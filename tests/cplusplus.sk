namespace Skew.Tests {
  def testCPlusPlus {

# Test entry point
test("
@entry
def main {}
", "
void main() {
}
").cpp

# Test entry point
test("
@entry
def main int {
  return 0
}
", "
int main() {
  return 0;
}
").cpp

# Test entry point
test("
@entry
def main(x List<string>) {
}
", "
void main(List<string> *x) {
}
").cpp

# Test entry point
test("
@entry
def main(x List<string>) int {
  return x.count
}
", "
int main(List<string> *x) {
  return x->count();
}
").cpp

# Basic class hierarchy
test("
@export
class Foo {
  const instanceVariable1 int
  const instanceVariable2 = 0
  def instanceMethod {}
  def instanceMethod2 {}
}

namespace Foo {
  const staticVariable = 0
}

@export
class Bar : Foo {
  const instanceVariable3 int
  const instanceVariable4 = 0
  over instanceMethod { super }
  def instanceMethod3 {}
}

namespace Bar {
  const staticVariable2 = 0
}
", "
struct Foo;
struct Bar;

struct Foo {
  virtual void instanceMethod();
  void instanceMethod2();
  Foo(int instanceVariable1);

  int instanceVariable1;
  int instanceVariable2;
  static int staticVariable;
};

struct Bar : Foo {
  virtual void instanceMethod() override;
  void instanceMethod3();
  Bar(int instanceVariable1, int instanceVariable3);

  int instanceVariable3;
  int instanceVariable4;
  static int staticVariable2;
};

int Foo::staticVariable = 0;
int Bar::staticVariable2 = 0;

void Foo::instanceMethod() {
}

void Foo::instanceMethod2() {
}

Foo::Foo(int instanceVariable1) {
  this->instanceVariable1 = instanceVariable1;
  this->instanceVariable2 = 0;
}

void Bar::instanceMethod() {
  Foo::instanceMethod();
}

void Bar::instanceMethod3() {
}

Bar::Bar(int instanceVariable1, int instanceVariable3) : Foo::Foo(instanceVariable1) {
  this->instanceVariable3 = instanceVariable3;
  this->instanceVariable4 = 0;
}
").cpp

# Basic interface usage
test("
@export
class Foo :: Bar, Baz {
  def instanceMethod {}
  def instanceMethod(x int) {}
  def instanceMethod2 {}
}

interface Bar {
  def instanceMethod
  def instanceMethod(x int)
}

interface Baz {
  def instanceMethod
  def instanceMethod2
}
", "
struct Bar;

struct Baz;

struct Foo;

struct Bar {
  virtual void instanceMethod() = 0;
  virtual void instanceMethod(int x) = 0;
};

struct Baz {
  virtual void instanceMethod() = 0;
  virtual void instanceMethod2() = 0;
};

struct Foo : Bar, Baz {
  virtual void instanceMethod();
  virtual void instanceMethod(int x);
  virtual void instanceMethod2();
  Foo();
};

void Foo::instanceMethod() {
}

void Foo::instanceMethod(int x) {
}

void Foo::instanceMethod2() {
}

Foo::Foo() {
}
").cpp

# Interface usage with tree shaking
test("
class Foo :: Bar, Baz {
  def instanceMethod {}
  def instanceMethod(x int) {}
  def instanceMethod2 {}
}

interface Bar {
  def instanceMethod
  def instanceMethod(x int)
}

interface Baz {
  def instanceMethod
  def instanceMethod2
}

@export
def test {
  var foo = Foo.new
  foo.instanceMethod
}
", "
struct Bar;

struct Baz;

struct Foo;

struct Bar {
  virtual void instanceMethod1() = 0;
};

struct Baz {
  virtual void instanceMethod1() = 0;
};

struct Foo : Bar, Baz {
  virtual void instanceMethod1();
  Foo();
};

void test() {
  Foo *foo = new Foo();
  foo->instanceMethod1();
}

void Foo::instanceMethod1() {
}

Foo::Foo() {
}
").cpp

# Type wrapping
test("
type Foo : double {
  def scaleBy(scale Foo) Foo {
    return ((self as double) * (scale as double)) as Foo
  }
}

namespace Foo {
  const FOO = 0.5 as Foo
}

@export
def test(x double) Foo {
  return (x as Foo).scaleBy(Foo.FOO)
}
", "
namespace Foo {
  double scaleBy(double self, double scale);
}

namespace Foo {
  double FOO = 0.5;
}

double test(double x) {
  return Foo::scaleBy(x, Foo::FOO);
}

double Foo::scaleBy(double self, double scale) {
  return self * scale;
}
").cpp

# Casting between enums and integers must be explicit
test("
enum Foo {
  FOO
}

@export
def test Foo {
  var x = Foo.FOO
  return ((x as int) * 1) as Foo
}
", "
enum struct Foo {
  FOO = 0,
};

Foo test() {
  Foo x = Foo::FOO;
  return (Foo)((int)x * 1);
}
").cpp

# Lists and maps
test("
@export
def foo {
  var x = [1, 2, 3]
  var y = {1: 2, 3: 4}
  var z = {\"1\": 2, \"3\": 4}
}
", "
#include <utility>

void foo() {
  List<int> *x = new List<int>({1, 2, 3});
  IntMap<int> *y = new IntMap<int>({std::make_pair(1, 2), std::make_pair(3, 4)});
  StringMap<int> *z = new StringMap<int>({std::make_pair(\"1\"_s, 2), std::make_pair(\"3\"_s, 4)});
}
").cpp

# Test math constants
test("
@export
def main {
  dynamic.foo(Math.NAN, Math.INFINITY, -Math.INFINITY)
  dynamic.foo(Math.NAN.toString, Math.INFINITY.toString, (-Math.INFINITY).toString)
}
", "
void main() {
  foo(0.0 / 0.0, 1.0 / 0.0, -(1.0 / 0.0));
  foo(doubleToString(0.0 / 0.0), doubleToString(1.0 / 0.0), doubleToString(-(1.0 / 0.0)));
}
").cpp.inlineAllFunctions

# Test math constants
test("
@export
def main {
  dynamic.foo(Math.NAN, Math.INFINITY, -Math.INFINITY)
  dynamic.foo(Math.NAN.toString, Math.INFINITY.toString, (-Math.INFINITY).toString)
}
", "
#include <math.h>

void main() {
  foo(NAN, INFINITY, -INFINITY);
  foo(doubleToString(NAN), doubleToString(INFINITY), doubleToString(-INFINITY));
}
").cpp.inlineAllFunctions.foldAllConstants

# Test math toString
test("
@export
def main {
  dynamic.foo(0.toString, 1.0.toString, (-1.0).toString, 0.5.toString, (-0.5).toString)
}
", "
void main() {
  foo(intToString(0), doubleToString(1.0), doubleToString(-1.0), doubleToString(0.5), doubleToString(-0.5));
}
").cpp.inlineAllFunctions

# Double literals must be emitted with a decimal point
test("
@export
def main(x double) {
  x = 1.0 / 2.0
  x = 1e100 / 2e100
  x = 1e-100 / 2e-100
  x = 1.5 / 2.5
  x = 1.5e100 / 2.5e100
  x = 1.5e-100 / 2.5e-100
}
", "
void main(double x) {
  x = 1.0 / 2.0;
  x = 1.0e+100 / 2.0e+100;
  x = 1.0e-100 / 2.0e-100;
  x = 1.5 / 2.5;
  x = 1.5e+100 / 2.5e+100;
  x = 1.5e-100 / 2.5e-100;
}
").cpp

# Check for a crash when converting switch statements to if chains
test("
@export
def main {
  switch \"a\" {
    case \"b\" {}
    case \"c\" {}
    default {}
  }
}
", "
void main() {
  string value = \"a\"_s;

  if (value == \"b\"_s) {
  }

  else if (value == \"c\"_s) {
  }

  else {
  }
}
").cpp

# Check different integer types
test("
enum Foo {
  A, B

  def foo {}
}

flags Bar {
  C, D

  def foo {}
}

type Baz : int {
  def foo {}
}

namespace Baz {
  const X = 0 as Baz
}

@export
def test int {
  var a = Foo.A
  var c = Bar.C
  var x = 0 as Baz
  a.foo
  c.foo
  x.foo
  return a + c + x as int + Foo.B + Bar.D + Baz.X as int
}
", "
enum struct Foo {
  A = 0,
  B = 1,
};

struct Bar {
  enum {
    C = 1,
    D = 2,
  };
};

namespace Baz {
  void foo(int self);
}

namespace in_Foo {
  void foo(Foo self);
}

namespace in_Bar {
  void foo(int self);
}

namespace Baz {
  int X = 0;
}

int test() {
  Foo a = Foo::A;
  int c = Bar::C;
  int x = 0;
  in_Foo::foo(a);
  in_Bar::foo(c);
  Baz::foo(x);
  return (int)a + c + x + (int)Foo::B + Bar::D + Baz::X;
}

void Baz::foo(int self) {
}

void in_Foo::foo(Foo self) {
}

void in_Bar::foo(int self) {
}
").cpp

# Check code generation for flags types
test("
flags Foo {
  X0
  X1
  X2
  X3
  X4
  X5
  X6
  X7
  X8
  X9

  X10
  X11
  X12
  X13
  X14
  X15
  X16
  X17
  X18
  X19

  X20
  X21
  X22
  X23
  X24
  X25
  X26
  X27
  X28
  X29

  X30
  X31
}

@export
def test {
  if !((.X0 | .X1) in (Foo.X30 | .X31)) {
    var x = Foo.X0
    x = .X1 | .X2
    x &= ~.X3
  }
}
", "
struct Foo {
  enum {
    X0 = 1,
    X1 = 2,
    X2 = 4,
    X3 = 8,
    X30 = 1073741824,
    X31 = -2147483648,
  };
};

void test() {
  if (!(((Foo::X0 | Foo::X1) & (Foo::X30 | Foo::X31)) != 0)) {
    int x = Foo::X0;
    x = Foo::X1 | Foo::X2;
    x &= ~Foo::X3;
  }
}
").cpp

# Check dynamic types
test("
@export
def test(foo dynamic.Foo) dynamic.Bar {
  return foo as dynamic.Bar + 0 as dynamic.Int + 0 as dynamic
}
", "
Bar test(Foo foo) {
  return (Bar)foo + (Int)0 + 0;
}
").cpp

# Check bit shifts
test("
@export
def test(x int) {
  x = x << x
  x = x >> x
  x = x >>> x
  x <<= x
  x >>= x
  x >>>= x
}
", "
namespace in_int {
  int unsignedRightShift(int self, int x);
}

void test(int x) {
  x = x << x;
  x = x >> x;
  x = in_int::unsignedRightShift(x, x);
  x <<= x;
  x >>= x;
  x = in_int::unsignedRightShift(x, x);
}

int in_int::unsignedRightShift(int self, int x) {
  return (int)((unsigned)self >> x);
}
").cpp

# Test lambda conversion with scope capture and currying
test("
@export
class Foo {
  var value = 0

  def test(x int) int {
    var y = 0
    var f = (a int) => => (b int) => => value + x + y + a + b
    return f(1)()(2)()
  }
}
", "
struct Foo;
struct Env1;
struct Lambda1;
struct Lambda21;
struct Lambda31;
struct Lambda41;

struct Foo {
  int test(int x);
  Foo();

  int value;
};

struct Env1 {
  Env1();

  Foo *self;
  int x;
  int y;
};

struct Lambda1 : Fn1<Fn0<Fn1<Fn0<int> *, int> *> *, int> {
  Lambda1(Env1 *copy);
  virtual Fn0<Fn1<Fn0<int> *, int> *> *run(int a);

  int a;
  Env1 *copy;
};

struct Lambda21 : Fn0<Fn1<Fn0<int> *, int> *> {
  Lambda21(Env1 *copy, Lambda1 *copy1);
  virtual Fn1<Fn0<int> *, int> *run();

  Env1 *copy;
  Lambda1 *copy1;
};

struct Lambda31 : Fn1<Fn0<int> *, int> {
  Lambda31(Env1 *copy, Lambda1 *copy1);
  virtual Fn0<int> *run(int b);

  int b;
  Env1 *copy;
  Lambda1 *copy1;
};

struct Lambda41 : Fn0<int> {
  Lambda41(Env1 *copy, Lambda1 *copy1, Lambda31 *copy2);
  virtual int run();

  Env1 *copy;
  Lambda1 *copy1;
  Lambda31 *copy2;
};

int Foo::test(int x) {
  Env1 *env = new Env1();
  env->self = this;
  env->x = x;
  env->y = 0;
  Fn1<Fn0<Fn1<Fn0<int> *, int> *> *, int> *f = new Lambda1(env);
  return f->run(1)->run()->run(2)->run();
}

Foo::Foo() {
  this->value = 0;
}

Env1::Env1() {
}

Lambda1::Lambda1(Env1 *copy) {
  this->copy = copy;
}

Fn0<Fn1<Fn0<int> *, int> *> *Lambda1::run(int a) {
  this->a = a;
  return new Lambda21(this->copy, this);
}

Lambda21::Lambda21(Env1 *copy, Lambda1 *copy1) {
  this->copy = copy;
  this->copy1 = copy1;
}

Fn1<Fn0<int> *, int> *Lambda21::run() {
  return new Lambda31(this->copy, this->copy1);
}

Lambda31::Lambda31(Env1 *copy, Lambda1 *copy1) {
  this->copy = copy;
  this->copy1 = copy1;
}

Fn0<int> *Lambda31::run(int b) {
  this->b = b;
  return new Lambda41(this->copy, this->copy1, this);
}

Lambda41::Lambda41(Env1 *copy, Lambda1 *copy1, Lambda31 *copy2) {
  this->copy = copy;
  this->copy1 = copy1;
  this->copy2 = copy2;
}

int Lambda41::run() {
  return this->copy->self->value + this->copy->x + this->copy->y + this->copy1->a + this->copy2->b;
}
").cpp

# Test lambda conversion at global scope
test("
var f = (x int) => (y int) => x + y

@entry
def test int {
  return f(1)(2)
}
", "
struct Lambda1;
struct Lambda21;

struct Lambda1 : Fn1<Fn1<int, int> *, int> {
  Lambda1();
  virtual Fn1<int, int> *run(int x);

  int x;
};

struct Lambda21 : Fn1<int, int> {
  Lambda21(Lambda1 *copy);
  virtual int run(int y);

  Lambda1 *copy;
};

Fn1<Fn1<int, int> *, int> *f = new Lambda1();

int test() {
  return f->run(1)->run(2);
}

Lambda1::Lambda1() {
}

Fn1<int, int> *Lambda1::run(int x) {
  this->x = x;
  return new Lambda21(this);
}

Lambda21::Lambda21(Lambda1 *copy) {
  this->copy = copy;
}

int Lambda21::run(int y) {
  return this->copy->x + y;
}
").cpp

# Check for a crash with nested loop handling
test("
@export
def test {
  var foo = 0
  var bar = () int => {
    while true {
      for baz in [1] {
        return foo + baz
      }
    }
  }
  bar()
}
", "
struct Env1;
struct Lambda1;

struct Env1 {
  Env1();

  int foo;
};

struct Lambda1 : Fn0<int> {
  Lambda1(Env1 *copy);
  virtual int run();

  Env1 *copy;
};

void test() {
  Env1 *env = new Env1();
  env->foo = 0;
  Fn0<int> *bar = new Lambda1(env);
  bar->run();
}

Env1::Env1() {
}

Lambda1::Lambda1(Env1 *copy) {
  this->copy = copy;
}

int Lambda1::run() {
  while (true) {
    for (int baz : *new List<int>({1})) {
      return this->copy->foo + baz;
    }
  }
}
").cpp

# Check that recursive lambdas work
test("
@export
def main {
  var f fn()
  f = => f()
  f()
}
", "
struct Env1;
struct Lambda1;

struct Env1 {
  Env1();

  FnVoid0 *f;
};

struct Lambda1 : FnVoid0 {
  Lambda1(Env1 *copy);
  virtual void run();

  Env1 *copy;
};

void main() {
  Env1 *env = new Env1();
  env->f = nullptr;
  env->f = new Lambda1(env);
  env->f->run();
}

Env1::Env1() {
}

Lambda1::Lambda1(Env1 *copy) {
  this->copy = copy;
}

void Lambda1::run() {
  this->copy->f->run();
}
").cpp

# Check for a crash in captured variable substitution
test("
@export
def main {
  var x = [1]
  var f = => x
  for y in x {}
  f()
}
", "
struct Env1;
struct Lambda1;

struct Env1 {
  Env1();

  List<int> *x;
};

struct Lambda1 : Fn0<List<int> *> {
  Lambda1(Env1 *copy);
  virtual List<int> *run();

  Env1 *copy;
};

void main() {
  Env1 *env = new Env1();
  env->x = new List<int>({1});
  Fn0<List<int> *> *f = new Lambda1(env);

  for (int y : *env->x) {
  }

  f->run();
}

Env1::Env1() {
}

Lambda1::Lambda1(Env1 *copy) {
  this->copy = copy;
}

List<int> *Lambda1::run() {
  return this->copy->x;
}
").cpp

# Test break statements inside a switch
test("
@export
def test(x int, y bool) {
  while true {
    switch x {
      case 0 {
        if y {
          break
        }
      }
    }
  }
}
", "
void test(int x, bool y) {
  while (true) {
    switch (x) {
      case 0: {
        if (y) {
          goto label;
        }
        break;
      }
    }
  }
  label:;
}
").cpp

  }
}
