- todo
  - comment parsing inside functions
  - make "self" explicit inside the compiler for sanity (all instance member NAME nodes become DOT nodes)
  - generics
  - real overload resolution involving types
  - need errors for ambiguous overloads at initialization time
  - interface auto-conversion and checking
  - automatic operator conversion so += can map to = and + if += isn't defined
  - throw/try/catch/finally
  - js generation
  - c++ generation
  - calling base class methods with "super"
  - annotations
  - compile-time constants
  - top-level if statements instead of c-style preprocessor, conditions must be constants and are evaluated from the outside in
  - inlining
  - automatic renaming, especially important for overloaded functions
    - could probably get by with just @rename for quite a while
  - lambda conversion to classes
  - abstract functions/types
  - import/export
  - standard library
    - use uppercase for namespaces now, camelCase is just too strange for namespaces for me
  - bootstrap the compiler
  - alias types using the "type" declaration prefix, not available inside functions?
  - namespace imports via the "use" declaration prefix

x done
  x argument type checking
  x return type and presence checking
  x function types including calling values of those types
  x lambda argument types from type context
  x deduplicate lambda types so equivalence checks using equality work




- test data:

var a = (q int) => 100
var b = => main

def main {
  var f = (q int) => 100
  var g = => main

  var x bool = a(false)
  var y = b()

  var z bool = f(false)
  var w = g()
}







- test data:

class Foo {
  def new {}
  def []=() {}
}

def main {
  Foo.new[ ]= false
  Foo.new[] = false
  Foo.new[]= false
}









- test data:

class Foo {
  def new {}
}

namespace Foo {
  def new(x int) Foo {
    return new
  }
}

def main {
  Foo.new
  Foo.new(100)
}










- test data:

class List {
  def new
  def new(count int)
  def foo
  def foo(count int)

  def bar {
    foo()
  }
}

def main(args List) {
  args.foo()
  start
}

def start {
  main(List.new())
}










- test data:

class List {
  def new
  def new(count int)
  def foo
  def foo(count int)

  def bar {
    foo
    foo(100)
  }
}

def main(args List) {
  args.foo
  args.foo(100)
  start
}

def start {
  main(List.new)
  main(List.new(100))
}










- test data:

namespace ns {
  namespace q {
    var x
    var y
    def foo()
    class Foo : Bar {}
  }
}

namespace ns {
  namespace q {
    var z = 100
    def foo() { return (1.5 as int).toString() }
    def foo() { return 200 }
    class Foo { def new() {} }
  }
  class Bar { def new() {} }
}
