- todo
  - comment parsing inside functions
  - make "self" explicit inside the compiler for sanity (all instance member NAME nodes become DOT nodes)
  - generics
  x argument type checking
    - real overload resolution involving types
    - need errors for ambiguous overloads at initialization time
  x return type and presence checking
  x function types including calling values of those types
  x lambda argument types from type context
  - deduplicate lambda types so equivalence checks using equality work
  - interface auto-conversion and checking
  - automatic operator conversion so += can map to = and + if += isn't defined
  - throw/try/catch/finally
  - js generation
  - c++ generation
  - annotations
  - compile-time constants
  - top-level if statements instead of c-style preprocessor, conditions must be constants and are evaluated from the outside in
  - inlining
  - automatic renaming, especially important for overloaded functions
    - could probably get by with just @rename for quite a while
  - lambda conversion to classes
  - abstract functions/types
  - import/export
  - standard library
    - use uppercase for namespaces now, camelCase is just too strange for namespaces for me
  - bootstrap the compiler
  - alias types using the "type" declaration prefix, not available inside functions?
  - namespace imports via the "use" declaration prefix
  - union and intersection types with | and &





- test data:

class Foo {
  def new {}
  def []=() {}
}

def main {
  Foo.new[ ]= false
  Foo.new[] = false
  Foo.new[]= false
}









- test data:

class Foo {
  def new {}
}

namespace Foo {
  def new(x int) Foo {
    return new
  }
}

def main {
  Foo.new
  Foo.new(100)
}










- test data:

class List {
  def new
  def new(count int)
  def foo
  def foo(count int)

  def bar {
    foo()
  }
}

def main(args List) {
  args.foo()
  start
}

def start {
  main(List.new())
}










- test data:

class List {
  def new
  def new(count int)
  def foo
  def foo(count int)

  def bar {
    foo
    foo(100)
  }
}

def main(args List) {
  args.foo
  args.foo(100)
  start
}

def start {
  main(List.new)
  main(List.new(100))
}










- test data:

namespace ns {
  namespace q {
    var x
    var y
    def foo()
    class Foo : Bar {}
  }
}

namespace ns {
  namespace q {
    var z = 100
    def foo() { return (1.5 as int).toString() }
    def foo() { return 200 }
    class Foo { def new() {} }
  }
  class Bar { def new() {} }
}


















- todo: figure out how these work
  x constructors
  x annotations
  - generic types
  - scopes
  - preprocessor
    - can just use normal if statements?







- ideas for annotation syntax:


adef @ExportAs(text string)
adef @ExportIf(x bool) = @If(x, @Export)
adef @ExportIf(x bool) = x ? @Export : null
adef @ExportIf(x bool) = x ? @Export : @
adef @IfElse(x bool, y dynamic, z dynamic) = @If(x, y) @If(!x, z)
adef @IfElse(x bool, y dynamic, z dynamic) = x ? y : z
adef @ExportIf(x bool) = x ? [@Export] : []
adef @IfElse(x bool, y dynamic, z dynamic) = [@If(x, y), @If(!x, z)]

// Like Python, seems sort of appropriate because it is a global function
def @ExportAs(text string)
def @ContentsOfFile(relativePath string) string
def @CallerFile() string
def @CallerLine() int
def @CallerText() string
def @If(value bool)
def @Import()
def @Export()
def @Flags()
def @ToString()

@If(BUILD_DEBUG)
def assert(value bool, file = @CallerFile, line = @CallerLine, text = @CallerText) {
  if (!value) {
    throw AssertionError.new(value, file, line, text)
  }
}

@Flags
@ToString
enum Foo {
  FOO
  BAR
}

// This is like C#/Java
class @ExportAs {
  var text string
}

- wait, why do annotations have to be different than normal forward-declared functions?



















- ideas for constructors syntax:


class Rect {
  new xywh(x double, y double, w double, h double) {
    ...
  }
}

class Rect {
  ctor xywh(x double, y double, w double, h double) {
    ...
  }
}

// I like this one the best. It makes replacing a constructor to a static method and back really easy.
class Rect {
  cdef new(x double, y double, w double, h double) {
    ...
  }
}

class Rect {
  def new(x double, y double, w double, h double) {
    ...
  }
}

class Rect {
  idef new(x double, y double, w double, h double) {
    ...
  }
}

class Rect {
  def Rect(x double, y double, w double, h double) {
    ...
  }
}

class Rect {
  idef Rect(x double, y double, w double, h double) {
    ...
  }
}

class Rect {
  new(x double, y double, w double, h double) {
    ...
  }
}





var a = Rect.xywh(50, 50, 200, 200)
var b = Rect.centerSize(Vector.new(100, 100), Vector.new(150, 150))
var c = Rect.originSize(Vector.new(100, 100), Vector.new(200, 200))

var a = Rect(x: 50, y: 50, w: 200, h: 200)
var b = Rect(center: Vector(x: 100, y: 100), size: Vector(x: 150, y: 150))
var c = Rect(origin: Vector(x: 100, y: 100), size: Vector(x: 200, y: 200))

var a = Rect(50, 50, 200, 200)
var b = Rect(Vector(100, 100), Vector(150, 150)) // These would be ambiguous
var c = Rect(Vector(100, 100), Vector(200, 200)) // These would be ambiguous






class Uint8Array {
  new(length int)
  new(values int[])
  new(buffer ArrayBuffer)
  idef subarray(start int, end int) Uint8Array
}

class Uint8Array {
  new withLength(length int)
  new withValues(values int[])
  new withBuffer(buffer ArrayBuffer)
  idef subarray(start int, end int) Uint8Array
}

class Uint8Array {
  cdef new(length int)
  cdef new(values int[])
  cdef new(buffer ArrayBuffer)
  idef subarray(start int, end int) Uint8Array
}

var bytes = Uint8Array.new(100)

class Uint8Array {
  def Uint8Array(length int)
  def Uint8Array(values int[])
  def Uint8Array(buffer ArrayBuffer)
  idef subarray(start int, end int) Uint8Array
}








- ideas for constructors semantics:
  - all classes without a user-defined constructor have a default constructor with named arguments that are optional if the variable declaration has an initializer
  - user-defined constructors may be overloaded
  - each constructor initializes all variables to their default values before entering the function body
  - a call to super() must be the first statement in the constructor for classes with base classes
  - it would also be awesome to be able to easily turn a constructor into a factory constructor that could return other objects, good for wrapping Object.create(), for example
    - could do this through a haxe-style abstract types http://haxe.org/manual/types-abstract.html

    class Derived extends Base {}
    class SafeString wraps string {}

    class Derived : Base {}
    class SafeString(string) {}

    class Derived : Base {}
    class SafeString is string {}








- idea for getter/setter syntax:

  // Getter
  def length double {
    return sqrt(x * x + y * y)
  }

  // Setter
  def length = v double {
    var scale = v / length
    x *= scale
    y *= scale
  }

  // Could maybe shorten to this with type inference
  def length {
    return sqrt(x * x + y * y)
  }






- idea for getter/setter syntax (I like this one better at the moment):

  // Getter
  get length() double {
    return sqrt(x * x + y * y)
  }

  // Setter
  set length(v double) {
    var scale = v / length
    x *= scale
    y *= scale
  }







- idea: use "soft keywords" so you could reuse keywords as identifiers without needing to obfuscate them

  var class = "hover"
  var set = HashSet()
  var def = FuncDef()

  - list: ivar, def, idef, interface, namespace, class, fn, set, get










- lambda syntax: use |...| like ruby/rust

  var square = |x| x * x
  var lengths = values.map(|v| v.length)
  range(0, lengths.size()).each(|i| {
    print(i + ": " + lengths[i])
  })

  def apply(x |int, int| int, a int, b int) int {
    return x(a, b)
  }

  - benefits:
    - familiar to many users
    - doesn't prevent adding tuples down the road using parentheses
    - very short, doesn't involve a keyword like javascript/python
  - drawbacks
    - what about lambdas which take lambdas as arguments? is the type ||int| int|? no way to distinguish open from close
    - even simpler, can't differentiate between xomething with and without a type: "var x = |x| x * x" and "var y = |y |int| int| y(100)"
    - what about specifying the return type? right now it would look like the return value the the parser





- lambda syntax: use <...>, never seen this one before

  var square = <x> x * x
  var lengths = values.map(<v> v.length)
  range(0, lengths.size()).each(<i> {
    print(i + ": " + lengths[i])
  })

  def apply(x <int, int> int, a int, b int) int {
    return x(a, b)
  }

  - benefits:
    - syntactically unambiguous
  - drawbacks
    - unfamiliar







- lambda syntax: use a keyword like javascript

  var square = def(x) x * x
  var lengths = values.map(def(v) v.length)
  range(0, lengths.size()).each(def(i) {
    print(i + ": " + lengths[i])
  })

  def apply(x def(int, int) int, a int, b int) int {
    return x(a, b)
  }

  - benefits:
    - similar to function declaration
    - syntactically unambiguous
    - naturally allows specifying the return type
  - drawbacks
    - very wordy








- lambda syntax: use a slash like haskell

  var square = \x -> x * x
  var lengths = values.map(\v -> v.length)
  range(0, lengths.size()).each(\i -> {
    print(i + ": " + lengths[i])
  })

  def apply(x \int, int -> int, a int, b int) int {
    return x(a, b)
  }

  - benefits:
    - very short
  - drawbacks
    - slash looks strange, kind of unbalanced
    - type syntax doesn't make sense, very hard to parse with commas in the middle







- lambda syntax: use an arrow like c#/coffeescript

  var square = x => x * x
  var lengths = values.map(v => v.length)
  range(0, lengths.size()).each(i => {
    print(i + ": " + lengths[i])
  })

  def apply(x (int, int) => int, a int, b int) int {
    return x(a, b)
  }

  - benefits:
    - short and familiar
  - drawbacks
    - open parenthesis would need help from the pre-parser pass to work
    - what about specifying the return type? right now it would look like the return value the the parser
    - awkward when return type is void, leaving it off looks like a tuple instead













- lambda syntax: use an arrow like c#/coffeescript for lambdas and a keyword for types

  var square = x => x * x
  var lengths = values.map(v => v.length)
  range(0, lengths.size()).each(i => {
    print(i + ": " + lengths[i])
  })

  def apply(x def(int, int) int, a int, b int) int {
    return x(a, b)
  }

  - benefits:
    - short and familiar
  - drawbacks
    - open parenthesis may need help from the pre-parser pass to work







- lambda syntax: use a keyword like go/tart

  var square = fn(x) x * x
  var lengths = values.map(fn(v) v.length)
  range(0, lengths.size()).each(fn(i) {
    print(i + ": " + lengths[i])
  })

  def apply(x fn(int, int) int, a int, b int) int {
    return x(a, b)
  }

  - benefits:
    - short
    - syntactically unambiguous
  - drawbacks
    - looks a little odd, and longer than I'd like













- lambda syntax: use a keyword and arrow like dart, unify that into

  var square = def(x) => x * x
  var lengths = values.map(def(v) => v.length)
  range(0, lengths.size()).each(def(i) {
    print(i + ": " + lengths[i])
  })

  def apply(x def(int, int) int, a int, b int) int => x(a, b)

  - benefits:
    - short
    - syntactically unambiguous
    - unified with regular functions
  - drawbacks
    - looks a little odd, and longer than I'd like







- lambda syntax: use a keyword like python

  var square = fn x: x * x
  var lengths = values.map(fn v: v.length)
  range(0, lengths.size()).each(fn i: {
    print(i + ": " + lengths[i])
  })

  def apply(x fn int, int: int, a int, b int) int {
    return x(a, b)
  }

  - benefits:
    - lack of parentheses make it easier to parse
  - drawbacks
    - nested types would look like

        var x fn fn a: b, fn a: b: c

      which is parsed as

        var x fn (fn a: b), (fn a: b) -> c







- lambda syntax: use a keyword like python but with an arrow

  var square = fn x -> x * x
  var lengths = values.map(fn v -> v.length)
  range(0, lengths.size()).each(fn i -> {
    print(i + ": " + lengths[i])
  })

  def apply(x fn int, int -> int, a int, b int) int {
    return x(a, b)
  }

  - benefits:
    - lack of parentheses make it easier to parse
  - drawbacks
    - nested types would look like

        var x fn fn a -> b, fn a -> b -> c

      which is parsed as

        var x fn (fn a -> b), (fn a -> b) -> c
