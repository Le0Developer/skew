- todo
  - automatic constructor generation
  - interface auto-conversion and checking
  - automatic operator conversion so += can map to = and + if += isn't defined
  - throw/try/catch/finally
  - js generation
  - c++ generation
  - compile-time constants
  - top-level if statements instead of c-style preprocessor, conditions must be constants and are evaluated from the outside in
  - inlining
  - automatic renaming, especially important for overloaded functions
    - could probably get by with just @rename for quite a while
  - lambda conversion to classes
  - abstract functions/types
  - standard library
  - bootstrap the compiler
  - alias types using the "type" declaration prefix, not available inside functions?
  - namespace imports via the "use" declaration prefix

x done
  x base classes
    x calling base class methods with "super"
    x method overloading with base and derived methods
  x support for protected access level
  x annotations
  x do [list] and {initializer} expressions, require [new] and {new} constructors and use [...] and {...} as operator names for appending
    x {...} can take one argument or two arguments using ":" as a separator
  x generics
  x real overload resolution involving types
  x need errors for ambiguous overloads at initialization time
  x make "self" explicit inside the compiler for sanity (all instance member NAME nodes become DOT nodes)
  x comment parsing inside functions
  x argument type checking
  x return type and presence checking
  x function types including calling values of those types
  x lambda argument types from type context
  x deduplicate lambda types so equivalence checks using equality work
