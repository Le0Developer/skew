namespace skew {
  # The same operator precedence as C for the most part
  enum Precedence {
    LOWEST
    ASSIGN
    LOGICAL_OR
    LOGICAL_AND
    BITWISE_OR
    BITWISE_XOR
    BITWISE_AND
    EQUAL
    COMPARE
    SHIFT
    ADD
    MULTIPLY
    UNARY_PREFIX
    UNARY_POSTFIX
    MEMBER
  }

  class ParserContext {
    var log Log
    var inNonVoidFunction = false
    var needsPreprocessor = false

    @private {
      var tokens List<Token>
      var index = 0

      # Keep track of the previous syntax error so only one syntax error is emitted
      # per token when recovering from a parse error. For example:
      #
      #   int x = (1 + (2 +
      #
      # In the code above, the only syntax error should be about an unexpected
      # end of file and not also about the two missing right parentheses.
      var previousSyntaxError Token = null
    }

    def current Token {
      return tokens[index]
    }

    def next Token {
      var token = current
      if index + 1 < tokens.count {
        index += 1
      }
      return token
    }

    def spanSince(range Range) Range {
      var previous = tokens[index > 0 ? index - 1 : 0]
      return previous.range.end < range.start ? range : Range.span(range, previous.range)
    }

    def peek(kind TokenKind) bool {
      return current.kind == kind
    }

    def eat(kind TokenKind) bool {
      if peek(kind) {
        next
        return true
      }
      return false
    }

    def undo {
      assert(index > 0)
      index -= 1
    }

    def expect(kind TokenKind) bool {
      if !eat(kind) {
        var token = current
        if previousSyntaxError != token {
          var range = token.range
          log.syntaxErrorExpectedToken(range, token.kind, kind)
          previousSyntaxError = token
        }
        return false
      }
      return true
    }

    def unexpectedToken {
      var token = current
      if previousSyntaxError != token {
        log.syntaxErrorUnexpectedToken(token)
        previousSyntaxError = token
      }
    }
  }

  class Parselet {
    var precedence Precedence
    var prefix fn(ParserContext) Node = null
    var infix fn(ParserContext, Node) Node = null
  }

  # A Pratt parser is a parser that associates up to two operations per token,
  # each with its own precedence. Pratt parsers excel at parsing expression
  # trees with deeply nested precedence levels. For an excellent writeup, see:
  #
  #   http:#journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/
  #
  class Pratt {
    @private
    var table = IntMap<Parselet>.new

    def parselet(kind TokenKind, precedence Precedence) Parselet {
      var parselet = table.get(kind, null)
      if parselet == null {
        var created = Parselet.new(precedence)
        parselet = created
        table[kind] = created
      } else if precedence as int > parselet.precedence as int {
        parselet.precedence = precedence
      }
      return parselet
    }

    def parse(context ParserContext, precedence Precedence) Node {
      var token = context.current
      var parselet = table.get(token.kind, null)
      if parselet == null || parselet.prefix == null {
        context.unexpectedToken
        return null
      }
      var node = resume(context, precedence, parselet.prefix(context))
      assert(node == null || node.range != null) # Parselets must set the range of every node
      return node
    }

    def resume(context ParserContext, precedence Precedence, left Node) Node {
      while left != null {
        var kind = context.current.kind
        var parselet = table.get(kind, null)
        if parselet == null || parselet.infix == null || parselet.precedence as int <= precedence as int {
          break
        }
        left = parselet.infix(context, left)
        assert(left == null || left.range != null) # Parselets must set the range of every node
      }
      return left
    }

    def hasPrefixParselet(context ParserContext) bool {
      var parselet = table.get(context.current.kind, null)
      return parselet != null && parselet.prefix != null
    }

    def literal(kind TokenKind, callback fn(ParserContext, Token) Node) {
      parselet(kind, .LOWEST).prefix = context => callback(context, context.next)
    }

    def prefix(kind TokenKind, precedence Precedence, callback fn(ParserContext, Token, Node) Node) {
      parselet(kind, .LOWEST).prefix = context => {
        var token = context.next
        var value = parse(context, precedence)
        return value != null ? callback(context, token, value) : null
      }
    }

    def postfix(kind TokenKind, precedence Precedence, callback fn(ParserContext, Node, Token) Node) {
      parselet(kind, precedence).infix = (context, left) => callback(context, left, context.next)
    }

    def infix(kind TokenKind, precedence Precedence, callback fn(ParserContext, Node, Token, Node) Node) {
      parselet(kind, precedence).infix = (context, left) => {
        var token = context.next
        var right = parse(context, precedence)
        return right != null ? callback(context, left, token, right) : null
      }
    }

    def infixRight(kind TokenKind, precedence Precedence, callback fn(ParserContext, Node, Token, Node) Node) {
      parselet(kind, precedence).infix = (context, left) => {
        var token = context.next
        var right = parse(context, (precedence as int - 1) as Precedence) # Subtract 1 for right-associativity
        return right != null ? callback(context, left, token, right) : null
      }
    }
  }
}
