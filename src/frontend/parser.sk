namespace Skew {
  enum PassKind {
    PARSING
  }

  class ParsingPass : Pass {
    over kind PassKind {
      return .PARSING
    }

    over run(context PassContext) {
      for tokens in context.tokens {
        Parsing.parseFile(context.log, tokens, context.global)
      }
    }
  }
}

namespace Skew.Parsing {
  var expressionParser Pratt
  var typeParser Pratt

  def parseDoubleLiteral(text string) double

  def parseIntLiteral(log Log, range Range) Box<int> {
    var text = range.toString
    var isNegative = text.startsWith("-") # Parse negative signs for use with the "--define" flag
    var start = isNegative as int
    var count = text.count
    var value = 0
    var base = 10

    # Parse the base
    if start + 2 < count && text[start] == '0' {
      var c = text[start + 1]
      if c == 'b' {
        base = 2
        start += 2
      } else if c == 'o' {
        base = 8
        start += 2
      } else if c == 'x' {
        base = 16
        start += 2
      }
    }

    # There must be numbers after the base
    if start == count {
      return null
    }

    # Special-case hexadecimal since it's more complex
    if base == 16 {
      for i in start..text.count {
        var c = text[i]
        if (c < '0' || c > '9') && (c < 'A' || c > 'F') && (c < 'a' || c > 'f') {
          return null
        }
        value = value * 16 + c - (c <= '9' ? '0' : c <= 'F' ? 'A' - 10 : 'a' - 10)
      }
    }

    # All other bases are zero-relative
    else {
      for i in start..text.count {
        var c = text[i]
        if c < '0' || c >= '0' + base {
          return null
        }
        value = value * base + c - '0'
      }
    }

    # Warn about decimal integers that start with "0" because other languages
    # strangely treat these numbers as octal instead of decimal
    if base == 10 && value != 0 && text[0] == '0' {
      log.syntaxWarningOctal(range)
    }

    return Box<int>.new(isNegative ? -value : value)
  }

  def checkExtraParentheses(context ParserContext, node Node) {
    if node.isInsideParentheses {
      context.log.semanticWarningExtraParentheses(node.range)
    }
  }

  def parseLeadingComments(context ParserContext) List<string> {
    var comments List<string> = null
    while context.peek(.COMMENT) {
      var range = context.next.range
      comments ?= []
      comments.append(range.source.contents.slice(range.start + 1, range.end))

      # Ignore blocks of comments with extra lines afterward
      if context.eat(.NEWLINE) {
        comments = null
      }
    }
    return comments
  }

  def parseTrailingComment(context ParserContext, comments List<string>) List<string> {
    if context.peek(.COMMENT) {
      var range = context.next.range
      comments ?= []
      var text = range.source.contents.slice(range.start + 1, range.end)
      if text[text.count - 1] != '\n' {
        text += "\n"
      }
      comments.append(text)
      return comments
    }
    return null
  }

  def parseAnnotations(context ParserContext, annotations List<Node>) List<Node> {
    while context.peek(.ANNOTATION) {
      var range = context.next.range
      var value = Node.createName(range.toString).withRange(range)

      # Change "@foo.bar.baz" into "foo.bar.@baz"
      if context.peek(.DOT) {
        var root = value.asString
        value.content = StringContent.new(root.slice(1))
        while context.eat(.DOT) {
          var name = context.current.range
          if !context.expect(.IDENTIFIER) {
            return null
          }
          value = Node.createDot(value, name.toString).withRange(context.spanSince(range)).withInternalRange(name)
        }
        value.content = StringContent.new("@" + value.asString)
      }

      # Parse parentheses if present
      var token = context.current
      if context.eat(.LEFT_PARENTHESIS) {
        var call = Node.createCall(value)
        if !parseCommaSeparatedList(context, call, .RIGHT_PARENTHESIS) {
          return null
        }
        value = call.withRange(context.spanSince(range)).withInternalRange(context.spanSince(token.range))
      }

      # Parse a trailing if condition
      var test Node = null
      if context.eat(.IF) {
        test = expressionParser.parse(context, .LOWEST)
        if test == null {
          return null
        }
      }

      # All annotations must end in a newline to avoid confusion with the trailing if
      if !context.peek(.LEFT_BRACE) && !context.expect(.NEWLINE) {
        return null
      }

      annotations.append(Node.createAnnotation(value, test).withRange(context.spanSince(range)))
    }

    return annotations
  }

  def parseVarOrConst(context ParserContext) Node {
    var variables = Node.createVariables
    var token = context.next

    while true {
      var range = context.current.range

      if !context.expect(.IDENTIFIER) {
        return null
      }

      var symbol = VariableSymbol.new(.VARIABLE_LOCAL, range.toString)
      symbol.range = range

      if token.kind == .CONST {
        symbol.flags |= Symbol.IS_CONST
      }

      if peekType(context) {
        symbol.type = parseType(context)
        if symbol.type == null {
          return null
        }
      }

      if context.eat(.ASSIGN) {
        symbol.value = expressionParser.parse(context, .LOWEST)
        if symbol.value == null {
          return null
        }
      }

      variables.appendChild(Node.createVariable(symbol).withRange(context.spanSince(range)))

      if !context.eat(.COMMA) {
        break
      }
    }

    return variables.withRange(context.spanSince(token.range))
  }

  def parseJump(context ParserContext) Node {
    var token = context.next
    return (token.kind == .BREAK ? Node.createBreak : Node.createContinue).withRange(token.range)
  }

  def parseReturn(context ParserContext) Node {
    var token = context.next
    var value Node = null
    if !context.peek(.NEWLINE) && !context.peek(.COMMENT) && !context.peek(.RIGHT_BRACE) {
      value = expressionParser.parse(context, .LOWEST)
      if value == null {
        return null
      }
      checkExtraParentheses(context, value)
    }
    return Node.createReturn(value).withRange(context.spanSince(token.range))
  }

  def parseSwitch(context ParserContext) Node {
    var token = context.next
    var value = expressionParser.parse(context, .LOWEST)
    if value == null {
      return null
    }
    checkExtraParentheses(context, value)
    var node = Node.createSwitch(value)

    if !context.expect(.LEFT_BRACE) {
      return null
    }

    context.eat(.NEWLINE)
    while !context.peek(.RIGHT_BRACE) {
      var comments = parseLeadingComments(context)

      # Ignore trailing comments
      if context.peek(.RIGHT_BRACE) || context.peek(.END_OF_FILE) {
        break
      }

      # Parse a new case
      var child = Node.createCase
      var start = context.current
      if context.eat(.CASE) {
        while true {
          var constant = expressionParser.parse(context, .LOWEST)
          if constant == null {
            return null
          }
          checkExtraParentheses(context, constant)
          child.appendChild(constant)
          if !context.eat(.COMMA) {
            break
          }
        }
      }

      # Default cases have no values
      else if !context.eat(.DEFAULT) {
        context.expect(.CASE)
        return null
      }

      # Use a block instead of requiring "break" at the end
      var block = parseBlock(context)
      if block == null {
        return null
      }

      # Create the case
      child.comments = comments
      node.appendChild(child.appendChild(block).withRange(context.spanSince(start.range)))

      # Parse trailing comments and/or newline
      comments = parseTrailingComment(context, comments)
      if comments != null {
        child.comments = comments
        context.eat(.NEWLINE)
      } else if context.peek(.RIGHT_BRACE) || !context.expect(.NEWLINE) {
        break
      }
    }

    if !context.expect(.RIGHT_BRACE) {
      return null
    }

    return node.withRange(context.spanSince(token.range))
  }

  def parseFor(context ParserContext) Node {
    var token = context.next
    var range = context.current.range

    if !context.expect(.IDENTIFIER) {
      return null
    }

    # for a in b {}
    if context.eat(.IN) {
      var symbol = VariableSymbol.new(.VARIABLE_LOCAL, range.toString)
      symbol.range = range

      var value = expressionParser.parse(context, .LOWEST)
      if value == null {
        return null
      }

      if context.eat(.DOT_DOT) {
        var second = expressionParser.parse(context, .LOWEST)
        if second == null {
          return null
        }
        value = Node.createPair(value, second).withRange(Range.span(value.range, second.range))
      }
      checkExtraParentheses(context, value)

      var block = parseBlock(context)
      if block == null {
        return null
      }

      return Node.createForeach(symbol, value, block).withRange(context.spanSince(token.range))
    }

    # for a = 0; a < 10; a++ {}
    var setup = Node.createVariables
    context.undo

    while true {
      var nameRange = context.current.range

      if !context.expect(.IDENTIFIER) {
        return null
      }

      var symbol = VariableSymbol.new(.VARIABLE_LOCAL, nameRange.toString)
      symbol.range = nameRange

      if peekType(context) {
        symbol.type = parseType(context)
        if symbol.type == null {
          return null
        }
      }

      if context.eat(.ASSIGN) {
        symbol.value = expressionParser.parse(context, .LOWEST)
        if symbol.value == null {
          return null
        }
        checkExtraParentheses(context, symbol.value)
      }

      setup.appendChild(Node.createVariable(symbol).withRange(context.spanSince(nameRange)))

      if !context.eat(.COMMA) {
        break
      }
    }
    setup.range = context.spanSince(range)

    if !context.expect(.SEMICOLON) {
      return null
    }

    var test = expressionParser.parse(context, .LOWEST)
    if test == null {
      return null
    }

    if !context.expect(.SEMICOLON) {
      return null
    }

    var update = expressionParser.parse(context, .LOWEST)
    if update == null {
      return null
    }

    # This is the one place in the grammar that sequence expressions are allowed
    if context.eat(.COMMA) {
      update = Node.createSequence.appendChild(update)
      while true {
        var value = expressionParser.parse(context, .LOWEST)
        if value == null {
          return null
        }
        update.appendChild(value)
        if !context.eat(.COMMA) {
          break
        }
      }
    }

    var block = parseBlock(context)
    if block == null {
      return null
    }

    return Node.createFor(setup, test, update, block).withRange(context.spanSince(token.range))
  }

  def parseIf(context ParserContext) Node {
    var token = context.next
    var test = expressionParser.parse(context, .LOWEST)
    if test == null {
      return null
    }
    checkExtraParentheses(context, test)

    var trueBlock = parseBlock(context)
    if trueBlock == null {
      return null
    }

    return Node.createIf(test, trueBlock, null).withRange(context.spanSince(token.range))
  }

  def parseThrow(context ParserContext) Node {
    var token = context.next
    var value = expressionParser.parse(context, .LOWEST)
    if value == null {
      return null
    }
    checkExtraParentheses(context, value)
    return Node.createThrow(value).withRange(context.spanSince(token.range))
  }

  def parseTry(context ParserContext) Node {
    var token = context.next
    var tryBlock = parseBlock(context)
    if tryBlock == null {
      return null
    }
    return Node.createTry(tryBlock).withRange(context.spanSince(token.range))
  }

  def parseWhile(context ParserContext) Node {
    var token = context.next
    var test = expressionParser.parse(context, .LOWEST)
    if test == null {
      return null
    }
    checkExtraParentheses(context, test)

    var block = parseBlock(context)
    if block == null {
      return null
    }

    return Node.createWhile(test, block).withRange(context.spanSince(token.range))
  }

  def parseStatement(context ParserContext) Node {
    var token = context.current

    switch token.kind {
      case .BREAK, .CONTINUE { return parseJump(context) }
      case .CONST, .VAR { return parseVarOrConst(context) }
      case .FOR { return parseFor(context) }
      case .IF { return parseIf(context) }
      case .RETURN { return parseReturn(context) }
      case .SWITCH { return parseSwitch(context) }
      case .THROW { return parseThrow(context) }
      case .TRY { return parseTry(context) }
      case .WHILE { return parseWhile(context) }
    }

    var value = expressionParser.parse(context, .LOWEST)
    if value == null {
      return null
    }
    checkExtraParentheses(context, value)
    return Node.createExpression(value).withRange(value.range)
  }

  def parseStatements(context ParserContext, parent Node) bool {
    var previous Node = null
    context.eat(.NEWLINE)

    while !context.peek(.RIGHT_BRACE) {
      var comments = parseLeadingComments(context)

      # Ignore trailing comments
      if context.peek(.RIGHT_BRACE) || context.peek(.END_OF_FILE) {
        break
      }

      # Merge "else" statements with the previous "if"
      if context.peek(.ELSE) && previous != null && previous.kind == .IF && previous.ifFalse == null {
        context.next

        # Match "else if"
        if context.peek(.IF) {
          var statement = parseIf(context)
          if statement == null {
            return false
          }
          var falseBlock = Node.createBlock.withRange(statement.range).appendChild(statement)
          falseBlock.comments = comments
          previous.appendChild(falseBlock)
          previous = statement
        }

        # Match "else"
        else {
          var falseBlock = parseBlock(context)
          if falseBlock == null {
            return false
          }
          falseBlock.comments = comments
          previous.appendChild(falseBlock)
          previous = falseBlock
        }
      }

      # Merge "catch" statements with the previous "try"
      else if context.peek(.CATCH) && previous != null && previous.kind == .TRY && previous.finallyBlock == null {
        var catchToken = context.next
        var symbol VariableSymbol = null
        var nameRange = context.current.range

        # Optional typed variable
        if context.eat(.IDENTIFIER) {
          symbol = VariableSymbol.new(.VARIABLE_LOCAL, nameRange.toString)
          symbol.range = nameRange
          symbol.type = parseType(context)
          if symbol.type == null {
            return false
          }
        }

        # Manditory catch block
        var catchBlock = parseBlock(context)
        if catchBlock == null {
          return false
        }

        var child = Node.createCatch(symbol, catchBlock).withRange(context.spanSince(catchToken.range))
        child.comments = comments
        previous.appendChild(child)
      }

      # Merge "finally" statements with the previous "try"
      else if context.peek(.FINALLY) && previous != null && previous.kind == .TRY && previous.finallyBlock == null {
        context.next
        var finallyBlock = parseBlock(context)
        if finallyBlock == null {
          return false
        }
        finallyBlock.comments = comments
        previous.appendChild(finallyBlock)
      }

      # Parse a new statement
      else {
        var statement = parseStatement(context)
        if statement == null {
          break
        }
        previous = statement
        statement.comments = comments
        parent.appendChild(statement)
      }

      # Parse trailing comments and/or newline
      comments = parseTrailingComment(context, comments)
      if comments != null {
        if previous != null {
          previous.comments = comments
        }
        context.eat(.NEWLINE)
      } else if context.peek(.RIGHT_BRACE) || !context.peek(.ELSE) && !context.peek(.CATCH) && !context.peek(.FINALLY) && !context.expect(.NEWLINE) {
        break
      }
    }

    return true
  }

  def parseBlock(context ParserContext) Node {
    context.skipWhitespace
    var token = context.current
    if !context.expect(.LEFT_BRACE) {
      return null
    }
    var block = Node.createBlock
    if !parseStatements(context, block) || !context.expect(.RIGHT_BRACE) {
      return null
    }
    return block.withRange(context.spanSince(token.range))
  }

  def parseType(context ParserContext) Node {
    return typeParser.parse(context, .LOWEST)
  }

  def peekType(context ParserContext) bool {
    return context.peek(.IDENTIFIER) || context.peek(.DYNAMIC)
  }

  def parseFunctionBlock(context ParserContext, symbol FunctionSymbol) bool {
    # "=> x" is the same as "{ return x }"
    if symbol.kind == .FUNCTION_LOCAL {
      if !context.expect(.ARROW) {
        return false
      }
      if context.peek(.LEFT_BRACE) {
        symbol.block = parseBlock(context)
        if symbol.block == null {
          return false
        }
      } else {
        var value = expressionParser.parse(context, .LOWEST)
        if value == null {
          return false
        }
        symbol.block = Node.createBlock.withRange(value.range).appendChild(Node.createReturn(value).withRange(value.range).withFlags(Node.IS_IMPLICIT_RETURN))
      }
    }

    # Parse function body if present
    else if context.peek(.LEFT_BRACE) {
      symbol.block = parseBlock(context)
      if symbol.block == null {
        return false
      }
    }

    return true
  }

  def parseFunctionArguments(context ParserContext, symbol FunctionSymbol) bool {
    var usingTypes = false
    while !context.eat(.RIGHT_PARENTHESIS) {
      if !symbol.arguments.isEmpty && !context.expect(.COMMA) {
        return false
      }

      context.skipWhitespace

      var range = context.current.range
      if !context.expect(.IDENTIFIER) {
        return false
      }

      var arg = VariableSymbol.new(.VARIABLE_ARGUMENT, range.toString)
      arg.range = range

      # Parse argument type
      if symbol.kind != .FUNCTION_LOCAL || (symbol.arguments.isEmpty ? peekType(context) : usingTypes) {
        arg.type = parseType(context)
        if arg.type == null {
          return false
        }
        usingTypes = true
      }

      symbol.arguments.append(arg)
    }
    return true
  }

  def parseFunctionReturnTypeAndBlock(context ParserContext, symbol FunctionSymbol) bool {
    if peekType(context) {
      symbol.returnType = parseType(context)
    }
    return parseFunctionBlock(context, symbol)
  }

  def parseTypeParameters(context ParserContext, kind SymbolKind) List<ParameterSymbol> {
    var parameters List<ParameterSymbol> = []
    while true {
      var range = context.current.range
      var name = range.toString
      if !context.expect(.IDENTIFIER) {
        return null
      }
      var symbol = ParameterSymbol.new(kind, name)
      symbol.range = range
      parameters.append(symbol)
      if !context.eat(.COMMA) {
        break
      }
    }
    if !context.expect(.END_PARAMETER_LIST) {
      return null
    }
    return parameters
  }

  const operatorOverloadTokenKinds IntMap<int> = {
    TokenKind.ASSIGN_BITWISE_AND: 0,
    TokenKind.ASSIGN_BITWISE_OR: 0,
    TokenKind.ASSIGN_BITWISE_XOR: 0,
    TokenKind.ASSIGN_DIVIDE: 0,
    TokenKind.ASSIGN_INDEX: 0,
    TokenKind.ASSIGN_MINUS: 0,
    TokenKind.ASSIGN_MULTIPLY: 0,
    TokenKind.ASSIGN_PLUS: 0,
    TokenKind.ASSIGN_POWER: 0,
    TokenKind.ASSIGN_REMAINDER: 0,
    TokenKind.ASSIGN_SHIFT_LEFT: 0,
    TokenKind.ASSIGN_SHIFT_RIGHT: 0,
    TokenKind.ASSIGN_UNSIGNED_SHIFT_RIGHT: 0,
    TokenKind.BITWISE_AND: 0,
    TokenKind.BITWISE_OR: 0,
    TokenKind.BITWISE_XOR: 0,
    TokenKind.COMPARE: 0,
    TokenKind.DECREMENT: 0,
    TokenKind.DIVIDE: 0,
    TokenKind.IN: 0,
    TokenKind.INCREMENT: 0,
    TokenKind.INDEX: 0,
    TokenKind.LIST: 0,
    TokenKind.MINUS: 0,
    TokenKind.MULTIPLY: 0,
    TokenKind.NOT: 0,
    TokenKind.PLUS: 0,
    TokenKind.POWER: 0,
    TokenKind.REMAINDER: 0,
    TokenKind.SET: 0,
    TokenKind.SHIFT_LEFT: 0,
    TokenKind.SHIFT_RIGHT: 0,
    TokenKind.TILDE: 0,
    TokenKind.UNSIGNED_SHIFT_RIGHT: 0,
  }

  def parseAfterBlock(context ParserContext) bool {
    return context.peek(.END_OF_FILE) || context.peek(.RIGHT_BRACE) || context.expect(.NEWLINE)
  }

  def recursiveParseGuard(context ParserContext, parent ObjectSymbol, annotations List<Node>) Guard {
    var test Node = null
    if context.eat(.IF) {
      test = expressionParser.parse(context, .LOWEST)
      if test == null {
        return null
      }
    }
    if !context.expect(.LEFT_BRACE) {
      return null
    }
    var contents = ObjectSymbol.new(parent.kind, "<conditional>")
    contents.parent = parent
    parseSymbols(context, contents, annotations)
    if !context.expect(.RIGHT_BRACE) || !context.peek(.ELSE) && !parseAfterBlock(context) {
      return null
    }
    var elseGuard Guard = null
    if context.eat(.ELSE) {
      elseGuard = recursiveParseGuard(context, parent, annotations)
      if elseGuard == null {
        return null
      }
    }
    return Guard.new(parent, test, contents, elseGuard)
  }

  def parseSymbol(context ParserContext, parent ObjectSymbol, annotations List<Node>) bool {
    # Parse comments before the symbol declaration
    var comments = parseLeadingComments(context)

    # Ignore trailing comments
    if context.peek(.RIGHT_BRACE) || context.peek(.END_OF_FILE) {
      return false
    }

    # Parse a compile-time if statement
    if context.peek(.IF) {
      var guard = recursiveParseGuard(context, parent, annotations)
      if guard == null {
        return false
      }
      parent.guards ?= []
      parent.guards.append(guard)
      return true
    }

    # Parse annotations before the symbol declaration
    if context.peek(.ANNOTATION) {
      annotations = parseAnnotations(context, annotations != null ? annotations.clone : [])
      if annotations == null {
        return false
      }

      # Parse an annotation block
      if context.eat(.LEFT_BRACE) {
        parseSymbols(context, parent, annotations)
        return context.expect(.RIGHT_BRACE) && parseAfterBlock(context)
      }
    }

    var token = context.current
    var symbol Symbol = null

    # Special-case enum symbols
    if parent.kind == .OBJECT_ENUM && token.kind == .IDENTIFIER {
      var variable = VariableSymbol.new(.VARIABLE_ENUM, token.range.toString)
      variable.range = token.range
      variable.parent = parent
      variable.flags |= Symbol.IS_CONST
      parent.variables.append(variable)
      symbol = variable
      context.next
    }

    else {
      # Parse the symbol kind
      var kind SymbolKind
      switch token.kind {
        case .CLASS { kind = .OBJECT_CLASS }
        case .CONST, .VAR { kind = parent.kind.hasInstances ? .VARIABLE_INSTANCE : .VARIABLE_GLOBAL }
        case .DEF, .OVER { kind = parent.kind.hasInstances ? .FUNCTION_INSTANCE : .FUNCTION_GLOBAL }
        case .ENUM { kind = .OBJECT_ENUM }
        case .INTERFACE { kind = .OBJECT_INTERFACE }
        case .NAMESPACE { kind = .OBJECT_NAMESPACE }
        case .IDENTIFIER {
          if token.range.toString == "type" {
            kind = .OBJECT_WRAPPED
          } else {
            context.unexpectedToken
            return false
          }
        }
        default {
          context.unexpectedToken
          return false
        }
      }
      context.next

      # Parse the symbol name
      var nameToken = context.current
      var range = nameToken.range
      var name = range.toString
      var isOperator = kind == .FUNCTION_INSTANCE && nameToken.kind in operatorOverloadTokenKinds
      if isOperator {
        context.next
      } else if kind == .FUNCTION_GLOBAL && context.eat(.ANNOTATION) {
        kind = .FUNCTION_ANNOTATION
      } else if context.eat(.LIST_NEW) || context.eat(.SET_NEW) {
        if kind == .FUNCTION_INSTANCE {
          kind = .FUNCTION_CONSTRUCTOR
        }
      } else {
        if !context.expect(.IDENTIFIER) {
          return false
        }
        if kind == .FUNCTION_INSTANCE && name == "new" {
          kind = .FUNCTION_CONSTRUCTOR
        }
      }

      # Parse shorthand nested namespace declarations
      if kind.isObject {
        while context.eat(.DOT) {
          var nextToken = context.current
          if !context.expect(.IDENTIFIER) {
            return false
          }

          # Wrap this declaration in a namespace
          var nextParent = ObjectSymbol.new(.OBJECT_NAMESPACE, name)
          nextParent.range = range
          nextParent.parent = parent
          parent.objects.append(nextParent)
          parent = nextParent

          # Update the declaration token
          nameToken = nextToken
          range = nextToken.range
          name = range.toString
        }
      }

      # Parse the symbol body
      switch kind {
        case .VARIABLE_GLOBAL, .VARIABLE_INSTANCE {
          var variable = VariableSymbol.new(kind, name)
          variable.range = range
          variable.parent = parent

          if token.kind == .CONST {
            variable.flags |= Symbol.IS_CONST
          }

          if peekType(context) {
            variable.type = parseType(context)
            if variable.type == null {
              return false
            }
          }

          if context.eat(.ASSIGN) {
            variable.value = expressionParser.parse(context, .LOWEST)
            if variable.value == null {
              return false
            }
            checkExtraParentheses(context, variable.value)
          }

          parent.variables.append(variable)
          symbol = variable
        }

        case .FUNCTION_ANNOTATION, .FUNCTION_CONSTRUCTOR, .FUNCTION_GLOBAL, .FUNCTION_INSTANCE {
          var function = FunctionSymbol.new(kind, name)
          function.range = range
          function.parent = parent

          if token.kind == .OVER {
            function.flags |= Symbol.IS_OVER
          }

          # Check for setters like "def foo=(x int) {}" but don't allow a space
          # between the name and the assignment operator
          if kind != .FUNCTION_ANNOTATION && nameToken.kind == .IDENTIFIER && context.peek(.ASSIGN) && context.current.range.start == nameToken.range.end {
            function.range = Range.span(function.range, context.next.range)
            function.flags |= Symbol.IS_SETTER
            function.name += "="
          }

          # Parse type parameters
          if context.eat(.START_PARAMETER_LIST) {
            function.parameters = parseTypeParameters(context, .PARAMETER_FUNCTION)
            if function.parameters == null {
              return false
            }
          }

          # Parse function arguments
          var before = context.current
          if context.eat(.LEFT_PARENTHESIS) {
            if !parseFunctionArguments(context, function) {
              return false
            }

            # Functions without arguments are "getters" and don't use parentheses
            if function.arguments.isEmpty {
              context.log.syntaxErrorEmptyFunctionParentheses(context.spanSince(before.range))
            }
          }

          if kind != .FUNCTION_ANNOTATION && !parseFunctionReturnTypeAndBlock(context, function) {
            return false
          }

          # Don't mark operators as getters to avoid confusion with unary operators and compiler-generated call expressions
          if !isOperator && function.arguments.isEmpty {
            function.flags |= Symbol.IS_GETTER
          }

          parent.functions.append(function)
          symbol = function
        }

        case .OBJECT_CLASS, .OBJECT_ENUM, .OBJECT_INTERFACE, .OBJECT_NAMESPACE, .OBJECT_WRAPPED {
          var object = ObjectSymbol.new(kind, name)
          object.range = range
          object.parent = parent

          if kind != .OBJECT_NAMESPACE && context.eat(.START_PARAMETER_LIST) {
            object.parameters = parseTypeParameters(context, .PARAMETER_OBJECT)
            if object.parameters == null {
              return false
            }
          }

          # Allow "type Foo = int"
          if kind == .OBJECT_WRAPPED && context.eat(.ASSIGN) {
            object.extends = parseType(context)
            if object.extends == null {
              return false
            }
          }

          # Regular block structure "type Foo : int {}"
          else {
            # Base class
            if context.eat(.COLON) {
              object.extends = parseType(context)
              if object.extends == null {
                return false
              }
            }

            # Interfaces
            if context.eat(.DOUBLE_COLON) {
              object.implements = []
              while true {
                var type = parseType(context)
                if type == null {
                  return false
                }
                object.implements.append(type)
                if !context.eat(.COMMA) {
                  break
                }
              }
            }

            if !context.expect(.LEFT_BRACE) {
              return false
            }

            parseSymbols(context, object, null)

            if !context.expect(.RIGHT_BRACE) {
              return false
            }
          }

          parent.objects.append(object)
          symbol = object
        }

        default {
          assert(false)
        }
      }

      # Forbid certain kinds of symbols inside enums and wrapped types
      if (parent.kind == .OBJECT_ENUM || parent.kind == .OBJECT_WRAPPED || parent.kind == .OBJECT_INTERFACE) && (
          kind == .FUNCTION_CONSTRUCTOR || kind == .VARIABLE_INSTANCE) {
        context.log.syntaxErrorBadDeclarationInsideType(context.spanSince(token.range))
      }
    }

    symbol.annotations = annotations?.clone
    symbol.comments = comments

    comments = parseTrailingComment(context, comments)
    if comments != null {
      symbol.comments = comments
      context.eat(.NEWLINE)
    } else if !parseAfterBlock(context) {
      return false
    }

    return true
  }

  def parseSymbols(context ParserContext, parent ObjectSymbol, annotations List<Node>) {
    context.eat(.NEWLINE)

    while !context.peek(.END_OF_FILE) && !context.peek(.RIGHT_BRACE) {
      if !parseSymbol(context, parent, annotations) {
        break
      }
    }
  }

  def parseCommaSeparatedList(context ParserContext, parent Node, stop TokenKind) bool {
    var isFirst = true
    context.skipWhitespace
    while !context.eat(stop) {
      if !isFirst && !context.expect(.COMMA) {
        return false
      }
      var value = expressionParser.parse(context, .LOWEST)
      if value == null {
        return false
      }
      parent.appendChild(value)
      isFirst = false
    }
    return true
  }

  def parseHexCharacter(c int) int {
    if c >= '0' && c <= '9' { return c - '0' }
    if c >= 'A' && c <= 'F' { return c - 'A' + 10 }
    if c >= 'a' && c <= 'f' { return c - 'a' + 10 }
    return -1
  }

  def parseStringLiteral(log Log, range Range) string {
    var text = range.toString
    assert(text.count >= 2)
    assert(text[0] == '"' || text[0] == '\'')
    assert(text[text.count - 1] == text[0])
    var builder = StringBuilder.new
    var start = 1 # Append long runs of unescaped characters using a single slice for speed
    var i = 1
    while i + 1 < text.count {
      var c = text[i++]
      if c == '\\' {
        var escape = i - 1
        builder.append(text.slice(start, escape))
        if i + 1 < text.count {
          c = text[i++]
          if c == 'n' {
            builder.append("\n")
            start = i
          }
          else if c == 'r' {
            builder.append("\r")
            start = i
          }
          else if c == 't' {
            builder.append("\t")
            start = i
          }
          else if c == 'e' {
            builder.append("\e")
            start = i
          }
          else if c == '0' {
            builder.append("\0")
            start = i
          }
          else if c == '\\' || c == '"' || c == '\'' {
            builder.append(string.fromCodeUnit(c))
            start = i
          }
          else if c == 'x' {
            if i + 1 < text.count {
              var c0 = parseHexCharacter(text[i++])
              if i + 1 < text.count {
                var c1 = parseHexCharacter(text[i++])
                if c0 != -1 && c1 != -1 {
                  builder.append(string.fromCodeUnit(c0 << 4 | c1))
                  start = i
                }
              }
            }
          }
        }
        if start < i {
          log.syntaxErrorInvalidEscapeSequence(Range.new(range.source, range.start + escape, range.start + i))
        }
      }
    }
    builder.append(text.slice(start, i))
    return builder.toString
  }

  const intLiteral = (context ParserContext, token Token) Node => Node.createInt(parseIntLiteral(context.log, token.range).value).withRange(token.range)
  const stringLiteral = (context ParserContext, token Token) Node => Node.createString(parseStringLiteral(context.log, token.range)).withRange(token.range)

  def boolLiteral(value bool) fn(ParserContext, Token) Node {
    return (context, token) => Node.createBool(value).withRange(token.range)
  }

  def tokenLiteral(kind NodeKind) fn(ParserContext, Token) Node {
    return (context, token) => Node.new(kind).withRange(token.range)
  }

  def unaryPrefix(kind NodeKind) fn(ParserContext, Token, Node) Node {
    return (context, token, value) => Node.createUnary(kind, value).withRange(Range.span(token.range, value.range)).withInternalRange(token.range)
  }

  def unaryPostfix(kind NodeKind) fn(ParserContext, Node, Token) Node {
    return (context, value, token) => Node.createUnary(kind, value).withRange(Range.span(value.range, token.range)).withInternalRange(token.range)
  }

  def binaryInfix(kind NodeKind) fn(ParserContext, Node, Token, Node) Node {
    return (context, left, token, right) => {
      if kind == .ASSIGN && left.kind == .INDEX {
        left.appendChild(right)
        left.kind = .ASSIGN_INDEX
        return left.withRange(Range.span(left.range, right.range)).withInternalRange(Range.span(left.internalRange, right.range))
      }
      return Node.createBinary(kind, left, right).withRange(Range.span(left.range, right.range)).withInternalRange(token.range)
    }
  }

  var dotInfixParselet = (context ParserContext, left Node) Node => {
    context.next
    var range = context.current.range
    if !context.expect(.IDENTIFIER) {
      return null
    }
    return Node.createDot(left, range.toString).withRange(context.spanSince(left.range)).withInternalRange(range)
  }

  var initializerParselet = (context ParserContext) Node => {
    var token = context.next
    var kind NodeKind = token.kind == .LEFT_BRACE ? .INITIALIZER_MAP : .INITIALIZER_LIST
    var node = Node.createInitializer(kind)

    if token.kind == .LEFT_BRACE || token.kind == .LEFT_BRACKET {
      var expectColon = kind != .INITIALIZER_LIST
      var end TokenKind = expectColon ? .RIGHT_BRACE : .RIGHT_BRACKET
      while true {
        context.eat(.NEWLINE)
        var comments = parseLeadingComments(context)
        if context.peek(end) {
          break
        }
        var first = expressionParser.parse(context, .LOWEST)
        if first == null {
          return null
        }
        var colon = context.current
        if !expectColon {
          node.appendChild(first)
        } else {
          if !context.expect(.COLON) {
            return null
          }
          var second = expressionParser.parse(context, .LOWEST)
          if second == null {
            return null
          }
          first = Node.createPair(first, second).withRange(Range.span(first.range, second.range)).withInternalRange(colon.range)
          node.appendChild(first)
        }
        first.comments = comments
        if !context.eat(.COMMA) {
          break
        }
      }
      context.skipWhitespace
      if !context.expect(end) {
        return null
      }
    } else if token.kind == .LIST_NEW || token.kind == .SET_NEW {
      node.appendChild(Node.createName("new").withRange(Range.new(token.range.source, token.range.start + 1, token.range.end - 1)))
    }
    return node.withRange(context.spanSince(token.range))
  }

  var parameterizedParselet = (context ParserContext, left Node) Node => {
    var value = Node.createParameterize(left)
    var token = context.next
    while true {
      var type = parseType(context)
      if type == null {
        return null
      }
      value.appendChild(type)
      if !context.eat(.COMMA) {
        break
      }
    }
    if !context.expect(.END_PARAMETER_LIST) {
      return null
    }
    return value.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
  }

  def createExpressionParser Pratt {
    var pratt = Pratt.new

    ########################################
    # Literals
    ########################################

    pratt.literal(.DOUBLE, (context, token) => Node.createDouble(parseDoubleLiteral(token.range.toString)).withRange(token.range))
    pratt.literal(.FALSE, boolLiteral(false))
    pratt.literal(.INT, intLiteral)
    pratt.literal(.INT_BINARY, intLiteral)
    pratt.literal(.INT_HEX, intLiteral)
    pratt.literal(.INT_OCTAL, intLiteral)
    pratt.literal(.NULL, tokenLiteral(.NULL))
    pratt.literal(.STRING, stringLiteral)
    pratt.literal(.SUPER, tokenLiteral(.SUPER))
    pratt.literal(.TRUE, boolLiteral(true))

    pratt.literal(.CHARACTER, (context, token) => {
      var result = parseStringLiteral(context.log, token.range)
      var codePoint = 0

      # There must be exactly one unicode code point
      var iterator = Unicode.StringIterator.INSTANCE.reset(result, 0)
      codePoint = iterator.nextCodePoint
      if codePoint == -1 || iterator.nextCodePoint != -1 {
        context.log.syntaxErrorInvalidCharacter(token.range)
      }

      # Don't return null when there's an error because that
      # error won't affect the rest of the compilation
      return Node.createInt(codePoint).withRange(token.range)
    })

    ########################################
    # Unary expressions
    ########################################

    pratt.prefix(.MINUS, .UNARY_PREFIX, unaryPrefix(.NEGATIVE))
    pratt.prefix(.NOT, .UNARY_PREFIX, unaryPrefix(.NOT))
    pratt.prefix(.PLUS, .UNARY_PREFIX, unaryPrefix(.POSITIVE))
    pratt.prefix(.TILDE, .UNARY_PREFIX, unaryPrefix(.COMPLEMENT))
    pratt.prefix(.INCREMENT, .UNARY_PREFIX, unaryPrefix(.PREFIX_INCREMENT))
    pratt.prefix(.DECREMENT, .UNARY_PREFIX, unaryPrefix(.PREFIX_DECREMENT))
    pratt.postfix(.INCREMENT, .UNARY_PREFIX, unaryPostfix(.POSTFIX_INCREMENT))
    pratt.postfix(.DECREMENT, .UNARY_PREFIX, unaryPostfix(.POSTFIX_DECREMENT))

    ########################################
    # Binary expressions
    ########################################

    pratt.infix(.BITWISE_AND, .BITWISE_AND, binaryInfix(.BITWISE_AND))
    pratt.infix(.BITWISE_OR, .BITWISE_OR, binaryInfix(.BITWISE_OR))
    pratt.infix(.BITWISE_XOR, .BITWISE_XOR, binaryInfix(.BITWISE_XOR))
    pratt.infix(.COMPARE, .COMPARE, binaryInfix(.COMPARE))
    pratt.infix(.DIVIDE, .MULTIPLY, binaryInfix(.DIVIDE))
    pratt.infix(.EQUAL, .EQUAL, binaryInfix(.EQUAL))
    pratt.infix(.GREATER_THAN, .COMPARE, binaryInfix(.GREATER_THAN))
    pratt.infix(.GREATER_THAN_OR_EQUAL, .COMPARE, binaryInfix(.GREATER_THAN_OR_EQUAL))
    pratt.infix(.IN, .COMPARE, binaryInfix(.IN))
    pratt.infix(.LESS_THAN, .COMPARE, binaryInfix(.LESS_THAN))
    pratt.infix(.LESS_THAN_OR_EQUAL, .COMPARE, binaryInfix(.LESS_THAN_OR_EQUAL))
    pratt.infix(.LOGICAL_AND, .LOGICAL_AND, binaryInfix(.LOGICAL_AND))
    pratt.infix(.LOGICAL_OR, .LOGICAL_OR, binaryInfix(.LOGICAL_OR))
    pratt.infix(.MINUS, .ADD, binaryInfix(.SUBTRACT))
    pratt.infix(.MULTIPLY, .MULTIPLY, binaryInfix(.MULTIPLY))
    pratt.infix(.NOT_EQUAL, .EQUAL, binaryInfix(.NOT_EQUAL))
    pratt.infix(.PLUS, .ADD, binaryInfix(.ADD))
    pratt.infix(.POWER, .UNARY_PREFIX, binaryInfix(.POWER))
    pratt.infix(.REMAINDER, .MULTIPLY, binaryInfix(.REMAINDER))
    pratt.infix(.SHIFT_LEFT, .SHIFT, binaryInfix(.SHIFT_LEFT))
    pratt.infix(.SHIFT_RIGHT, .SHIFT, binaryInfix(.SHIFT_RIGHT))
    pratt.infix(.UNSIGNED_SHIFT_RIGHT, .SHIFT, binaryInfix(.UNSIGNED_SHIFT_RIGHT))

    pratt.infixRight(.ASSIGN, .ASSIGN, binaryInfix(.ASSIGN))
    pratt.infixRight(.ASSIGN_BITWISE_AND, .ASSIGN, binaryInfix(.ASSIGN_BITWISE_AND))
    pratt.infixRight(.ASSIGN_BITWISE_OR, .ASSIGN, binaryInfix(.ASSIGN_BITWISE_OR))
    pratt.infixRight(.ASSIGN_BITWISE_XOR, .ASSIGN, binaryInfix(.ASSIGN_BITWISE_XOR))
    pratt.infixRight(.ASSIGN_DIVIDE, .ASSIGN, binaryInfix(.ASSIGN_DIVIDE))
    pratt.infixRight(.ASSIGN_MINUS, .ASSIGN, binaryInfix(.ASSIGN_SUBTRACT))
    pratt.infixRight(.ASSIGN_MULTIPLY, .ASSIGN, binaryInfix(.ASSIGN_MULTIPLY))
    pratt.infixRight(.ASSIGN_NULL, .ASSIGN, binaryInfix(.ASSIGN_NULL))
    pratt.infixRight(.ASSIGN_PLUS, .ASSIGN, binaryInfix(.ASSIGN_ADD))
    pratt.infixRight(.ASSIGN_POWER, .ASSIGN, binaryInfix(.ASSIGN_POWER))
    pratt.infixRight(.ASSIGN_REMAINDER, .ASSIGN, binaryInfix(.ASSIGN_REMAINDER))
    pratt.infixRight(.ASSIGN_SHIFT_LEFT, .ASSIGN, binaryInfix(.ASSIGN_SHIFT_LEFT))
    pratt.infixRight(.ASSIGN_SHIFT_RIGHT, .ASSIGN, binaryInfix(.ASSIGN_SHIFT_RIGHT))
    pratt.infixRight(.ASSIGN_UNSIGNED_SHIFT_RIGHT, .ASSIGN, binaryInfix(.ASSIGN_UNSIGNED_SHIFT_RIGHT))
    pratt.infixRight(.NULL_JOIN, .NULL_JOIN, binaryInfix(.NULL_JOIN))

    ########################################
    # Other expressions
    ########################################

    pratt.parselet(.DOT, .MEMBER).infix = dotInfixParselet
    pratt.parselet(.INDEX, .LOWEST).prefix = initializerParselet
    pratt.parselet(.LEFT_BRACE, .LOWEST).prefix = initializerParselet
    pratt.parselet(.LEFT_BRACKET, .LOWEST).prefix = initializerParselet
    pratt.parselet(.LIST_NEW, .LOWEST).prefix = initializerParselet
    pratt.parselet(.SET_NEW, .LOWEST).prefix = initializerParselet
    pratt.parselet(.START_PARAMETER_LIST, .MEMBER).infix = parameterizedParselet

    # "x?.y"
    pratt.parselet(.NULL_DOT, .MEMBER).infix = (context ParserContext, left Node) Node => {
      context.next
      var range = context.current.range
      if !context.expect(.IDENTIFIER) {
        return null
      }
      return Node.createNullDot(left, range.toString).withRange(context.spanSince(left.range)).withInternalRange(range)
    }

    # Lambda expressions like "=> x"
    pratt.parselet(.ARROW, .LOWEST).prefix = (context) => {
      var token = context.current
      var symbol = FunctionSymbol.new(.FUNCTION_LOCAL, "<lambda>")
      if !parseFunctionBlock(context, symbol) {
        return null
      }
      symbol.range = context.spanSince(token.range)
      return Node.createLambda(symbol).withRange(symbol.range)
    }

    # Cast expressions
    pratt.parselet(.AS, .UNARY_PREFIX).infix = (context, left) => {
      var token = context.next
      var type = parseType(context)
      if type == null {
        return null
      }
      return Node.createCast(left, type).withRange(context.spanSince(left.range)).withInternalRange(token.range)
    }

    # Using "." as a unary prefix operator accesses members off the inferred type
    pratt.parselet(.DOT, .MEMBER).prefix = (context) => {
      var token = context.next
      var range = context.current.range
      if !context.expect(.IDENTIFIER) {
        return null
      }
      return Node.createDot(null, range.toString).withRange(context.spanSince(token.range)).withInternalRange(range)
    }

    # Access members off of "dynamic" for untyped globals
    pratt.parselet(.DYNAMIC, .LOWEST).prefix = (context) => {
      var token = context.next
      if !context.expect(.DOT) {
        return null
      }
      var range = context.current.range
      if !context.expect(.IDENTIFIER) {
        return null
      }
      return Node.createDot(Node.createType(.DYNAMIC), range.toString).withRange(context.spanSince(token.range)).withInternalRange(range)
    }

    # Name expressions and lambda expressions like "x => x * x"
    pratt.parselet(.IDENTIFIER, .LOWEST).prefix = (context) => {
      var range = context.next.range
      var name = range.toString
      if context.peek(.ARROW) {
        var symbol = FunctionSymbol.new(.FUNCTION_LOCAL, "<lambda>")
        var argument = VariableSymbol.new(.VARIABLE_ARGUMENT, name)
        argument.range = range
        symbol.arguments.append(argument)
        if !parseFunctionBlock(context, symbol) {
          return null
        }
        symbol.range = context.spanSince(range)
        return Node.createLambda(symbol).withRange(symbol.range)
      }

      return Node.createName(name).withRange(range)
    }

    # Type check expressions
    pratt.parselet(.IS, .COMPARE).infix = (context, left) => {
      var token = context.next
      var type = parseType(context)
      if type == null {
        return null
      }
      return Node.createTypeCheck(left, type).withRange(context.spanSince(left.range)).withInternalRange(token.range)
    }

    # Index expressions
    pratt.parselet(.LEFT_BRACKET, .MEMBER).infix = (context, left) => {
      var token = context.next
      var right = expressionParser.parse(context, .LOWEST)
      if right == null || !context.expect(.RIGHT_BRACKET) {
        return null
      }
      return Node.createIndex(left, right).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
    }

    # Parenthetic groups and lambda expressions like "() => x"
    pratt.parselet(.LEFT_PARENTHESIS, .LOWEST).prefix = (context) => {
      var token = context.next

      # Try to parse a group
      if !context.peek(.RIGHT_PARENTHESIS) {
        var value = pratt.parse(context, .LOWEST)
        if value == null {
          return null
        }
        if (value.kind != .NAME || !peekType(context)) && context.eat(.RIGHT_PARENTHESIS) {
          if value.kind != .NAME || !context.peek(.ARROW) {
            return value.withRange(context.spanSince(token.range)).withFlags(Node.IS_INSIDE_PARENTHESES)
          }
          context.undo
        }
        context.undo
      }

      # Parse a lambda instead
      var symbol = FunctionSymbol.new(.FUNCTION_LOCAL, "<lambda>")
      if !parseFunctionArguments(context, symbol) || !parseFunctionReturnTypeAndBlock(context, symbol) {
        return null
      }
      symbol.range = context.spanSince(token.range)
      return Node.createLambda(symbol).withRange(symbol.range)
    }

    # Call expressions
    pratt.parselet(.LEFT_PARENTHESIS, .UNARY_POSTFIX).infix = (context, left) => {
      var node = Node.createCall(left)
      var token = context.next
      if !parseCommaSeparatedList(context, node, .RIGHT_PARENTHESIS) {
        return null
      }
      return node.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
    }

    # Hook expressions
    pratt.parselet(.QUESTION_MARK, .ASSIGN).infix = (context, left) => {
      context.next
      var middle = pratt.parse(context, (Precedence.ASSIGN - 1) as Precedence)
      if middle == null || !context.expect(.COLON) {
        return null
      }
      var right = pratt.parse(context, (Precedence.ASSIGN - 1) as Precedence)
      if right == null {
        return null
      }
      return Node.createHook(left, middle, right).withRange(context.spanSince(left.range))
    }

    return pratt
  }

  def createTypeParser Pratt {
    var pratt = Pratt.new

    pratt.literal(.DYNAMIC, (context, token) => Node.createType(.DYNAMIC).withRange(token.range))
    pratt.parselet(.DOT, .MEMBER).infix = dotInfixParselet
    pratt.parselet(.START_PARAMETER_LIST, .MEMBER).infix = parameterizedParselet

    # Name expressions or lambda type expressions like "fn(int) int"
    pratt.parselet(.IDENTIFIER, .LOWEST).prefix = (context) => {
      var node = Node.createLambdaType
      var returnType = node.lambdaReturnType
      var token = context.next
      var name = token.range.toString
      var isFirst = true

      if name != "fn" || !context.eat(.LEFT_PARENTHESIS) {
        return Node.createName(name).withRange(token.range)
      }

      # Parse argument types
      while !context.eat(.RIGHT_PARENTHESIS) {
        if !isFirst && !context.expect(.COMMA) {
          return null
        }
        var type = parseType(context)
        if type == null {
          return null
        }
        node.insertChildBefore(returnType, type)
        isFirst = false
      }

      # Parse return type if present
      if peekType(context) {
        var type = parseType(context)
        if type == null {
          return null
        }
        returnType.replaceWith(type)
      }

      return node.withRange(context.spanSince(token.range))
    }

    return pratt
  }

  def parseFile(log Log, tokens List<Token>, global ObjectSymbol) {
    expressionParser ?= createExpressionParser
    typeParser ?= createTypeParser

    var context = ParserContext.new(log, tokens)
    parseSymbols(context, global, null)
    context.expect(.END_OF_FILE)
  }
}
