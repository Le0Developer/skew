namespace skew {
  #if TARGET_JS
    double parseDoubleLiteral(string text) {
      return `+`text``
    }
  #else
    import double parseDoubleLiteral(string text)
  #endif

  // The same operator precedence as C for the most part
  enum Precedence {
    LOWEST
    ASSIGN
    LOGICAL_OR
    LOGICAL_AND
    BITWISE_OR
    BITWISE_XOR
    BITWISE_AND
    EQUAL
    COMPARE
    SHIFT
    ADD
    MULTIPLY
    UNARY_PREFIX
    UNARY_POSTFIX
    MEMBER
  }

  List<string> parseLeadingComments(ParserContext context) {
    List<string> comments = null
    while (context.peek(.COMMENT)) {
      var range = context.next().range
      if (comments == null) {
        comments = []
      }
      comments.push(range.source.contents.slice(range.start + 1, range.end))

      // Ignore blocks of comments with extra lines afterward
      if (context.eat(.NEWLINE)) {
        comments = null
      }
    }
    return comments
  }

  List<Node> parseAnnotations(ParserContext context, List<Node> annotations) {
    annotations = annotations != null ? annotations.clone() : []

    while (context.peek(.ANNOTATION)) {
      var range = context.next().range
      var value = Node.createName(range.toString()).withRange(range)

      // Change "@foo.bar.baz" into "foo.bar.@baz"
      if (context.peek(.DOT)) {
        var root = value.asString()
        value.content = StringContent(root.slice(1, root.size()))
        while (context.eat(.DOT)) {
          var name = context.current().range
          if (!context.expect(.IDENTIFIER)) {
            return null
          }
          value = Node.createDot(value, name.toString()).withRange(context.spanSince(range)).withInternalRange(name)
        }
        value.content = StringContent("@" + value.asString())
      }

      // Parse parentheses if present
      var token = context.current()
      if (context.eat(.LEFT_PARENTHESIS)) {
        var arguments = parseCommaSeparatedList(context, .RIGHT_PARENTHESIS)
        if (arguments == null) {
          return null
        }
        value = Node.createCall(value, arguments).withRange(context.spanSince(range)).withInternalRange(context.spanSince(token.range))
      }

      // Parse a trailing if condition
      Node test = null
      if (context.eat(.IF)) {
        test = pratt.parse(context, .LOWEST)
        if (test == null) {
          return null
        }
      }

      // All annotations must end in a newline to avoid confusion with the trailing if
      if (!context.peek(.LEFT_BRACE) && !context.expect(.NEWLINE)) {
        return null
      }

      annotations.push(Node.createAnnotation(value, test).withRange(context.spanSince(range)))
    }

    return annotations
  }


  Node parseVarOrConst(ParserContext context) {
    var token = context.next()
    var range = context.current().range

    if (!context.expect(.IDENTIFIER)) {
      return null
    }

    var symbol = VariableSymbol(.VARIABLE_LOCAL, range.toString())
    symbol.range = range

    if (token.kind == .CONST) {
      symbol.flags |= .CONST
    }

    if (peekType(context)) {
      symbol.type = parseType(context)
      if (symbol.type == null) {
        return null
      }
    }

    if (context.eat(.ASSIGN)) {
      symbol.value = pratt.parse(context, .LOWEST)
      if (symbol.value == null) {
        return null
      }
    }

    return Node.createVar(symbol).withRange(context.spanSince(token.range))
  }

  Node parseJump(ParserContext context) {
    var token = context.next()
    return (token.kind == .BREAK ? Node.createBreak() : Node.createContinue()).withRange(token.range)
  }

  Node parseReturn(ParserContext context) {
    var token = context.next()
    Node value = null
    if (!context.peek(.NEWLINE) && !context.peek(.RIGHT_BRACE)) {
      value = pratt.parse(context, .LOWEST)
      if (value == null) {
        return null
      }
    }
    return Node.createReturn(value).withRange(context.spanSince(token.range))
  }

  Node parseIf(ParserContext context) {
    var token = context.next()
    var test = pratt.parse(context, .LOWEST)
    if (test == null) {
      return null
    }
    var trueBlock = parseBlock(context)
    if (trueBlock == null) {
      return null
    }
    Node falseBlock = null
    if (context.eat(.ELSE)) {
      if (context.peek(.IF)) {
        var statement = parseIf(context)
        if (statement == null) {
          return null
        }
        falseBlock = Node.createBlock([statement]).withRange(statement.range)
      } else {
        falseBlock = parseBlock(context)
        if (falseBlock == null) {
          return null
        }
      }
    }
    return Node.createIf(test, trueBlock, falseBlock).withRange(context.spanSince(token.range))
  }

  Node parseWhile(ParserContext context) {
    var token = context.next()
    var test = pratt.parse(context, .LOWEST)
    if (test == null) {
      return null
    }
    var block = parseBlock(context)
    if (block == null) {
      return null
    }
    return Node.createWhile(test, block).withRange(context.spanSince(token.range))
  }

  Node parseStatement(ParserContext context) {
    var token = context.current()

    switch (token.kind) {
      case .BREAK, .CONTINUE { return parseJump(context) }
      case .CONST, .VAR { return parseVarOrConst(context) }
      case .IF { return parseIf(context) }
      case .RETURN { return parseReturn(context) }
      case .WHILE { return parseWhile(context) }
    }

    var value = pratt.parse(context, .LOWEST)
    if (value == null) {
      return null
    }
    return Node.createExpression(value).withRange(value.range)
  }

  List<Node> parseStatements(ParserContext context) {
    List<Node> statements = []
    context.eat(.NEWLINE)
    while (!context.peek(.RIGHT_BRACE)) {
      List<string> comments = parseLeadingComments(context)

      // Ignore trailing comments
      if (context.peek(.RIGHT_BRACE) || context.peek(.END_OF_FILE)) {
        break
      }

      var statement = parseStatement(context)
      if (statement == null) {
        break
      }

      statement.comments = comments
      statements.push(statement)

      if (context.peek(.RIGHT_BRACE) || !context.expect(.NEWLINE)) {
        break
      }
    }
    return statements
  }

  Node parseBlock(ParserContext context) {
    var token = context.current()
    if (!context.expect(.LEFT_BRACE)) {
      return null
    }
    var statements = parseStatements(context)
    if (!context.expect(.RIGHT_BRACE)) {
      return null
    }
    return Node.createBlock(statements).withRange(context.spanSince(token.range))
  }

  Node parseType(ParserContext context) {
    return typePratt.parse(context, .LOWEST)
  }

  bool peekType(ParserContext context) {
    return context.peek(.IDENTIFIER) || context.peek(.DYNAMIC)
  }

  bool parseFunctionBlock(ParserContext context, FunctionSymbol symbol) {
    // "=> x" is the same as "{ return x }"
    if (symbol.kind == .FUNCTION_LOCAL) {
      if (!context.expect(.ARROW)) {
        return false
      }
      if (context.peek(.LEFT_BRACE)) {
        symbol.block = parseBlock(context)
        if (symbol.block == null) {
          return false
        }
      } else {
        var value = pratt.parse(context, .LOWEST)
        if (value == null) {
          return false
        }
        symbol.block = Node.createBlock([Node.createImplicitReturn(value).withRange(value.range)]).withRange(value.range)
      }
    }

    // Parse function body if present
    else if (context.peek(.LEFT_BRACE)) {
      symbol.block = parseBlock(context)
      if (symbol.block == null) {
        return false
      }
    }

    return true
  }

  bool parseFunctionArguments(ParserContext context, FunctionSymbol symbol) {
    var usingTypes = false
    while (!context.eat(.RIGHT_PARENTHESIS)) {
      if (symbol.arguments.size() != 0 && !context.expect(.COMMA)) {
        return false
      }

      var range = context.current().range
      var name = range.toString()

      if (!context.expect(.IDENTIFIER)) {
        return false
      }

      var arg = VariableSymbol(.VARIABLE_LOCAL, name)
      arg.range = range

      // Parse argument type
      if (symbol.kind != .FUNCTION_LOCAL || (symbol.arguments.size() != 0 ? usingTypes : peekType(context))) {
        arg.type = parseType(context)
        if (arg.type == null) {
          return false
        }
        usingTypes = true
      }

      // Parse default value
      if (context.eat(.ASSIGN)) {
        arg.value = pratt.parse(context, .LOWEST)
        if (arg.value == null) {
          return false
        }
      }

      symbol.arguments.push(arg)
    }
    return true
  }

  bool parseFunctionReturnTypeAndBlock(ParserContext context, FunctionSymbol symbol) {
    if (peekType(context)) {
      symbol.returnType = parseType(context)
    }
    return parseFunctionBlock(context, symbol)
  }

  List<ParameterSymbol> parseTypeParameters(ParserContext context) {
    List<ParameterSymbol> parameters = []
    do {
      var range = context.current().range
      var name = range.toString()
      if (!context.expect(.IDENTIFIER)) {
        return null
      }
      var symbol = ParameterSymbol(.PARAMETER, name)
      symbol.range = range
      parameters.push(symbol)
    } while (context.eat(.COMMA))
    if (!context.expect(.END_PARAMETER_LIST)) {
      return null
    }
    return parameters
  }

  var operatorOverloadTokenKinds = {
    TokenKind.ASSIGN_BITWISE_AND: 0,
    TokenKind.ASSIGN_BITWISE_OR: 0,
    TokenKind.ASSIGN_BITWISE_XOR: 0,
    TokenKind.ASSIGN_DIVIDE: 0,
    TokenKind.ASSIGN_INDEX: 0,
    TokenKind.ASSIGN_MINUS: 0,
    TokenKind.ASSIGN_MULTIPLY: 0,
    TokenKind.ASSIGN_PLUS: 0,
    TokenKind.ASSIGN_POWER: 0,
    TokenKind.ASSIGN_REMAINDER: 0,
    TokenKind.ASSIGN_SHIFT_LEFT: 0,
    TokenKind.ASSIGN_SHIFT_RIGHT: 0,
    TokenKind.BITWISE_AND: 0,
    TokenKind.BITWISE_OR: 0,
    TokenKind.BITWISE_XOR: 0,
    TokenKind.COMPARE: 0,
    TokenKind.DIVIDE: 0,
    TokenKind.IN: 0,
    TokenKind.INDEX: 0,
    TokenKind.LIST: 0,
    TokenKind.MINUS: 0,
    TokenKind.MULTIPLY: 0,
    TokenKind.NOT: 0,
    TokenKind.PLUS: 0,
    TokenKind.POWER: 0,
    TokenKind.REMAINDER: 0,
    TokenKind.SET: 0,
    TokenKind.SHIFT_LEFT: 0,
    TokenKind.SHIFT_RIGHT: 0,
    TokenKind.TILDE: 0,
  }

  bool parseSymbol(ParserContext context, ObjectSymbol parent, List<Node> annotations) {
    // Parse comments before the symbol declaration
    List<string> comments = parseLeadingComments(context)

    // Ignore trailing comments
    if (context.peek(.RIGHT_BRACE) || context.peek(.END_OF_FILE)) {
      return false
    }

    // Parse annotations before the symbol declaration
    if (context.peek(.ANNOTATION)) {
      annotations = parseAnnotations(context, annotations)
      if (annotations == null) {
        return false
      }

      // Parse an annotation block
      if (context.eat(.LEFT_BRACE)) {
        parseSymbols(context, parent, annotations)
        return context.expect(.RIGHT_BRACE) && (context.peek(.END_OF_FILE) || context.peek(.RIGHT_BRACE) || context.expect(.NEWLINE))
      }
    }

    // Parse the symbol kind
    var token = context.current()
    SymbolKind kind
    switch (token.kind) {
      case .CLASS { kind = .OBJECT_CLASS }
      case .CONST, .VAR { kind = parent.kind.hasInstances() ? .VARIABLE_INSTANCE : .VARIABLE_GLOBAL }
      case .DEF { kind = parent.kind.hasInstances() ? .FUNCTION_INSTANCE : .FUNCTION_GLOBAL }
      case .INTERFACE { kind = .OBJECT_INTERFACE }
      case .NAMESPACE { kind = .OBJECT_NAMESPACE }
      default {
        context.unexpectedToken()
        return false
      }
    }
    context.next()

    // Parse the symbol name
    var nameToken = context.current()
    var range = nameToken.range
    var name = range.toString()
    var isOperator = kind == .FUNCTION_INSTANCE && nameToken.kind in operatorOverloadTokenKinds
    if (isOperator) {
      context.next()
    } else if (kind == .FUNCTION_GLOBAL && context.eat(.ANNOTATION)) {
      kind = .FUNCTION_ANNOTATION
    } else if (!context.expect(.IDENTIFIER)) {
      return false
    }
    if (kind == .FUNCTION_INSTANCE && name == "new") {
      kind = .FUNCTION_CONSTRUCTOR
    }

    // Parse shorthand nested namespace declarations
    if (kind.isObject()) {
      while (context.eat(.DOT)) {
        var nextToken = context.current()
        if (!context.expect(.IDENTIFIER)) {
          return false
        }

        // Wrap this declaration in a namespace
        var nextParent = ObjectSymbol(.OBJECT_NAMESPACE, name)
        nextParent.range = range
        parent.objects.push(nextParent)
        parent = nextParent

        // Update the declaration token
        nameToken = nextToken
        range = nextToken.range
        name = range.toString()
      }
    }

    // Parse the symbol body
    switch (kind) {
      case .VARIABLE_GLOBAL, .VARIABLE_INSTANCE {
        var symbol = VariableSymbol(kind, name)
        symbol.range = range

        if (token.kind == .CONST) {
          symbol.flags |= .CONST
        }

        if (peekType(context)) {
          symbol.type = parseType(context)
        }

        if (context.eat(.ASSIGN)) {
          symbol.value = pratt.parse(context, .LOWEST)
        }

        symbol.annotations = annotations
        symbol.comments = comments
        parent.variables.push(symbol)
      }

      case .FUNCTION_ANNOTATION, .FUNCTION_CONSTRUCTOR, .FUNCTION_GLOBAL, .FUNCTION_INSTANCE {
        var symbol = FunctionSymbol(kind, name)
        symbol.range = range

        // Check for setters like "def foo=(x int) {}" but don't allow a space
        // between the name and the assignment operator
        if (kind != .FUNCTION_ANNOTATION && nameToken.kind == .IDENTIFIER && context.peek(.ASSIGN) && context.current().range.start == nameToken.range.end) {
          context.next()
          symbol.flags |= .SETTER
          symbol.name += "="
        }

        // Parse type parameters
        if (context.eat(.START_PARAMETER_LIST)) {
          symbol.parameters = parseTypeParameters(context)
          if (symbol.parameters == null) {
            return false
          }
        }

        // Parse function arguments
        var before = context.current()
        if (context.eat(.LEFT_PARENTHESIS)) {
          if (!parseFunctionArguments(context, symbol)) {
            return false
          }

          // Functions without arguments are "getters" and don't use parentheses
          if (symbol.arguments.size() == 0) {
            context.log.syntaxErrorEmptyFunctionParentheses(context.spanSince(before.range))
          }
        }

        if (kind != .FUNCTION_ANNOTATION && !parseFunctionReturnTypeAndBlock(context, symbol)) {
          return false
        }

        // Don't mark operators as getters to avoid confusion with unary operators and compiler-generated call expressions
        if (!isOperator && symbol.arguments.size() == 0) {
          symbol.flags |= .GETTER
        }

        symbol.annotations = annotations
        symbol.comments = comments
        parent.functions.push(symbol)
      }

      case .OBJECT_CLASS, .OBJECT_INTERFACE, .OBJECT_NAMESPACE {
        var symbol = ObjectSymbol(kind, name)
        symbol.range = range

        if (kind != .OBJECT_NAMESPACE && context.eat(.START_PARAMETER_LIST)) {
          symbol.parameters = parseTypeParameters(context)
          if (symbol.parameters == null) {
            return false
          }
        }

        if (context.eat(.IS)) {
          symbol.base = parseType(context)
          if (symbol.base == null) {
            return false
          }
        }

        if (!context.expect(.LEFT_BRACE)) {
          return false
        }

        parseSymbols(context, symbol, null)

        if (!context.expect(.RIGHT_BRACE)) {
          return false
        }

        symbol.annotations = annotations
        symbol.comments = comments
        parent.objects.push(symbol)
      }

      default {
        assert false
      }
    }

    if (!context.peek(.END_OF_FILE) && !context.peek(.RIGHT_BRACE) && !context.expect(.NEWLINE)) {
      return false
    }

    return true
  }

  void parseSymbols(ParserContext context, ObjectSymbol parent, List<Node> annotations) {
    context.eat(.NEWLINE)

    while (!context.peek(.END_OF_FILE) && !context.peek(.RIGHT_BRACE)) {
      if (!parseSymbol(context, parent, annotations)) {
        break
      }
    }
  }

  void parseFile(Log log, List<Token> tokens, ObjectSymbol global) {
    var context = ParserContext(log, tokens)
    parseSymbols(context, global, null)
    context.expect(.END_OF_FILE)
  }

  List<Node> parseCommaSeparatedList(ParserContext context, TokenKind stop) {
    List<Node> values = []
    while (!context.peek(stop)) {
      if (values.size() != 0) {
        if (!context.expect(.COMMA)) {
          return null
        }
        context.eat(.NEWLINE)
      }
      var value = pratt.parse(context, .LOWEST)
      values.push(value)
      if (value == null) {
        break
      }
    }
    if (!context.expect(stop)) {
      return null
    }
    return values
  }

  int parseHexCharacter(int c) {
    if (c >= '0' && c <= '9') return c - '0'
    if (c >= 'A' && c <= 'F') return c - 'A' + 10
    if (c >= 'a' && c <= 'f') return c - 'a' + 10
    return -1
  }

  StringContent parseStringLiteral(Log log, Range range) {
    var text = range.toString()
    assert text.size() >= 2
    assert text[0] == '"' || text[0] == '\''
    assert text[text.size() - 1] == text[0]
    var isValidString = true
    var builder = StringBuilder()
    var start = 1 // Append long runs of unescaped characters using a single slice() for speed
    var i = 1
    while (i + 1 < text.size()) {
      var c = text[i]
      i++
      if (c == '\\') {
        var escape = i - 1
        builder.append(text.slice(start, escape))
        if (i + 1 < text.size()) {
          c = text[i]
          i++
          if (c == 'n') {
            builder.append("\n")
            start = i
          }
          else if (c == 'r') {
            builder.append("\r")
            start = i
          }
          else if (c == 't') {
            builder.append("\t")
            start = i
          }
          else if (c == 'e') {
            builder.append("\e")
            start = i
          }
          else if (c == '0') {
            builder.append("\0")
            start = i
          }
          else if (c == '\\' || c == '"' || c == '\'') {
            builder.append(string.fromCodeUnit(c))
            start = i
          }
          else if (c == 'x') {
            if (i + 1 < text.size()) {
              var c0 = parseHexCharacter(text[i])
              i++
              if (i + 1 < text.size()) {
                var c1 = parseHexCharacter(text[i])
                i++
                if (c0 != -1 && c1 != -1) {
                  builder.append(string.fromCodeUnit(c0 << 4 | c1))
                  start = i
                }
              }
            }
          }
        }
        if (start < i) {
          log.syntaxErrorInvalidEscapeSequence(Range(range.source, range.start + escape, range.start + i))
          isValidString = false
        }
      }
    }
    builder.append(text.slice(start, i))
    return isValidString ? StringContent(builder.toString()) : null
  }

  class TokenLiteral : LiteralCallback {
    NodeKind kind

    override Node parse(ParserContext context, Token token) {
      return Node(kind).withRange(token.range)
    }
  }

  class CallParselet : InfixParselet {
    override Node parse(ParserContext context, Node left) {
      var token = context.next()
      var arguments = parseCommaSeparatedList(context, .RIGHT_PARENTHESIS)
      if (arguments == null) {
        return null
      }
      return Node.createCall(left, arguments).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
    }
  }

  class BoolLiteral : LiteralCallback {
    bool value

    override Node parse(ParserContext context, Token token) {
      return Node.createBool(value).withRange(token.range)
    }
  }

  class IntLiteral : LiteralCallback {
    int base

    override Node parse(ParserContext context, Token token) {
      var text = token.range.toString()
      var value = 0
      switch (base) {
        case 2, 8, 10 {
          for (var i = base == 10 ? 0 : 2; i < text.size(); i++) {
            value = value * base + text[i] - '0'
          }
        }
        case 16 {
          for (var i = 2; i < text.size(); i++) {
            var c = text[i]
            value = value * 16 + c - (c <= '9' ? '0' : c <= 'F' ? 'A' - 10 : 'a' - 10)
          }
        }
      }
      return Node.createInt(value).withRange(token.range)
    }
  }

  class DoubleLiteral : LiteralCallback {
    override Node parse(ParserContext context, Token token) {
      return Node.createDouble(parseDoubleLiteral(token.range.toString())).withRange(token.range)
    }
  }

  class CharacterLiteral : LiteralCallback {
    override Node parse(ParserContext context, Token token) {
      var result = parseStringLiteral(context.log, token.range)
      var codePoint = 0

      // There must be exactly one unicode code point
      if (result != null) {
        var iterator = unicode.StringIterator.INSTANCE.reset(result.value, 0)
        codePoint = iterator.nextCodePoint()
        if (codePoint == -1 || iterator.nextCodePoint() != -1) {
          context.log.syntaxErrorInvalidCharacter(token.range)
        }
      }

      // Don't return null when there's an error because that
      // error won't affect the rest of the compilation
      return Node.createInt(codePoint).withRange(token.range)
    }
  }

  class StringLiteral : LiteralCallback {
    override Node parse(ParserContext context, Token token) {
      var result = parseStringLiteral(context.log, token.range)
      if (result == null) {
        return null
      }
      return Node.createString(result.value).withRange(token.range)
    }
  }

  class DotParselet : InfixParselet {
    override Node parse(ParserContext context, Node left) {
      context.next()
      var range = context.current().range
      if (!context.expect(.IDENTIFIER)) {
        return null
      }
      return Node.createDot(left, range.toString()).withRange(context.spanSince(left.range)).withInternalRange(range)
    }
  }

  class UnaryPrefix : PrefixCallback {
    NodeKind kind

    override Node parse(ParserContext context, Token token, Node value) {
      if (kind == .NOT && value.kind == .IN) {
        context.log.syntaxWarningPreferNotIn(value.internalRange)
      }
      return Node.createUnary(kind, value).withRange(Range.span(token.range, value.range)).withInternalRange(token.range)
    }
  }

  class BinaryInfix : InfixCallback {
    NodeKind kind

    override Node parse(ParserContext context, Node left, Token token, Node right) {
      if (kind == .ASSIGN && left.kind == .INDEX) {
        left.appendChild(right)
        left.kind = .ASSIGN_INDEX
        return left.withRange(Range.span(left.range, right.range)).withInternalRange(Range.span(left.internalRange, right.range))
      }
      return Node.createBinary(kind, left, right).withRange(Range.span(left.range, right.range)).withInternalRange(token.range)
    }
  }

  class CastParselet : InfixParselet {
    override Node parse(ParserContext context, Node left) {
      context.next()
      var type = parseType(context)
      if (type == null) {
        return null
      }
      return Node.createCast(left, type).withRange(context.spanSince(left.range))
    }
  }

  class NotParselet : InfixParselet {
    override Node parse(ParserContext context, Node left) {
      var notToken = context.next()
      var inToken = context.current()
      if (!context.expect(.IN)) {
        return null
      }
      var right = pratt.parse(context, .COMPARE)
      if (right == null) {
        return null
      }
      var range = context.spanSince(left.range)
      return Node.createUnary(.NOT, Node.createBinary(.IN, left, right).withRange(range).withInternalRange(inToken.range)).withRange(range).withInternalRange(notToken.range)
    }
  }

  class HookParselet : InfixParselet {
    override Node parse(ParserContext context, Node left) {
      context.next()
      var middle = pratt.parse(context, (Precedence)(Precedence.ASSIGN - 1))
      if (middle == null || !context.expect(.COLON)) {
        return null
      }
      var right = pratt.parse(context, (Precedence)(Precedence.ASSIGN - 1))
      if (right == null) {
        return null
      }
      return Node.createHook(left, middle, right).withRange(context.spanSince(left.range))
    }
  }

  class LambdaParselet : PrefixParselet {
    override Node parse(ParserContext context) {
      var token = context.current()
      var symbol = FunctionSymbol(.FUNCTION_LOCAL, "<lambda>")
      if (!parseFunctionBlock(context, symbol)) {
        return null
      }
      symbol.range = context.spanSince(token.range)
      return Node.createLambda(symbol).withRange(symbol.range)
    }
  }

  class NameOrLambdaParselet : PrefixParselet {
    override Node parse(ParserContext context) {
      var range = context.next().range
      var name = range.toString()

      // Parse a lambda of the form "x => x * x"
      if (context.peek(.ARROW)) {
        var symbol = FunctionSymbol(.FUNCTION_LOCAL, "<lambda>")
        var arg = VariableSymbol(.VARIABLE_LOCAL, name)
        arg.range = range
        symbol.arguments.push(arg)
        if (!parseFunctionBlock(context, symbol)) {
          return null
        }
        symbol.range = context.spanSince(range)
        return Node.createLambda(symbol).withRange(symbol.range)
      }

      return Node.createName(name).withRange(range)
    }
  }

  class InitializerParselet : PrefixParselet {
    override Node parse(ParserContext context) {
      var token = context.next()
      List<Node> values = []
      NodeKind kind = token.kind == .LEFT_BRACE ? .INITIALIZER_SET : .INITIALIZER_LIST
      if (token.kind != .INDEX) {
        var checkForColon = kind != .INITIALIZER_LIST
        TokenKind end = checkForColon ? .RIGHT_BRACE : .RIGHT_BRACKET
        while (!context.peek(end)) {
          var first = pratt.parse(context, .LOWEST)
          if (first == null) {
            return null
          }
          var colon = context.current()
          if (!checkForColon || values.size() == 0 && !context.peek(.COLON)) {
            values.push(first)
            checkForColon = false
          } else {
            if (!context.expect(.COLON)) {
              return null
            }
            var second = pratt.parse(context, .LOWEST)
            if (second == null) {
              return null
            }
            values.push(Node.createPair(first, second).withRange(Range.span(first.range, second.range)).withInternalRange(colon.range))
            kind = .INITIALIZER_MAP
          }
          if (!context.eat(.COMMA)) {
            break
          }
        }
        if (!context.expect(end)) {
          return null
        }
      }
      return Node.createInitializer(kind, values).withRange(context.spanSince(token.range))
    }
  }

  class IndexParselet : InfixParselet {
    override Node parse(ParserContext context, Node left) {
      var token = context.next()
      var arguments = token.kind == .LEFT_BRACKET ? parseCommaSeparatedList(context, .RIGHT_BRACKET) : []
      if (arguments == null) {
        return null
      }
      var node = Node.createIndex(left, arguments).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
      if (token.kind != .ASSIGN_INDEX) {
        return node
      }
      var right = pratt.parse(context, .ASSIGN)
      if (right == null) {
        return null
      }
      node.kind = .ASSIGN_INDEX
      node.appendChild(right)
      return node.withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
    }
  }

  class ParenthesisParselet : PrefixParselet {
    override Node parse(ParserContext context) {
      var token = context.next()

      // Try to parse a group
      if (!context.peek(.RIGHT_PARENTHESIS)) {
        var value = pratt.parse(context, .LOWEST)
        if (value == null) {
          return null
        }
        if ((value.kind != .NAME || !peekType(context)) && context.eat(.RIGHT_PARENTHESIS)) {
          if (value.kind != .NAME || !context.peek(.ARROW)) {
            return value.withRange(context.spanSince(token.range))
          }
          context.undo()
        }
        context.undo()
      }

      // Parse a lambda instead
      var symbol = FunctionSymbol(.FUNCTION_LOCAL, "<lambda>")
      if (!parseFunctionArguments(context, symbol) || !parseFunctionReturnTypeAndBlock(context, symbol)) {
        return null
      }
      symbol.range = context.spanSince(token.range)
      return Node.createLambda(symbol).withRange(symbol.range)
    }
  }

  class NameOrFunctionTypeParselet : PrefixParselet {
    override Node parse(ParserContext context) {
      var token = context.next()
      var name = token.range.toString()

      if (name != "fn" || !context.eat(.LEFT_PARENTHESIS)) {
        return Node.createName(name).withRange(token.range)
      }

      // Parse argument types
      List<Node> argTypes = []
      while (!context.eat(.RIGHT_PARENTHESIS)) {
        if (argTypes.size() != 0 && !context.expect(.COMMA)) {
          return null
        }
        var type = parseType(context)
        if (type == null) {
          return null
        }
        argTypes.push(type)
      }
      Node returnType = null

      // Parse return type if present
      if (peekType(context)) {
        returnType = parseType(context)
        if (returnType == null) {
          return null
        }
      }

      return Node.createLambdaType(argTypes, returnType).withRange(context.spanSince(token.range))
    }
  }

  class ParameterizedParselet : InfixParselet {
    override Node parse(ParserContext context, Node left) {
      var token = context.next()
      List<Node> parameters = []
      do {
        var type = parseType(context)
        if (type == null) {
          return null
        }
        parameters.push(type)
      } while (context.eat(.COMMA))
      if (!context.expect(.END_PARAMETER_LIST)) {
        return null
      }
      return Node.createParameterize(left, parameters).withRange(context.spanSince(left.range)).withInternalRange(context.spanSince(token.range))
    }
  }

  pure Pratt createExpressionParser() {
    var pratt = Pratt()

    ////////////////////////////////////////////////////////////////////////////////
    // Literals
    ////////////////////////////////////////////////////////////////////////////////

    pratt.literal(.DOUBLE, DoubleLiteral())
    pratt.literal(.FALSE, BoolLiteral(false))
    pratt.literal(.INT_BINARY, IntLiteral(2))
    pratt.literal(.INT_OCTAL, IntLiteral(8))
    pratt.literal(.INT_HEX, IntLiteral(16))
    pratt.literal(.INT, IntLiteral(10))
    pratt.literal(.NULL, TokenLiteral(.NULL))
    pratt.literal(.STRING, StringLiteral())
    pratt.literal(.CHARACTER, CharacterLiteral())
    pratt.literal(.TRUE, BoolLiteral(true))

    ////////////////////////////////////////////////////////////////////////////////
    // Unary expressions
    ////////////////////////////////////////////////////////////////////////////////

    pratt.prefix(.MINUS, .UNARY_PREFIX, UnaryPrefix(.NEGATIVE))
    pratt.prefix(.NOT, .UNARY_PREFIX, UnaryPrefix(.NOT))
    pratt.prefix(.PLUS, .UNARY_PREFIX, UnaryPrefix(.POSITIVE))
    pratt.prefix(.TILDE, .UNARY_PREFIX, UnaryPrefix(.COMPLEMENT))

    ////////////////////////////////////////////////////////////////////////////////
    // Binary expressions
    ////////////////////////////////////////////////////////////////////////////////

    pratt.infix(.BITWISE_OR, .BITWISE_OR, BinaryInfix(.BITWISE_OR))
    pratt.infix(.BITWISE_XOR, .BITWISE_XOR, BinaryInfix(.BITWISE_XOR))
    pratt.infix(.COMPARE, .COMPARE, BinaryInfix(.COMPARE))
    pratt.infix(.DIVIDE, .MULTIPLY, BinaryInfix(.DIVIDE))
    pratt.infix(.EQUAL, .EQUAL, BinaryInfix(.EQUAL))
    pratt.infix(.GREATER_THAN, .COMPARE, BinaryInfix(.GREATER_THAN))
    pratt.infix(.GREATER_THAN_OR_EQUAL, .COMPARE, BinaryInfix(.GREATER_THAN_OR_EQUAL))
    pratt.infix(.IN, .COMPARE, BinaryInfix(.IN))
    pratt.infix(.LESS_THAN, .COMPARE, BinaryInfix(.LESS_THAN))
    pratt.infix(.LESS_THAN_OR_EQUAL, .COMPARE, BinaryInfix(.LESS_THAN_OR_EQUAL))
    pratt.infix(.LOGICAL_AND, .LOGICAL_AND, BinaryInfix(.LOGICAL_AND))
    pratt.infix(.LOGICAL_OR, .LOGICAL_OR, BinaryInfix(.LOGICAL_OR))
    pratt.infix(.MINUS, .ADD, BinaryInfix(.SUBTRACT))
    pratt.infix(.MULTIPLY, .MULTIPLY, BinaryInfix(.MULTIPLY))
    pratt.infix(.NOT_EQUAL, .EQUAL, BinaryInfix(.NOT_EQUAL))
    pratt.infix(.PLUS, .ADD, BinaryInfix(.ADD))
    pratt.infix(.POWER, .UNARY_PREFIX, BinaryInfix(.POWER))
    pratt.infix(.REMAINDER, .MULTIPLY, BinaryInfix(.REMAINDER))
    pratt.infix(.SHIFT_LEFT, .SHIFT, BinaryInfix(.SHIFT_LEFT))
    pratt.infix(.SHIFT_RIGHT, .SHIFT, BinaryInfix(.SHIFT_RIGHT))

    pratt.infixRight(.ASSIGN, .ASSIGN, BinaryInfix(.ASSIGN))
    pratt.infixRight(.ASSIGN_BITWISE_AND, .ASSIGN, BinaryInfix(.ASSIGN_BITWISE_AND))
    pratt.infixRight(.ASSIGN_BITWISE_OR, .ASSIGN, BinaryInfix(.ASSIGN_BITWISE_OR))
    pratt.infixRight(.ASSIGN_BITWISE_XOR, .ASSIGN, BinaryInfix(.ASSIGN_BITWISE_XOR))
    pratt.infixRight(.ASSIGN_DIVIDE, .ASSIGN, BinaryInfix(.ASSIGN_DIVIDE))
    pratt.infixRight(.ASSIGN_MINUS, .ASSIGN, BinaryInfix(.ASSIGN_SUBTRACT))
    pratt.infixRight(.ASSIGN_MULTIPLY, .ASSIGN, BinaryInfix(.ASSIGN_MULTIPLY))
    pratt.infixRight(.ASSIGN_PLUS, .ASSIGN, BinaryInfix(.ASSIGN_ADD))
    pratt.infixRight(.ASSIGN_POWER, .ASSIGN, BinaryInfix(.ASSIGN_POWER))
    pratt.infixRight(.ASSIGN_REMAINDER, .ASSIGN, BinaryInfix(.ASSIGN_REMAINDER))
    pratt.infixRight(.ASSIGN_SHIFT_LEFT, .ASSIGN, BinaryInfix(.ASSIGN_SHIFT_LEFT))
    pratt.infixRight(.ASSIGN_SHIFT_RIGHT, .ASSIGN, BinaryInfix(.ASSIGN_SHIFT_RIGHT))

    ////////////////////////////////////////////////////////////////////////////////
    // Other expressions
    ////////////////////////////////////////////////////////////////////////////////

    pratt.parselet(.ARROW, .LOWEST).prefix = LambdaParselet()
    pratt.parselet(.AS, .COMPARE).infix = CastParselet()
    pratt.parselet(.ASSIGN_INDEX, .MEMBER).infix = IndexParselet()
    pratt.parselet(.DOT, .MEMBER).infix = DotParselet()
    pratt.parselet(.IDENTIFIER, .LOWEST).prefix = NameOrLambdaParselet()
    pratt.parselet(.INDEX, .LOWEST).prefix = InitializerParselet()
    pratt.parselet(.INDEX, .MEMBER).infix = IndexParselet()
    pratt.parselet(.LEFT_BRACE, .LOWEST).prefix = InitializerParselet()
    pratt.parselet(.LEFT_BRACKET, .LOWEST).prefix = InitializerParselet()
    pratt.parselet(.LEFT_BRACKET, .MEMBER).infix = IndexParselet()
    pratt.parselet(.LEFT_PARENTHESIS, .LOWEST).prefix = ParenthesisParselet()
    pratt.parselet(.LEFT_PARENTHESIS, .UNARY_POSTFIX).infix = CallParselet()
    pratt.parselet(.NOT, .COMPARE).infix = NotParselet()
    pratt.parselet(.QUESTION_MARK, .ASSIGN).infix = HookParselet()
    pratt.parselet(.START_PARAMETER_LIST, .MEMBER).infix = ParameterizedParselet()

    return pratt
  }

  pure Pratt createTypeParser() {
    var pratt = Pratt()

    pratt.literal(.DYNAMIC, TokenLiteral(.DYNAMIC))
    pratt.parselet(.DOT, .MEMBER).infix = DotParselet()
    pratt.parselet(.IDENTIFIER, .LOWEST).prefix = NameOrFunctionTypeParselet()
    pratt.parselet(.START_PARAMETER_LIST, .MEMBER).infix = ParameterizedParselet()

    return pratt
  }

  var pratt = createExpressionParser()
  var typePratt = createTypeParser()
}
