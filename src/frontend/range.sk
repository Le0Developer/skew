namespace skew {
  class FormattedRange {
    var line string
    var range string

    def new(line string, range string) {
      self.line = line
      self.range = range
    }
  }

  class Range {
    var source Source
    var start int
    var end int

    def new(source Source, start int, end int) {
      self.source = source
      self.start = start
      self.end = end
    }

    def toString string {
      return source.contents.slice(start, end)
    }

    def locationString string {
      var location = source.indexToLineColumn(start)
      return source.name ":" (location.line + 1) ":" (location.column + 1)
    }

    def format(maxLength int) FormattedRange {
      assert(source != null)
      var start = source.indexToLineColumn(self.start)
      var end = source.indexToLineColumn(self.end)
      var line = source.contentsOfLine(start.line)
      var length = line.count

      # Use a unicode iterator to count the actual code points so they don't get sliced through the middle
      var iterator = unicode.StringIterator.INSTANCE.reset(line, 0)
      var a = iterator.countCodePointsUntil(start.column)
      var b = a + iterator.countCodePointsUntil(end.line == start.line ? end.column : length)
      var count = b + iterator.countCodePointsUntil(length)

      # Ensure the line length doesn't exceed maxLength
      if maxLength > 0 && count > maxLength {
        var centeredWidth = Math.min(b - a, maxLength / 2)
        var centeredStart = Math.max((maxLength - centeredWidth) / 2, 3)
        var codePoints = line.codePoints

        # Left aligned
        if a < centeredStart {
          line = string.fromCodePoints(codePoints.slice(0, maxLength - 3)) + "..."
          if b > maxLength - 3 {
            b = maxLength - 3
          }
        }

        # Right aligned
        else if count - a < maxLength - centeredStart {
          var offset = count - maxLength
          line = "..." + string.fromCodePoints(codePoints.slice(offset + 3, count))
          a -= offset
          b -= offset
        }

        # Center aligned
        else {
          var offset = a - centeredStart
          line = "..." + string.fromCodePoints(codePoints.slice(offset + 3, offset + maxLength - 3)) + "..."
          a -= offset
          b -= offset
          if b > maxLength - 3 {
            b = maxLength - 3
          }
        }
      }

      return FormattedRange.new(line, " ".repeat(a) + (b - a < 2 ? "^" : "~".repeat(b - a)))
    }

    def fromStart(count int) Range {
      assert(count >= 0 && count <= end - start)
      return Range.new(source, start, start + count)
    }

    def fromEnd(count int) Range {
      assert(count >= 0 && count <= end - start)
      return Range.new(source, end - count, end)
    }

    def slice(offsetStart int, offsetEnd int) Range {
      assert(offsetStart >= 0 && offsetStart <= offsetEnd && offsetEnd <= end - start)
      return Range.new(source, start + offsetStart, start + offsetEnd)
    }
  }

  namespace Range {
    def span(start Range, end Range) Range {
      assert(start.source == end.source)
      assert(start.start <= end.end)
      return Range.new(start.source, start.start, end.end)
    }

    def inner(start Range, end Range) Range {
      assert(start.source == end.source)
      assert(start.end <= end.start)
      return Range.new(start.source, start.end, end.start)
    }

    def before(outer Range, inner Range) Range {
      assert(outer.source == inner.source)
      assert(outer.start <= inner.start)
      assert(outer.end >= inner.end)
      return Range.new(outer.source, outer.start, inner.start)
    }

    def after(outer Range, inner Range) Range {
      assert(outer.source == inner.source)
      assert(outer.start <= inner.start)
      assert(outer.end >= inner.end)
      return Range.new(outer.source, inner.end, outer.end)
    }

    def equal(left Range, right Range) bool {
      return left.source == right.source && left.start == right.start && left.end == right.end
    }
  }
}
