namespace skew {
  enum DiagnosticKind {
    ERROR
    WARNING
  }

  class Diagnostic {
    DiagnosticKind kind
    Range range
    string text
    Range noteRange = null
    var noteText = ""

    static string format(string kind, Range range, string text) {
      if (range == null) {
        return kind + ": " + text + "\n"
      }
      var formatted = range.format(0)
      return range.locationString() + ": " + kind + ": " + text + "\n" + formatted.line + "\n" + formatted.range + "\n"
    }
  }

  class Log {
    List<Diagnostic> diagnostics = []
    var warningCount = 0
    var errorCount = 0

    string toString() {
      var builder = StringBuilder()

      // Emit the log assuming an infinite terminal width
      for (var i = 0; i < diagnostics.size(); i++) {
        var diagnostic = diagnostics[i]
        builder.append(Diagnostic.format(diagnostic.kind == .ERROR ? "error" : "warning", diagnostic.range, diagnostic.text))

        // Append notes after the diagnostic they apply to
        if (diagnostic.noteRange != null) {
          builder.append(Diagnostic.format("note", diagnostic.noteRange, diagnostic.noteText))
        }
      }

      return builder.toString()
    }

    bool isEmpty() {
      return diagnostics.size() == 0
    }

    bool hasErrors() {
      return errorCount != 0
    }

    bool hasWarnings() {
      return warningCount != 0
    }

    void error(Range range, string text) {
      diagnostics.push(Diagnostic(.ERROR, range, text))
      errorCount++
    }

    void warning(Range range, string text) {
      diagnostics.push(Diagnostic(.WARNING, range, text))
      warningCount++
    }

    void note(Range range, string text) {
      var last = diagnostics.last()
      last.noteRange = range
      last.noteText = text
    }
  }

  in Log {
    void syntaxErrorInvalidEscapeSequence(Range range) {
      error(range, "Invalid escape sequence")
    }

    void syntaxErrorExtraData(Range range, string text) {
      error(range, "Syntax error \"" + text + "\"")
    }

    void syntaxErrorUnexpectedToken(Token token) {
      error(token.range, "Unexpected " + token.kind)
    }

    void syntaxErrorExpectedToken(Range range, TokenKind found, TokenKind expected) {
      error(range, "Expected " + expected + " but found " + found)
    }

    void syntaxWarningPreferNotIn(Range range) {
      warning(range, "The \"not in\" operator is preferred over nesting \"in\" inside \"not\"")
    }
  }

  in Log {
    private static string expectedCountText(string singular, int expected, int found) {
      return "Expected " + expected + " " + singular + prettyPrint.plural(expected) +
        " but found " + found + " " + singular + prettyPrint.plural(found)
    }

    void semanticErrorDuplicateSymbol(Range range, string name, Range previous) {
      error(range, "\"" + name + "\" is already declared")
      if (previous != null) {
        note(previous, "The previous declaration is here")
      }
    }

    void semanticErrorShadowedSymbol(Range range, string name, Range previous) {
      error(range, "\"" + name + "\" shadows a previous declaration")
      if (previous != null) {
        note(previous, "The previous declaration is here")
      }
    }

    void semanticErrorDuplicateTypeParameters(Range range, string name, Range previous) {
      error(range, "\"" + name + "\" already has type parameters")
      if (previous != null) {
        note(previous, "Type parameters were previously declared here")
      }
    }

    void semanticErrorDuplicateBaseType(Range range, string name, Range previous) {
      error(range, "\"" + name + "\" already has a base type")
      if (previous != null) {
        note(previous, "The previous base type is here")
      }
    }

    void semanticErrorCyclicDeclaration(Range range, string name) {
      error(range, "Cyclic declaration of \"" + name + "\"")
    }

    void semanticErrorUndeclaredSymbol(Range range, string name) {
      error(range, "\"" + name + "\" is not declared")
    }

    void semanticErrorUnknownMemberSymbol(Range range, string name, Type type) {
      error(range, "\"" + name + "\" is not declared on type \"" + type + "\"")
    }

    void semanticErrorVarMissingType(Range range, string name) {
      error(range, "Unable to determine the type of \"" + name + "\"")
    }

    void semanticErrorVarMissingValue(Range range) {
      error(range, "Implicitly typed variables must be initialized")
    }

    void semanticErrorInvalidCall(Range range, Type type) {
      error(range, "Cannot call value of type \"" + type + "\"")
    }

    void semanticErrorCannotParameterize(Range range, Type type) {
      error(range, "Cannot parameterize \"" + type + (
        type.hasParameters() ? "\" because it is already parameterized" : "\" because it has no type parameters"))
    }

    void semanticErrorParameterCount(Range range, int expected, int found) {
      error(range, expectedCountText("type parameter", expected, found))
    }

    void semanticErrorArgumentCount(Range range, int expected, int found) {
      error(range, expectedCountText("argument", expected, found))
    }

    void semanticErrorGetterCalledTwice(Range range, string name) {
      error(range, "The function \"" + name + "\" is already called implicitly")
    }

    void semanticErrorUseOfVoidFunction(Range range, string name) {
      error(range, "The function \"" + name + "\" does not return a value")
    }

    void semanticErrorUseOfVoidLambda(Range range) {
      error(range, "This call does not return a value")
    }

    void semanticErrorBadVariableType(Range range, Type type) {
      error(range, "Implicitly typed variables cannot be of type \"" + type + "\"")
    }

    void semanticErrorUseOfVoidAssignment(Range range, string name) {
      error(range, "Cannot use the return value of the assignment operator \"" + name + "\"")
    }

    void semanticErrorMemberUnexpectedGlobal(Range range, string name) {
      error(range, "Cannot access global member \"" + name + "\" from an instance context")
    }

    void semanticErrorMemberUnexpectedInstance(Range range, string name) {
      error(range, "Cannot access instance member \"" + name + "\" from a global context")
    }

    void semanticErrorConstructorReturnType(Range range) {
      error(range, "Constructors cannot have a return type")
    }

    void semanticErrorNoMatchingOverload(Range range, string name, int count) {
      error(range, "No overload of \"" + name + "\" was found that takes " + count + " argument" + prettyPrint.plural(count))
    }

    void semanticErrorAmbiguousOperator(Range range, string name, int count) {
      error(range, "Multiple matching overloads of \"" + name + "\" were found that take " + count + " argument" + prettyPrint.plural(count))
    }

    void semanticErrorUnexpectedExpression(Range range, Type type) {
      error(range, "Unexpected expression of type \"" + type + "\"")
    }

    void semanticErrorUnexpectedType(Range range, Type type) {
      error(range, "Unexpected type \"" + type + "\"")
    }

    void semanticErrorIncompatibleTypes(Range range, Type from, Type to, bool isCastAllowed) {
      error(range, "Cannot convert from type \"" + from + "\" to type \"" + to + "\"" + (isCastAllowed ? " without a cast" : ""))
    }

    void semanticErrorSetterWrongArgumentCount(Range range, string name) {
      error(range, "Expected \"" + name + "\" to take 1 argument")
    }

    void semanticErrorUnexpectedReturnValue(Range range) {
      error(range, "Cannot return a value inside a function without a return type")
    }

    void semanticErrorBadReturnType(Range range, Type type) {
      error(range, "Cannot create a function with a return type of \"" + type + "\"")
    }

    void semanticErrorExpectedReturnValue(Range range, Type type) {
      error(range, "Must return a value of type \"" + type + "\"")
    }

    void semanticErrorMissingReturn(Range range, string name, Type type) {
      error(range, "All control paths for \"" + name + "\" must return a value of type \"" + type + "\"")
    }

    void semanticErrorBadStorage(Range range) {
      error(range, "Cannot store to this location")
    }

    void semanticErrorUnparameterizedType(Range range, Type type) {
      error(range, "Cannot use unparameterized type \"" + type + "\"")
    }
  }
}
