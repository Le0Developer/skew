namespace skew {
  enum DiagnosticKind {
    ERROR
    WARNING
  }

  class Diagnostic {
    var kind DiagnosticKind
    var range Range
    var text string
    var noteRange Range = null
    var noteText = ""
  }

  namespace Diagnostic {
    def format(kind string, range Range, text string) string {
      if range == null {
        return kind ": " text "\n"
      }
      var formatted = range.format(0)
      return range.locationString ": " kind ": " text "\n" formatted.line "\n" formatted.range "\n"
    }
  }

  class Log {
    var diagnostics List<Diagnostic> = []
    var warningCount = 0
    var errorCount = 0

    def toString string {
      var builder = StringBuilder.new

      # Emit the log assuming an infinite terminal width
      for diagnostic in diagnostics {
        builder.append(Diagnostic.format(diagnostic.kind == .ERROR ? "error" : "warning", diagnostic.range, diagnostic.text))

        # Append notes after the diagnostic they apply to
        if diagnostic.noteRange != null {
          builder.append(Diagnostic.format("note", diagnostic.noteRange, diagnostic.noteText))
        }
      }

      return builder.toString
    }

    def isEmpty bool {
      return diagnostics.isEmpty
    }

    def hasErrors bool {
      return errorCount != 0
    }

    def hasWarnings bool {
      return warningCount != 0
    }

    def error(range Range, text string) {
      diagnostics.append(Diagnostic.new(.ERROR, range, text))
      errorCount++
    }

    def warning(range Range, text string) {
      diagnostics.append(Diagnostic.new(.WARNING, range, text))
      warningCount++
    }

    def note(range Range, text string) {
      var last = diagnostics.last
      last.noteRange = range
      last.noteText = text
    }
  }

  class Log {
    def syntaxErrorInvalidEscapeSequence(range Range) {
      error(range, "Invalid escape sequence")
    }

    def syntaxErrorInvalidCharacter(range Range) {
      error(range, "Invalid character literal")
    }

    def syntaxErrorExtraData(range Range, text string) {
      error(range, "Syntax error \"" text "\"")
    }

    def syntaxErrorUnexpectedToken(token Token) {
      error(token.range, "Unexpected " token.kind)
    }

    def syntaxErrorExpectedToken(range Range, found TokenKind, expected TokenKind) {
      error(range, "Expected " expected " but found " found)
    }

    def syntaxErrorEmptyFunctionParentheses(range Range) {
      error(range, "Functions without arguments do not use parentheses")
    }

    def semanticErrorComparisonOperatorNotNumeric(range Range) {
      error(range, "The comparison operator must have a numeric return type")
    }

    def syntaxErrorBadDeclarationInsideEnum(range Range) {
      error(range, "Cannot use this declaration inside an enum")
    }
  }

  namespace Log {
    @private {
      def expectedCountText(singular string, expected int, found int) string {
        return "Expected " expected " " singular + prettyPrint.plural(expected) " but found " found " " singular + prettyPrint.plural(found)
      }

      def formatArgumentTypes(types List<Type>) string {
        if types == null {
          return ""
        }
        var names List<string> = []
        for type in types {
          names.append(type.toString)
        }
        return " of type" prettyPrint.plural(types.count) " " prettyPrint.join(names, "and")
      }
    }
  }

  class Log {
    def semanticWarningExtraParentheses(range Range) {
      warning(range, "Unnecessary parentheses")
    }

    def semanticWarningUnusedExpression(range Range) {
      warning(range, "Unused expression")
    }

    def semanticErrorDuplicateSymbol(range Range, name string, previous Range) {
      error(range, "\"" name "\" is already declared")
      if previous != null {
        note(previous, "The previous declaration is here")
      }
    }

    def semanticErrorShadowedSymbol(range Range, name string, previous Range) {
      error(range, "\"" name "\" shadows a previous declaration")
      if previous != null {
        note(previous, "The previous declaration is here")
      }
    }

    def semanticErrorDuplicateTypeParameters(range Range, name string, previous Range) {
      error(range, "\"" name "\" already has type parameters")
      if previous != null {
        note(previous, "Type parameters were previously declared here")
      }
    }

    def semanticErrorDuplicateBaseType(range Range, name string, previous Range) {
      error(range, "\"" name "\" already has a base type")
      if previous != null {
        note(previous, "The previous base type is here")
      }
    }

    def semanticErrorCyclicDeclaration(range Range, name string) {
      error(range, "Cyclic declaration of \"" name "\"")
    }

    def semanticErrorUndeclaredSymbol(range Range, name string) {
      error(range, "\"" name "\" is not declared")
    }

    def semanticErrorUnknownMemberSymbol(range Range, name string, type Type) {
      error(range, "\"" name "\" is not declared on type \"" type "\"")
    }

    def semanticErrorVarMissingType(range Range, name string) {
      error(range, "Unable to determine the type of \"" name "\"")
    }

    def semanticErrorVarMissingValue(range Range, name string) {
      error(range, "The implicitly typed variable \"" name "\" must be initialized")
    }

    def semanticErrorConstMissingValue(range Range, name string) {
      error(range, "The constant \"" name "\" must be initialized")
    }

    def semanticErrorInvalidCall(range Range, type Type) {
      error(range, "Cannot call value of type \"" type "\"")
    }

    def semanticErrorCannotParameterize(range Range, type Type) {
      error(range, "Cannot parameterize \"" type + (
        type.isParameterized ? "\" because it is already parameterized" : "\" because it has no type parameters"))
    }

    def semanticErrorParameterCount(range Range, expected int, found int) {
      error(range, expectedCountText("type parameter", expected, found))
    }

    def semanticErrorArgumentCount(range Range, expected int, found int, name string, function Range) {
      error(range, expectedCountText("argument", expected, found) + (name != "" ? " when calling \"" name "\"" : ""))
      if function != null {
        note(function, "The function declaration is here")
      }
    }

    def semanticErrorGetterCalledTwice(range Range, name string) {
      error(range, "The function \"" name "\" takes no arguments and is already called implicitly")
    }

    def semanticErrorUseOfVoidFunction(range Range, name string) {
      error(range, "The function \"" name "\" does not return a value")
    }

    def semanticErrorUseOfVoidLambda(range Range) {
      error(range, "This call does not return a value")
    }

    def semanticErrorBadVariableType(range Range, type Type) {
      error(range, "Implicitly typed variables cannot be of type \"" type "\"")
    }

    def semanticErrorMemberUnexpectedGlobal(range Range, name string) {
      error(range, "Cannot access global member \"" name "\" from an instance context")
    }

    def semanticErrorMemberUnexpectedInstance(range Range, name string) {
      error(range, "Cannot access instance member \"" name "\" from a global context")
    }

    def semanticErrorMemberUnexpectedTypeParameter(range Range, name string) {
      error(range, "Cannot access type parameter \"" name "\" here")
    }

    def semanticErrorConstructorReturnType(range Range) {
      error(range, "Constructors cannot have a return type")
    }

    def semanticErrorNoMatchingOverload(range Range, name string, count int, types List<Type>) {
      error(range, "No overload of \"" name "\" was found that takes " count " argument" prettyPrint.plural(count) + formatArgumentTypes(types))
    }

    def semanticErrorAmbiguousOverload(range Range, name string, count int, types List<Type>) {
      error(range, "Multiple matching overloads of \"" name "\" were found that can take " count " argument" prettyPrint.plural(count) + formatArgumentTypes(types))
    }

    def semanticErrorUnexpectedExpression(range Range, type Type) {
      error(range, "Unexpected expression of type \"" type "\"")
    }

    def semanticErrorUnexpectedType(range Range, type Type) {
      error(range, "Unexpected type \"" type "\"")
    }

    def semanticErrorIncompatibleTypes(range Range, from Type, to Type, isCastAllowed bool) {
      error(range, "Cannot convert from type \"" from "\" to type \"" to "\"" (isCastAllowed ? " without a cast" : ""))
    }

    def semanticWarningExtraCast(range Range, from Type, to Type) {
      warning(range, "Unnecessary cast from type \"" from "\" to type \"" to "\"")
    }

    def semanticErrorWrongArgumentCount(range Range, name string, count int) {
      error(range, "Expected \"" name "\" to take " count " argument" prettyPrint.plural(count))
    }

    def semanticErrorWrongArgumentCountRange(range Range, name string, lower int, upper int) {
      if lower == 0 {
        error(range, "Expected \"" name "\" to take at most " upper " argument" prettyPrint.plural(upper))
      } else if upper == -1 {
        error(range, "Expected \"" name "\" to take at least " lower " argument" prettyPrint.plural(lower))
      } else {
        error(range, "Expected \"" name "\" to take between " lower " and " upper " arguments")
      }
    }

    def semanticErrorExpectedList(range Range, name string, type Type) {
      error(range, "Expected argument \"" name "\" to be of type \"List<T>\" instead of type \"" type "\"")
    }

    def semanticErrorUnexpectedReturnValue(range Range) {
      error(range, "Cannot return a value inside a function without a return type")
    }

    def semanticErrorBadReturnType(range Range, type Type) {
      error(range, "Cannot create a function with a return type of \"" type "\"")
    }

    def semanticErrorExpectedReturnValue(range Range, type Type) {
      error(range, "Must return a value of type \"" type "\"")
    }

    def semanticErrorMissingReturn(range Range, name string, type Type) {
      error(range, "All control paths for \"" name "\" must return a value of type \"" type "\"")
    }

    def semanticErrorBadStorage(range Range) {
      error(range, "Cannot store to this location")
    }

    def semanticErrorStorageToConstSymbol(range Range, name string) {
      error(range, "Cannot store to constant symbol \"" name "\"")
    }

    def semanticErrorAccessViolation(range Range, level string, name string) {
      error(range, "Cannot access \"" level "\" symbol \"" name "\" here")
    }

    def semanticWarningDeprecatedUsage(range Range, name string) {
      warning(range, "Use of deprecated symbol \"" name "\"")
    }

    def semanticErrorUnparameterizedType(range Range, type Type) {
      error(range, "Cannot use unparameterized type \"" type "\" here")
    }

    def semanticErrorParameterizedType(range Range, type Type) {
      error(range, "Cannot use parameterized type \"" type "\" here")
    }

    def semanticErrorNoCommonType(range Range, left Type, right Type) {
      error(range, "No common type for \"" left "\" and \"" right "\"")
    }

    def semanticErrorInvalidAnnotation(range Range, annotation string, name string) {
      error(range, "Cannot use the annotation \"" annotation "\" on \"" name "\"")
    }

    def semanticErrorDuplicateAnnotation(range Range, annotation string, name string) {
      error(range, "Duplicate annotation \"" annotation "\" on \"" name "\"")
    }

    def semanticErrorBadForValue(range Range, type Type) {
      error(range, "Cannot iterate over type \"" type "\"")
    }

    def semanticWarningEmptyRange(range Range) {
      warning(range, "This range is empty")
    }

    def semanticErrorMissingDotContext(range Range, name string) {
      error(range, "Cannot access \"" name "\" without type context")
    }

    def semanticErrorInitializerTypeInferenceFailed(range Range) {
      error(range, "Cannot infer a type for this literal")
    }

    def semanticErrorDuplicateOverload(range Range, name string, previous Range) {
      error(range, "Duplicate overloaded function \"" name "\"")
      if previous != null {
        note(previous, "The previous declaration is here")
      }
    }

    def semanticErrorInvalidBaseType(range Range, type Type) {
      error(range, "Cannot derive from type \"" type "\"")
    }

    def semanticErrorBadOverride(range Range, name string, base Type, overridden Range) {
      error(range, "\"" name "\" overrides another declaration with the same name in base type \"" base "\"")
      if overridden != null {
        note(overridden, "The overridden declaration is here")
      }
    }

    def semanticErrorBadOverrideReturnType(range Range, name string, base Type, overridden Range) {
      error(range, "\"" name "\" overrides another function with the same name and argument types but a different return type in base type \"" base "\"")
      if overridden != null {
        note(overridden, "The overridden function is here")
      }
    }

    def semanticErrorModifierMissingOverride(range Range, name string, overridden Range) {
      error(range, "\"" name "\" overrides another symbol with the same name but is declared using \"def\" instead of \"over\"")
      if overridden != null {
        note(overridden, "The overridden declaration is here")
      }
    }

    def semanticErrorModifierUnusedOverride(range Range, name string) {
      error(range, "\"" name "\" is declared using \"over\" instead of \"def\" but does not override anything")
    }

    def semanticErrorBadSuper(range Range) {
      error(range, "Cannot use \"super\" here")
    }

    def semanticErrorBadJump(range Range, name string) {
      error(range, "Cannot use \"" name "\" outside a loop")
    }

    def semanticErrorMustCallFunction(range Range, name string) {
      error(range, "The function \"" name "\" must be called")
    }

    def semanticErrorDuplicateEntryPoint(range Range, previous Range) {
      error(range, "Multiple entry points are declared")
      note(previous, "The first entry point is here")
    }

    def semanticErrorInvalidEntryPointArguments(range Range, name string) {
      error(range, "Entry point \"" name "\" must take either no arguments or one argument of type \"List<string>\"")
    }

    def semanticErrorInvalidEntryPointReturnType(range Range, name string) {
      error(range, "Entry point \"" name "\" must return either nothing or a value of type \"int\"")
    }
  }
}
