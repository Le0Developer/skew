namespace skew {
  enum DiagnosticKind {
    ERROR
    WARNING
  }

  class Diagnostic {
    DiagnosticKind kind
    Range range
    string text
    Range noteRange = null
    var noteText = ""

    static string format(string kind, Range range, string text) {
      if (range == null) {
        return kind + ": " + text + "\n"
      }
      var formatted = range.format(0)
      return range.locationString() + ": " + kind + ": " + text + "\n" + formatted.line + "\n" + formatted.range + "\n"
    }
  }

  class Log {
    List<Diagnostic> diagnostics = []
    var warningCount = 0
    var errorCount = 0

    string toString() {
      var builder = StringBuilder()

      // Emit the log assuming an infinite terminal width
      for (var i = 0; i < diagnostics.size(); i++) {
        var diagnostic = diagnostics[i]
        builder.append(Diagnostic.format(diagnostic.kind == .ERROR ? "error" : "warning", diagnostic.range, diagnostic.text))

        // Append notes after the diagnostic they apply to
        if (diagnostic.noteRange != null) {
          builder.append(Diagnostic.format("note", diagnostic.noteRange, diagnostic.noteText))
        }
      }

      return builder.toString()
    }

    bool isEmpty() {
      return diagnostics.size() == 0
    }

    bool hasErrors() {
      return errorCount != 0
    }

    bool hasWarnings() {
      return warningCount != 0
    }

    void error(Range range, string text) {
      diagnostics.push(Diagnostic(.ERROR, range, text))
      errorCount++
    }

    void warning(Range range, string text) {
      diagnostics.push(Diagnostic(.WARNING, range, text))
      warningCount++
    }

    void note(Range range, string text) {
      var last = diagnostics.last()
      last.noteRange = range
      last.noteText = text
    }
  }

  in Log {
    void syntaxErrorInvalidEscapeSequence(Range range) {
      error(range, "Invalid escape sequence")
    }

    void syntaxErrorInvalidCharacter(Range range) {
      error(range, "Invalid character literal")
    }

    void syntaxErrorExtraData(Range range, string text) {
      error(range, "Syntax error \"" + text + "\"")
    }

    void syntaxErrorUnexpectedToken(Token token) {
      error(token.range, "Unexpected " + token.kind)
    }

    void syntaxErrorExpectedToken(Range range, TokenKind found, TokenKind expected) {
      error(range, "Expected " + expected + " but found " + found)
    }

    void syntaxErrorEmptyFunctionParentheses(Range range) {
      error(range, "Functions without arguments do not use parentheses")
    }

    void syntaxWarningPreferNotIn(Range range) {
      warning(range, "The \"not in\" operator is preferred over nesting \"in\" inside \"not\"")
    }

    void semanticErrorComparisonOperatorNotNumeric(Range range) {
      error(range, "The comparison operator must have a numeric return type")
    }
  }

  in Log {
    private static string expectedCountText(string singular, int expected, int found) {
      return "Expected " + expected + " " + singular + prettyPrint.plural(expected) +
        " but found " + found + " " + singular + prettyPrint.plural(found)
    }

    void semanticWarningUnusedExpression(Range range) {
      warning(range, "Unused expression")
    }

    void semanticErrorDuplicateSymbol(Range range, string name, Range previous) {
      error(range, "\"" + name + "\" is already declared")
      if (previous != null) {
        note(previous, "The previous declaration is here")
      }
    }

    void semanticErrorShadowedSymbol(Range range, string name, Range previous) {
      error(range, "\"" + name + "\" shadows a previous declaration")
      if (previous != null) {
        note(previous, "The previous declaration is here")
      }
    }

    void semanticErrorDuplicateTypeParameters(Range range, string name, Range previous) {
      error(range, "\"" + name + "\" already has type parameters")
      if (previous != null) {
        note(previous, "Type parameters were previously declared here")
      }
    }

    void semanticErrorDuplicateBaseType(Range range, string name, Range previous) {
      error(range, "\"" + name + "\" already has a base type")
      if (previous != null) {
        note(previous, "The previous base type is here")
      }
    }

    void semanticErrorCyclicDeclaration(Range range, string name) {
      error(range, "Cyclic declaration of \"" + name + "\"")
    }

    void semanticErrorUndeclaredSymbol(Range range, string name) {
      error(range, "\"" + name + "\" is not declared")
    }

    void semanticErrorUnknownMemberSymbol(Range range, string name, Type type) {
      error(range, "\"" + name + "\" is not declared on type \"" + type + "\"")
    }

    void semanticErrorVarMissingType(Range range, string name) {
      error(range, "Unable to determine the type of \"" + name + "\"")
    }

    void semanticErrorVarMissingValue(Range range, string name) {
      error(range, "The implicitly typed variable \"" + name + "\" must be initialized")
    }

    void semanticErrorConstMissingValue(Range range, string name) {
      error(range, "The constant \"" + name + "\" must be initialized")
    }

    void semanticErrorInvalidCall(Range range, Type type) {
      error(range, "Cannot call value of type \"" + type + "\"")
    }

    void semanticErrorCannotParameterize(Range range, Type type) {
      error(range, "Cannot parameterize \"" + type + (
        type.isParameterized() ? "\" because it is already parameterized" : "\" because it has no type parameters"))
    }

    void semanticErrorParameterCount(Range range, int expected, int found) {
      error(range, expectedCountText("type parameter", expected, found))
    }

    void semanticErrorArgumentCount(Range range, int expected, int found) {
      error(range, expectedCountText("argument", expected, found))
    }

    void semanticErrorGetterCalledTwice(Range range, string name) {
      error(range, "The function \"" + name + "\" takes no arguments and is already called implicitly")
    }

    void semanticErrorUseOfVoidFunction(Range range, string name) {
      error(range, "The function \"" + name + "\" does not return a value")
    }

    void semanticErrorUseOfVoidLambda(Range range) {
      error(range, "This call does not return a value")
    }

    void semanticErrorBadVariableType(Range range, Type type) {
      error(range, "Implicitly typed variables cannot be of type \"" + type + "\"")
    }

    void semanticErrorMemberUnexpectedGlobal(Range range, string name) {
      error(range, "Cannot access global member \"" + name + "\" from an instance context")
    }

    void semanticErrorMemberUnexpectedInstance(Range range, string name) {
      error(range, "Cannot access instance member \"" + name + "\" from a global context")
    }

    void semanticErrorConstructorReturnType(Range range) {
      error(range, "Constructors cannot have a return type")
    }

    void semanticErrorNoMatchingOverload(Range range, string name, int count) {
      error(range, "No overload of \"" + name + "\" was found that takes " + count + " argument" + prettyPrint.plural(count))
    }

    void semanticErrorAmbiguousOperator(Range range, string name, int count) {
      error(range, "Multiple matching overloads of \"" + name + "\" were found that take " + count + " argument" + prettyPrint.plural(count))
    }

    void semanticErrorUnexpectedExpression(Range range, Type type) {
      error(range, "Unexpected expression of type \"" + type + "\"")
    }

    void semanticErrorUnexpectedType(Range range, Type type) {
      error(range, "Unexpected type \"" + type + "\"")
    }

    void semanticErrorIncompatibleTypes(Range range, Type from, Type to, bool isCastAllowed) {
      error(range, "Cannot convert from type \"" + from + "\" to type \"" + to + "\"" + (isCastAllowed ? " without a cast" : ""))
    }

    void semanticErrorWrongArgumentCount(Range range, string name, int count) {
      error(range, "Expected \"" + name + "\" to take " + count + " argument" + prettyPrint.plural(count))
    }

    void semanticErrorWrongArgumentCountRange(Range range, string name, int lower, int upper) {
      if (lower == 0) {
        error(range, "Expected \"" + name + "\" to take at most " + upper + " argument" + prettyPrint.plural(upper))
      } else if (upper == -1) {
        error(range, "Expected \"" + name + "\" to take at least " + lower + " argument" + prettyPrint.plural(lower))
      } else {
        error(range, "Expected \"" + name + "\" to take between " + lower + " and " + upper + " arguments")
      }
    }

    void semanticErrorUnexpectedReturnValue(Range range) {
      error(range, "Cannot return a value inside a function without a return type")
    }

    void semanticErrorBadReturnType(Range range, Type type) {
      error(range, "Cannot create a function with a return type of \"" + type + "\"")
    }

    void semanticErrorExpectedReturnValue(Range range, Type type) {
      error(range, "Must return a value of type \"" + type + "\"")
    }

    void semanticErrorMissingReturn(Range range, string name, Type type) {
      error(range, "All control paths for \"" + name + "\" must return a value of type \"" + type + "\"")
    }

    void semanticErrorBadStorage(Range range) {
      error(range, "Cannot store to this location")
    }

    void semanticErrorStorageToConstSymbol(Range range, string name) {
      error(range, "Cannot store to constant symbol \"" + name + "\"")
    }

    void semanticErrorAccessViolation(Range range, string level, string name) {
      error(range, "Cannot access \"" + level + "\" symbol \"" + name + "\" here")
    }

    void semanticErrorUnparameterizedType(Range range, Type type) {
      error(range, "Cannot use unparameterized type \"" + type + "\"")
    }

    void semanticErrorNoCommonType(Range range, Type left, Type right) {
      error(range, "No common type for \"" + left + "\" and \"" + right + "\"")
    }

    void semanticErrorInvalidAnnotation(Range range, string annotation, string name) {
      error(range, "Cannot use the annotation \"" + annotation + "\" on \"" + name + "\"")
    }

    void semanticErrorDuplicateAnnotation(Range range, string annotation, string name) {
      error(range, "Duplicate annotation \"" + annotation + "\" on \"" + name + "\"")
    }

    void semanticErrorBadForValue(Range range, Type type) {
      error(range, "Cannot iterate over type \"" + type + "\"")
    }

    void semanticWarningEmptyRange(Range range) {
      warning(range, "This range is empty")
    }
  }
}
