namespace Skew {
  def hashCombine(left int, right int) int {
    return left ^ right - 0x61c88647 + (left << 6) + (left >> 2)
  }

  class UnionFind {
    var parents List<int> = []

    def allocate int {
      var index = parents.count
      parents.append(index)
      return index
    }

    def allocate(count int) UnionFind {
      for i in 0..count {
        parents.append(parents.count)
      }
      return self
    }

    def union(left int, right int) {
      parents[find(left)] = find(right)
    }

    def find(index int) int {
      assert(index >= 0 && index < parents.count)
      var parent = parents[index]
      if parent != index {
        parent = find(parent)
        parents[index] = parent
      }
      return parent
    }
  }
}

namespace Skew.PrettyPrint {
  def plural(value int) string {
    return value == 1 ? "" : "s"
  }

  def join(parts List<string>, trailing string) string {
    if parts.count < 3 {
      return (" " + trailing + " ").join(parts)
    }
    var text = ""
    for i in 0..parts.count {
      if i != 0 {
        text += ", "
        if i + 1 == parts.count {
          text += trailing + " "
        }
      }
      text += parts[i]
    }
    return text
  }

  def wrapWords(text string, width int) List<string> {
    # An invalid length means wrapping is disabled
    if width < 1 {
      return [text]
    }

    var words = text.split(" ")
    var lines List<string> = []
    var line = ""

    # Run the word wrapping algorithm
    var i = 0
    while i < words.count {
      var word = words[i]
      var lineLength = line.count
      var wordLength = word.count
      var estimatedLength = lineLength + 1 + wordLength
      i++

      # Collapse adjacent spaces
      if word == "" {
        continue
      }

      # Start the line
      if line == "" {
        while word.count > width {
          lines.append(word.slice(0, width))
          word = word.slice(width, word.count)
        }
        line = word
      }

      # Continue line
      else if estimatedLength < width {
        line += " " + word
      }

      # Continue and wrap
      else if estimatedLength == width {
        lines.append(line + " " + word)
        line = ""
      }

      # Wrap and try again
      else {
        lines.append(line)
        line = ""
        i--
      }
    }

    # Don't add an empty trailing line unless there are no other lines
    if line != "" || lines.isEmpty {
      lines.append(line)
    }

    return lines
  }
}

# JavaScript-specific library stuff

@skip if RELEASE
def assert(truth bool) {
  if !truth {
    throw dynamic.Error("Assertion failed")
  }
}

namespace StringMap {
  def new StringMap<T> {
    return dynamic.Object.create(null)
  }
}

class StringMap {
  def {...}(key string, value T) StringMap<T> {
    self[key] = value
    return self
  }

  def get(key string, value T) T {
    return key in self ? self[key] : value
  }

  def keys List<string> {
    return dynamic.Object.keys(self)
  }

  def values List<T> {
    var values List<T> = []
    for key in self as dynamic {
      values.append(self[key])
    }
    return values
  }

  def clone StringMap<T> {
    var clone = new
    for key in keys {
      clone[key] = self[key]
    }
    return clone
  }

  def remove(key string) {
    dynamic.delete(self[key])
  }
}

namespace IntMap {
  def new IntMap<T> {
    return dynamic.Object.create(null)
  }
}

class IntMap {
  def {...}(key int, value T) IntMap<T> {
    self[key] = value
    return self
  }

  def get(key int, value T) T {
    return key in self ? self[key] : value
  }

  def keys List<int> {
    var keys List<int> = []
    for key in dynamic.Object.keys(self) as List<string> {
      keys.append(key as dynamic as int)
    }
    return keys
  }

  def values List<T> {
    var values List<T> = []
    for key in self as dynamic {
      values.append(self[key])
    }
    return values
  }

  def clone IntMap<T> {
    var clone = new
    for key in keys {
      clone[key] = self[key]
    }
    return clone
  }

  def remove(key int) {
    dynamic.delete(self[key])
  }
}

class double {
  def isFinite bool {
    return dynamic.isFinite(self)
  }

  def isNAN bool {
    return dynamic.isNaN(self)
  }
}

class string {
  def startsWith(text string) bool {
    return count >= text.count && slice(0, text.count) == text
  }

  def replaceAll(before string, after string) string {
    return after.join(self.split(before))
  }

  def in(value string) bool {
    return indexOf(value) >= 0
  }

  def count int {
    return (self as dynamic).length
  }

  def [](index int) int {
    return (self as dynamic).charCodeAt(index)
  }

  def get(index int) string {
    return (self as dynamic)[index]
  }

  def repeat(times int) string {
    var result = ""
    for i in 0..times {
      result += self
    }
    return result
  }

  def join(parts List<string>) string {
    return (parts as dynamic).join(self)
  }
}

namespace string {
  def fromCodeUnit(x int) string {
    return dynamic.String.fromCharCode(x)
  }
}

class List {
  def isEqualTo(other List<T>) bool {
    if count != other.count {
      return false
    }
    for i in 0..count {
      if self[i] != other[i] {
        return false
      }
    }
    return true
  }

  def in(value T) bool {
    return indexOf(value) >= 0
  }

  def isEmpty bool {
    return count == 0
  }

  def count int {
    return (self as dynamic).length
  }

  def first T {
    return self[0]
  }

  def last T {
    return self[count - 1]
  }

  def prepend(value T) {
    (self as dynamic).unshift(value)
  }

  def prepend(values List<T>) {
    var count = values.count
    for i in 0..count {
      prepend(values[count - i - 1])
    }
  }

  def append(value T) {
    (self as dynamic).push(value)
  }

  def append(values List<T>) {
    for value in values {
      append(value)
    }
  }

  def removeFirst {
    (self as dynamic).shift()
  }

  def removeLast {
    (self as dynamic).pop()
  }

  def takeFirst T {
    return (self as dynamic).shift()
  }

  def takeLast T {
    return (self as dynamic).pop()
  }

  def swap(i int, j int) {
    var temp = self[i]
    self[i] = self[j]
    self[j] = temp
  }

  def insert(index int, value T) {
    (self as dynamic).splice(index, 0, value)
  }

  def removeAt(index int) {
    (self as dynamic).splice(index, 1)
  }

  def removeOne(value T) {
    var index = indexOf(value)
    if index >= 0 {
      removeAt(index)
    }
  }

  def clone List<T> {
    return (self as dynamic).slice()
  }

  def removeIf(callback fn(T) bool) {
    var index = 0

    # Remove elements in place
    for i in 0..count {
      if !callback(self[i]) {
        if index < i {
          self[index] = self[i]
        }
        index++
      }
    }

    # Shrink the array to the correct size
    while index < count {
      removeLast
    }
  }
}

class StringBuilder {
  var buffer string

  def append(x string) {
    buffer += x
  }

  def toString string {
    return buffer
  }
}

namespace StringBuilder {
  def new StringBuilder {
    return {"buffer": ""} as dynamic
  }
}
