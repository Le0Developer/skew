namespace skew {
  enum NodeKind {
    # Other
    ANNOTATION
    BLOCK
    CASE

    # Statements
    BREAK
    CONTINUE
    EXPRESSION
    FOR
    IF
    IMPLICIT_RETURN
    RETURN
    SWITCH
    VAR
    WHILE

    # Expressions
    ASSIGN_INDEX
    CALL
    CAST
    CONSTANT
    DOT
    DYNAMIC
    HOOK
    INDEX
    INITIALIZER_LIST
    INITIALIZER_MAP
    INITIALIZER_SET
    INTERPOLATE
    LAMBDA
    LAMBDA_TYPE
    NAME
    NULL
    PAIR
    PARAMETERIZE
    SUPER
    TYPE

    # Unary operators
    COMPLEMENT
    POSITIVE
    NEGATIVE
    NOT

    # Binary operators
    ADD
    BITWISE_AND
    BITWISE_OR
    BITWISE_XOR
    COMPARE
    DIVIDE
    EQUAL
    IN
    LOGICAL_AND
    LOGICAL_OR
    MULTIPLY
    NOT_EQUAL
    POWER
    REMAINDER
    SHIFT_LEFT
    SHIFT_RIGHT
    SUBTRACT

    # Binary comparison operators
    GREATER_THAN
    GREATER_THAN_OR_EQUAL
    LESS_THAN
    LESS_THAN_OR_EQUAL

    # Binary assigment operators
    ASSIGN
    ASSIGN_ADD
    ASSIGN_BITWISE_AND
    ASSIGN_BITWISE_OR
    ASSIGN_BITWISE_XOR
    ASSIGN_DIVIDE
    ASSIGN_MULTIPLY
    ASSIGN_POWER
    ASSIGN_REMAINDER
    ASSIGN_SHIFT_LEFT
    ASSIGN_SHIFT_RIGHT
    ASSIGN_SUBTRACT

    def isStatement bool {
      return self as int >= ASSIGN as int && self as int <= WHILE as int
    }

    def isExpression bool {
      return self as int >= ASSIGN_INDEX as int && self as int <= ASSIGN_SUBTRACT as int
    }

    def isInitializer bool {
      return self as int >= INITIALIZER_LIST as int && self as int <= INITIALIZER_SET as int
    }

    def isUnary bool {
      return self as int >= COMPLEMENT as int && self as int <= NOT as int
    }

    def isBinary bool {
      return self as int >= ADD as int && self as int <= ASSIGN_SUBTRACT as int
    }

    def isBinaryAssign bool {
      return self as int >= ASSIGN as int && self as int <= ASSIGN_SUBTRACT as int
    }

    def isBinaryComparison bool {
      return self as int >= GREATER_THAN as int && self as int <= LESS_THAN_OR_EQUAL as int
    }

    def isJump bool {
      return self == BREAK || self == CONTINUE || self == IMPLICIT_RETURN || self == RETURN
    }
  }

  # Nodes represent executable code (variable initializers and function bodies)
  class Node {
    var kind NodeKind
    var range Range = null
    var internalRange Range = null
    var symbol Symbol = null # For names, calls, and dots
    var parent Node = null
    var content Content = null
    var resolvedType Type = null
    var comments List<string> = null
    var children List<Node> = []

    # Change self node in place to become the provided node. The parent node is
    # not changed, so become() can be called within a nested method and does not
    # need to report the updated node reference to the caller since the reference
    # does not change.
    def become(node Node) {
      kind = node.kind
      range = node.range
      internalRange = node.internalRange
      symbol = node.symbol
      content = node.content
      resolvedType = node.resolvedType
      comments = node.comments
      removeChildren
      withChildren(node.removeChildren)
    }

    def withType(value Type) Node {
      resolvedType = value
      return self
    }

    def withSymbol(value Symbol) Node {
      symbol = value
      return self
    }

    def withContent(value Content) Node {
      content = value
      return self
    }

    def withRange(value Range) Node {
      range = value
      return self
    }

    def withInternalRange(value Range) Node {
      internalRange = value
      return self
    }

    def withChildren(nodes List<Node>) Node {
      assert(children.isEmpty)
      for node in nodes {
        updateParent(node, self)
      }
      children = nodes
      return self
    }

    def internalRangeOrRange Range {
      return internalRange != null ? internalRange : range
    }

    def indexInParent int {
      assert(parent != null)
      return parent.children.indexOf(self)
    }

    def insertChild(index int, node Node) {
      assert(index >= 0 && index <= children.count)
      updateParent(node, self)
      children.insert(index, node)
    }

    def appendChild(node Node) {
      insertChild(children.count, node)
    }

    def removeChildAtIndex(index int) Node {
      assert(index >= 0 && index < children.count)
      var child = children[index]
      updateParent(child, null)
      children.removeAt(index)
      return child
    }

    def remove Node {
      parent.removeChildAtIndex(indexInParent)
      return self
    }

    def removeChildren List<Node> {
      var result = children
      for child in children {
        updateParent(child, null)
      }
      children = []
      return result
    }

    def replaceChild(index int, node Node) Node {
      assert(index >= 0 && index < children.count)
      updateParent(node, self)
      var child = children[index]
      updateParent(child, null)
      children[index] = node
      return child
    }

    def replaceWithNull Node {
      parent.replaceChild(indexInParent, null)
      return self
    }

    def swapWith(node Node) {
      var parentA = parent
      var parentB = node.parent
      var indexA = indexInParent
      var indexB = node.indexInParent
      parentA.children[indexA] = node
      parentB.children[indexB] = self
      parent = parentB
      node.parent = parentA
    }
  }

  namespace Node {
    @private
    def updateParent(node Node, parent Node) {
      if node != null {
        assert((node.parent == null) != (parent == null))
        node.parent = parent
      }
    }
  }

  # Node-specific queries
  class Node {
    def isTrue bool {
      return kind == .CONSTANT && content.kind == .BOOL && content.asBool
    }

    def isFalse bool {
      return kind == .CONSTANT && content.kind == .BOOL && !content.asBool
    }

    def isType bool {
      return kind == .TYPE || kind == .LAMBDA_TYPE || (kind == .NAME || kind == .DOT || kind == .PARAMETERIZE) && symbol != null && symbol.kind.isType
    }

    def blockAlwaysEndsWithReturn bool {
      assert(kind == .BLOCK)
      if children.isEmpty {
        return false
      }

      for i in 0..children.count {
        var child = children[children.count - i - 1]
        switch (child.kind) {
          case .RETURN, .IMPLICIT_RETURN {
            return true
          }

          case .IF {
            var trueBlock = child.ifTrue
            var falseBlock = child.ifFalse
            if falseBlock != null && trueBlock.blockAlwaysEndsWithReturn && falseBlock.blockAlwaysEndsWithReturn {
              return true
            }
          }
        }
      }

      return false
    }
  }

  # Factory functions
  namespace Node {
    def createAnnotation(value Node, test Node) Node {
      assert(value.kind.isExpression)
      assert(test == null || test.kind.isExpression)
      return Node.new(.ANNOTATION).withChildren([value, test])
    }

    def createBlock(statements List<Node>) Node {
      return Node.new(.BLOCK).withChildren(statements)
    }

    def createCase(values List<Node>, block Node) Node {
      assert(block.kind == .BLOCK)
      values.prepend(block)
      return Node.new(.CASE).withChildren(values)
    }

    def createBreak Node {
      return Node.new(.BREAK)
    }

    def createContinue Node {
      return Node.new(.CONTINUE)
    }

    def createExpression(value Node) Node {
      assert(value.kind.isExpression)
      return Node.new(.EXPRESSION).withChildren([value])
    }

    def createFor(symbol VariableSymbol, value Node, block Node) Node {
      assert(value.kind.isExpression)
      assert(block.kind == .BLOCK)
      return Node.new(.FOR).withSymbol(symbol).withChildren([value, block])
    }

    def createIf(test Node, trueBlock Node, falseBlock Node) Node {
      assert(test.kind.isExpression)
      assert(trueBlock.kind == .BLOCK)
      assert(falseBlock == null || falseBlock.kind == .BLOCK)
      return Node.new(.IF).withChildren([test, trueBlock, falseBlock])
    }

    def createReturn(value Node) Node {
      assert(value == null || value.kind.isExpression)
      return Node.new(.RETURN).withChildren([value])
    }

    def createSwitch(value Node, cases List<Node>) Node {
      assert(value.kind.isExpression)
      cases.prepend(value)
      return Node.new(.SWITCH).withChildren(cases)
    }

    def createImplicitReturn(value Node) Node {
      assert(value.kind.isExpression)
      return Node.new(.IMPLICIT_RETURN).withChildren([value])
    }

    def createVar(symbol VariableSymbol) Node {
      return Node.new(.VAR).withSymbol(symbol)
    }

    def createWhile(test Node, block Node) Node {
      return Node.new(.WHILE).withChildren([test, block])
    }

    def createAssignIndex(target Node, arguments List<Node>, value Node) Node {
      assert(target.kind.isExpression)
      assert(value.kind.isExpression)
      arguments.prepend(target)
      arguments.append(value)
      return Node.new(.ASSIGN_INDEX).withChildren(arguments)
    }

    def createIndex(target Node, arguments List<Node>) Node {
      assert(target.kind.isExpression)
      arguments.prepend(target)
      return Node.new(.INDEX).withChildren(arguments)
    }

    def createCall(target Node, arguments List<Node>) Node {
      assert(target.kind.isExpression)
      arguments.prepend(target)
      return Node.new(.CALL).withChildren(arguments)
    }

    def createCast(value Node, type Node) Node {
      assert(value.kind.isExpression)
      assert(type.kind.isExpression)
      return Node.new(.CAST).withChildren([value, type])
    }

    def createBool(value bool) Node {
      return createConstant(BoolContent.new(value))
    }

    def createInt(value int) Node {
      return createConstant(IntContent.new(value))
    }

    def createDouble(value double) Node {
      return createConstant(DoubleContent.new(value))
    }

    def createString(value string) Node {
      return createConstant(StringContent.new(value))
    }

    def createConstant(value Content) Node {
      return Node.new(.CONSTANT).withContent(value)
    }

    def createDot(target Node, name string) Node {
      return Node.new(.DOT).withContent(StringContent.new(name)).withChildren([target])
    }

    def createHook(test Node, trueValue Node, falseValue Node) Node {
      assert(test.kind.isExpression)
      assert(trueValue.kind.isExpression)
      assert(falseValue.kind.isExpression)
      return Node.new(.HOOK).withChildren([test, trueValue, falseValue])
    }

    def createList(values List<Node>) Node {
      return Node.new(.INITIALIZER_LIST).withChildren(values)
    }

    def createInitializer(kind NodeKind, values List<Node>) Node {
      assert(kind.isInitializer)
      return Node.new(kind).withChildren(values)
    }

    def createInterpolate(left Node, right Node) Node {
      return Node.new(.INTERPOLATE).withChildren([left, right])
    }

    def createLambda(symbol FunctionSymbol) Node {
      return Node.new(.LAMBDA).withSymbol(symbol)
    }

    def createName(text string) Node {
      return Node.new(.NAME).withContent(StringContent.new(text))
    }

    def createDynamic Node {
      return Node.new(.DYNAMIC)
    }

    def createNull Node {
      return Node.new(.NULL)
    }

    def createPair(first Node, second Node) Node {
      assert(first.kind.isExpression)
      assert(second.kind.isExpression)
      return Node.new(.PAIR).withChildren([first, second])
    }

    def createParameterize(type Node, parameters List<Node>) Node {
      assert(type.kind.isExpression)
      parameters.prepend(type)
      return Node.new(.PARAMETERIZE).withChildren(parameters)
    }

    def createSuper Node {
      return Node.new(.SUPER)
    }

    def createType(type Type) Node {
      return Node.new(.TYPE).withType(type)
    }

    def createUnary(kind NodeKind, value Node) Node {
      assert(kind.isUnary)
      assert(value.kind.isExpression)
      return Node.new(kind).withChildren([value])
    }

    def createBinary(kind NodeKind, left Node, right Node) Node {
      assert(kind.isBinary)
      assert(left.kind.isExpression)
      assert(right.kind.isExpression)
      return Node.new(kind).withChildren([left, right])
    }

    def createLambdaType(argTypes List<Node>, returnType Node) Node {
      argTypes.append(returnType)
      return Node.new(.LAMBDA_TYPE).withChildren(argTypes)
    }
  }

  # Getters
  class Node {
    def asString string {
      assert(kind == .NAME || kind == .DOT)
      return content.asString
    }

    def firstValue Node {
      assert(kind == .PAIR)
      assert(children.count == 2)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def secondValue Node {
      assert(kind == .PAIR)
      assert(children.count == 2)
      assert(children[1].kind.isExpression)
      return children[1]
    }

    def dotTarget Node {
      assert(kind == .DOT)
      assert(children.count == 1)
      assert(children[0] == null || children[0].kind.isExpression)
      return children[0]
    }

    def annotationValue Node {
      assert(kind == .ANNOTATION)
      assert(children.count == 2)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def annotationTest Node {
      assert(kind == .ANNOTATION)
      assert(children.count == 2)
      assert(children[1] == null || children[1].kind.isExpression)
      return children[1]
    }

    def caseBlock Node {
      assert(kind == .CASE)
      assert(children.count >= 1)
      assert(children[0].kind == .BLOCK)
      return children[0]
    }

    def expressionValue Node {
      assert(kind == .EXPRESSION)
      assert(children.count == 1)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def returnValue Node {
      assert(kind == .RETURN || kind == .IMPLICIT_RETURN)
      assert(children.count == 1)
      assert(children[0] == null || children[0].kind.isExpression)
      return children[0]
    }

    def switchValue Node {
      assert(kind == .SWITCH)
      assert(children.count >= 1)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def parameterizeValue Node {
      assert(kind == .PARAMETERIZE)
      assert(children.count >= 1)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def callValue Node {
      assert(kind == .CALL)
      assert(children.count >= 1)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def indexValue Node {
      assert(kind == .INDEX)
      assert(children.count >= 1)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def castValue Node {
      assert(kind == .CAST)
      assert(children.count == 2)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def castType Node {
      assert(kind == .CAST)
      assert(children.count == 2)
      assert(children[1].kind.isExpression)
      return children[1]
    }

    def unaryValue Node {
      assert(kind.isUnary)
      assert(children.count == 1)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def binaryLeft Node {
      assert(kind.isBinary)
      assert(children.count == 2)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def binaryRight Node {
      assert(kind.isBinary)
      assert(children.count == 2)
      assert(children[1].kind.isExpression)
      return children[1]
    }

    def interpolateLeft Node {
      assert(kind == .INTERPOLATE)
      assert(children.count == 2)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def interpolateRight Node {
      assert(kind == .INTERPOLATE)
      assert(children.count == 2)
      assert(children[1].kind.isExpression)
      return children[1]
    }

    def whileTest Node {
      assert(kind == .WHILE)
      assert(children.count == 2)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def whileBlock Node {
      assert(kind == .WHILE)
      assert(children.count == 2)
      assert(children[1].kind == .BLOCK)
      return children[1]
    }

    def forValue Node {
      assert(kind == .FOR)
      assert(children.count == 2)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def forBlock Node {
      assert(kind == .FOR)
      assert(children.count == 2)
      assert(children[1].kind == .BLOCK)
      return children[1]
    }

    def ifTest Node {
      assert(kind == .IF)
      assert(children.count == 3)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def ifTrue Node {
      assert(kind == .IF)
      assert(children.count == 3)
      assert(children[1].kind == .BLOCK)
      return children[1]
    }

    def ifFalse Node {
      assert(kind == .IF)
      assert(children.count == 3)
      assert(children[2] == null || children[2].kind == .BLOCK)
      return children[2]
    }

    def hookTest Node {
      assert(kind == .HOOK)
      assert(children.count == 3)
      assert(children[0].kind.isExpression)
      return children[0]
    }

    def hookTrue Node {
      assert(kind == .HOOK)
      assert(children.count == 3)
      assert(children[1].kind.isExpression)
      return children[1]
    }

    def hookFalse Node {
      assert(kind == .HOOK)
      assert(children.count == 3)
      assert(children[2].kind.isExpression)
      return children[2]
    }
  }
}
