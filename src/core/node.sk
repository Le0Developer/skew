namespace skew {
  enum NodeKind {
    // Other
    BLOCK

    // Statements
    BREAK
    CONTINUE
    EXPRESSION
    IF
    IMPLICIT_RETURN
    RETURN
    VAR
    WHILE

    // Expressions
    ASSIGN_INDEX
    CALL // If node has symbol then symbol.arguments matches node.children, otherwise node.children.first is the function and other children are arguments
    CAST
    CONSTANT
    DOT
    DYNAMIC
    HOOK
    INDEX
    LAMBDA
    LAMBDA_TYPE
    NAME
    NULL
    PARAMETERIZE
    TYPE

    // Unary operators
    COMPLEMENT
    POSITIVE
    NEGATIVE
    NOT

    // Binary operators
    ADD
    BITWISE_AND
    BITWISE_OR
    BITWISE_XOR
    DIVIDE
    EQUAL
    GREATER_THAN
    GREATER_THAN_OR_EQUAL
    IN
    LESS_THAN
    LESS_THAN_OR_EQUAL
    LOGICAL_AND
    LOGICAL_OR
    MULTIPLY
    NOT_EQUAL
    POWER
    REMAINDER
    SHIFT_LEFT
    SHIFT_RIGHT
    SUBTRACT

    // Binary assigment operators
    ASSIGN
    ASSIGN_ADD
    ASSIGN_BITWISE_AND
    ASSIGN_BITWISE_OR
    ASSIGN_BITWISE_XOR
    ASSIGN_DIVIDE
    ASSIGN_MULTIPLY
    ASSIGN_POWER
    ASSIGN_REMAINDER
    ASSIGN_SHIFT_LEFT
    ASSIGN_SHIFT_RIGHT
    ASSIGN_SUBTRACT
  }

  in NodeKind {
    bool isStatement() {
      return this >= ASSIGN && this <= WHILE
    }

    bool isExpression() {
      return this >= ASSIGN_INDEX && this <= ASSIGN_SUBTRACT
    }

    bool isUnary() {
      return this >= COMPLEMENT && this <= NOT
    }

    bool isBinary() {
      return this >= ADD && this <= ASSIGN_SUBTRACT
    }

    bool isBinaryAssign() {
      return this >= ASSIGN && this <= ASSIGN_SUBTRACT
    }
  }

  // Nodes represent executable code (variable initializers and function bodies)
  class Node {
    NodeKind kind
    Range range = null
    Range internalRange = null
    Symbol symbol = null // For names, calls, and dots
    Node parent = null
    Content content = null
    Type resolvedType = null
    List<string> comments = null
    List<Node> children = []

    // Change this node in place to become the provided node. The parent node is
    // not changed, so become() can be called within a nested method and does not
    // need to report the updated node reference to the caller since the reference
    // does not change.
    void become(Node node) {
      kind = node.kind
      range = node.range
      internalRange = node.internalRange
      symbol = node.symbol
      content = node.content
      resolvedType = node.resolvedType
      comments = node.comments
      removeChildren()
      withChildren(node.removeChildren())
    }

    Node withType(Type value) {
      resolvedType = value
      return this
    }

    Node withSymbol(Symbol value) {
      symbol = value
      return this
    }

    Node withContent(Content value) {
      content = value
      return this
    }

    Node withRange(Range value) {
      range = value
      return this
    }

    Node withInternalRange(Range value) {
      internalRange = value
      return this
    }

    Node withChildren(List<Node> nodes) {
      assert children.size() == 0
      for (var i = 0; i < nodes.size(); i++) {
        updateParent(nodes[i], this)
      }
      children = nodes
      return this
    }

    int indexInParent() {
      assert parent != null
      return parent.children.indexOf(this)
    }

    void insertChild(int index, Node node) {
      assert index >= 0 && index <= children.size()
      updateParent(node, this)
      children.insert(index, node)
    }

    void appendChild(Node node) {
      insertChild(children.size(), node)
    }

    Node removeChildAtIndex(int index) {
      assert index >= 0 && index < children.size()
      var child = children[index]
      updateParent(child, null)
      children.removeAt(index)
      return child
    }

    Node remove() {
      parent.removeChildAtIndex(indexInParent())
      return this
    }

    List<Node> removeChildren() {
      var result = children
      for (var i = 0; i < children.size(); i++) {
        updateParent(children[i], null)
      }
      children = []
      return result
    }

    Node replaceChild(int index, Node node) {
      assert index >= 0 && index < children.size()
      updateParent(node, this)
      var child = children[index]
      updateParent(child, null)
      children[index] = node
      return child
    }

    Node replaceWithNull() {
      parent.replaceChild(indexInParent(), null)
      return this
    }

    private static void updateParent(Node node, Node parent) {
      if (node != null) {
        assert (node.parent == null) != (parent == null)
        node.parent = parent
      }
    }
  }

  // Node-specific queries
  in Node {
    bool isTrue() {
      return kind == .CONSTANT && content.kind() == .BOOL && content.asBool()
    }

    bool isFalse() {
      return kind == .CONSTANT && content.kind() == .BOOL && !content.asBool()
    }

    bool isType() {
      return kind == .TYPE || kind == .LAMBDA_TYPE || (kind == .NAME || kind == .DOT || kind == .PARAMETERIZE) && symbol != null && (symbol.kind.isObject() || symbol.kind == .PARAMETER)
    }

    bool blockAlwaysEndsWithReturn() {
      assert kind == .BLOCK
      if (children.size() == 0) {
        return false
      }

      for (var i = children.size() - 1; i >= 0; i--) {
        var child = children[i]
        switch (child.kind) {
          case .RETURN, .IMPLICIT_RETURN {
            return true
          }

          case .IF {
            var trueBlock = child.ifTrue()
            var falseBlock = child.ifFalse()
            if (falseBlock != null && trueBlock.blockAlwaysEndsWithReturn() && falseBlock.blockAlwaysEndsWithReturn()) {
              return true
            }
          }
        }
      }

      return false
    }
  }

  // Factory functions
  in Node {
    static Node createBlock(List<Node> statements) {
      return Node(.BLOCK).withChildren(statements)
    }

    static Node createBreak() {
      return Node(.BREAK)
    }

    static Node createContinue() {
      return Node(.CONTINUE)
    }

    static Node createExpression(Node value) {
      assert value.kind.isExpression()
      return Node(.EXPRESSION).withChildren([value])
    }

    static Node createIf(Node test, Node trueBlock, Node falseBlock) {
      assert test.kind.isExpression()
      assert trueBlock.kind == .BLOCK
      assert falseBlock == null || falseBlock.kind == .BLOCK
      return Node(.IF).withChildren([test, trueBlock, falseBlock])
    }

    static Node createReturn(Node value) {
      assert value == null || value.kind.isExpression()
      return Node(.RETURN).withChildren([value])
    }

    static Node createImplicitReturn(Node value) {
      assert value.kind.isExpression()
      return Node(.IMPLICIT_RETURN).withChildren([value])
    }

    static Node createVar(VariableSymbol symbol) {
      return Node(.VAR).withSymbol(symbol)
    }

    static Node createWhile(Node test, Node block) {
      return Node(.WHILE).withChildren([test, block])
    }

    static Node createAssignIndex(Node target, List<Node> arguments, Node value) {
      assert target.kind.isExpression()
      assert value.kind.isExpression()
      arguments.unshift(target)
      arguments.push(value)
      return Node(.ASSIGN_INDEX).withChildren(arguments)
    }

    static Node createIndex(Node target, List<Node> arguments) {
      assert target.kind.isExpression()
      arguments.unshift(target)
      return Node(.INDEX).withChildren(arguments)
    }

    static Node createCall(Node target, List<Node> arguments) {
      assert target.kind.isExpression()
      arguments.unshift(target)
      return Node(.CALL).withChildren(arguments)
    }

    static Node createCast(Node value, Node type) {
      assert value.kind.isExpression()
      assert type.kind.isExpression()
      return Node(.CAST).withChildren([value, type])
    }

    static Node createBool(bool value) {
      return createConstant(BoolContent(value))
    }

    static Node createInt(int value) {
      return createConstant(IntContent(value))
    }

    static Node createDouble(double value) {
      return createConstant(DoubleContent(value))
    }

    static Node createString(string value) {
      return createConstant(StringContent(value))
    }

    static Node createConstant(Content value) {
      return Node(.CONSTANT).withContent(value)
    }

    static Node createDot(Node target, string name) {
      return Node(.DOT).withContent(StringContent(name)).withChildren([target])
    }

    static Node createHook(Node test, Node trueValue, Node falseValue) {
      assert test.kind.isExpression()
      assert trueValue.kind.isExpression()
      assert falseValue.kind.isExpression()
      return Node(.HOOK).withChildren([test, trueValue, falseValue])
    }

    static Node createLambda(FunctionSymbol symbol) {
      return Node(.LAMBDA).withSymbol(symbol)
    }

    static Node createName(string text) {
      return Node(.NAME).withContent(StringContent(text))
    }

    static Node createDynamic() {
      return Node(.DYNAMIC)
    }

    static Node createNull() {
      return Node(.NULL)
    }

    static Node createParameterize(Node type, List<Node> parameters) {
      assert type.kind.isExpression()
      parameters.unshift(type)
      return Node(.PARAMETERIZE).withChildren(parameters)
    }

    static Node createType(Type type) {
      return Node(.TYPE).withType(type)
    }

    static Node createUnary(NodeKind kind, Node value) {
      assert kind.isUnary()
      assert value.kind.isExpression()
      return Node(kind).withChildren([value])
    }

    static Node createBinary(NodeKind kind, Node left, Node right) {
      assert kind.isBinary()
      assert left.kind.isExpression()
      assert right.kind.isExpression()
      return Node(kind).withChildren([left, right])
    }

    static Node createLambdaType(List<Node> argTypes, Node returnType) {
      argTypes.push(returnType)
      return Node(.LAMBDA_TYPE).withChildren(argTypes)
    }
  }

  // Getters
  in Node {
    string asString() {
      assert kind == .NAME || kind == .DOT
      return content.asString()
    }

    Node dotTarget() {
      assert kind == .DOT
      assert children.size() == 1
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node expressionValue() {
      assert kind == .EXPRESSION
      assert children.size() == 1
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node returnValue() {
      assert kind == .RETURN || kind == .IMPLICIT_RETURN
      assert children.size() == 1
      assert children[0] == null || children[0].kind.isExpression()
      return children[0]
    }

    Node parameterizeValue() {
      assert kind == .PARAMETERIZE
      assert children.size() >= 1
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node callValue() {
      assert kind == .CALL
      assert children.size() >= 1
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node indexValue() {
      assert kind == .INDEX
      assert children.size() >= 1
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node castValue() {
      assert kind == .CAST
      assert children.size() == 2
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node castType() {
      assert kind == .CAST
      assert children.size() == 2
      assert children[1].kind.isExpression()
      return children[1]
    }

    Node unaryValue() {
      assert kind.isUnary()
      assert children.size() == 1
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node binaryLeft() {
      assert kind.isBinary()
      assert children.size() == 2
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node binaryRight() {
      assert kind.isBinary()
      assert children.size() == 2
      assert children[1].kind.isExpression()
      return children[1]
    }

    Node whileTest() {
      assert kind == .WHILE
      assert children.size() == 2
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node whileBlock() {
      assert kind == .WHILE
      assert children.size() == 2
      assert children[1].kind == .BLOCK
      return children[1]
    }

    Node ifTest() {
      assert kind == .IF
      assert children.size() == 3
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node ifTrue() {
      assert kind == .IF
      assert children.size() == 3
      assert children[1].kind == .BLOCK
      return children[1]
    }

    Node ifFalse() {
      assert kind == .IF
      assert children.size() == 3
      assert children[2] == null || children[2].kind == .BLOCK
      return children[2]
    }

    Node hookTest() {
      assert kind == .HOOK
      assert children.size() == 3
      assert children[0].kind.isExpression()
      return children[0]
    }

    Node hookTrue() {
      assert kind == .HOOK
      assert children.size() == 3
      assert children[1].kind.isExpression()
      return children[1]
    }

    Node hookFalse() {
      assert kind == .HOOK
      assert children.size() == 3
      assert children[2].kind.isExpression()
      return children[2]
    }
  }
}
