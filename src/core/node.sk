namespace Skew {
  enum NodeKind {
    # Other
    ANNOTATION
    BLOCK
    CASE
    CATCH
    VARIABLE

    # Statements
    BREAK
    CONTINUE
    EXPRESSION
    FOR
    FOREACH
    IF
    RETURN
    SWITCH
    THROW
    TRY
    VARIABLES
    WHILE

    # Expressions
    ASSIGN_INDEX
    CALL
    CAST
    CONSTANT
    DOT
    HOOK
    INDEX
    INITIALIZER_LIST
    INITIALIZER_MAP
    LAMBDA
    LAMBDA_TYPE
    NAME
    NULL
    NULL_DOT
    PAIR
    PARAMETERIZE
    SEQUENCE
    SUPER
    TYPE
    TYPE_CHECK

    # Unary operators
    COMPLEMENT
    NEGATIVE
    NOT
    POSITIVE
    POSTFIX_DECREMENT
    POSTFIX_INCREMENT
    PREFIX_DECREMENT
    PREFIX_INCREMENT

    # Binary operators
    ADD
    BITWISE_AND
    BITWISE_OR
    BITWISE_XOR
    COMPARE
    DIVIDE
    EQUAL
    IN
    LOGICAL_AND
    LOGICAL_OR
    MULTIPLY
    NOT_EQUAL
    NULL_JOIN
    POWER
    REMAINDER
    SHIFT_LEFT
    SHIFT_RIGHT
    SUBTRACT
    UNSIGNED_SHIFT_RIGHT

    # Binary comparison operators
    GREATER_THAN
    GREATER_THAN_OR_EQUAL
    LESS_THAN
    LESS_THAN_OR_EQUAL

    # Binary assigment operators
    ASSIGN
    ASSIGN_ADD
    ASSIGN_BITWISE_AND
    ASSIGN_BITWISE_OR
    ASSIGN_BITWISE_XOR
    ASSIGN_DIVIDE
    ASSIGN_MULTIPLY
    ASSIGN_NULL
    ASSIGN_POWER
    ASSIGN_REMAINDER
    ASSIGN_SHIFT_LEFT
    ASSIGN_SHIFT_RIGHT
    ASSIGN_SUBTRACT
    ASSIGN_UNSIGNED_SHIFT_RIGHT

    def isStatement bool {
      return self >= ASSIGN && self <= WHILE
    }

    def isLoop bool {
      return self == FOR || self == FOREACH || self == WHILE
    }

    def isExpression bool {
      return self >= ASSIGN_INDEX && self <= ASSIGN_UNSIGNED_SHIFT_RIGHT
    }

    def isInitializer bool {
      return self == INITIALIZER_LIST || self == INITIALIZER_MAP
    }

    def isUnary bool {
      return self >= COMPLEMENT && self <= PREFIX_INCREMENT
    }

    def isUnaryAssign bool {
      return self >= POSTFIX_DECREMENT && self <= PREFIX_INCREMENT
    }

    def isUnaryPostfix bool {
      return self == POSTFIX_DECREMENT || self == POSTFIX_INCREMENT
    }

    def isBinary bool {
      return self >= ADD && self <= ASSIGN_UNSIGNED_SHIFT_RIGHT
    }

    def isBinaryAssign bool {
      return self >= ASSIGN && self <= ASSIGN_UNSIGNED_SHIFT_RIGHT
    }

    # Note that add and multiply are NOT associative in finite-precision arithmetic
    def isBinaryAssociative bool {
      switch self {
        case BITWISE_AND, BITWISE_OR, BITWISE_XOR, LOGICAL_AND, LOGICAL_OR {
          return true
        }
      }
      return false
    }

    def isBinaryComparison bool {
      return self >= GREATER_THAN && self <= LESS_THAN_OR_EQUAL
    }

    def isJump bool {
      return self == BREAK || self == CONTINUE || self == RETURN
    }

    def isAssign bool {
      return isUnaryAssign || isBinaryAssign || self == ASSIGN_INDEX
    }
  }

  # Flags
  namespace Node {
    # An implicit return is a return statement inside an expression lambda. For
    # example, the lambda "x => x" is compiled into "x => { return x }" where
    # the return statement has this flag set.
    const IS_IMPLICIT_RETURN = 1 << 0

    # This flag marks nodes that were wrapped in parentheses in the original
    # source code. It's used for warnings about C-style syntax in conditional
    # statements and to call a lambda returned from a getter.
    const IS_INSIDE_PARENTHESES = 1 << 1

    # This flag is only for blocks. A simple control flow analysis is run
    # during code resolution and blocks where control flow reaches the end of
    # the block have this flag set.
    const HAS_CONTROL_FLOW_AT_END = 1 << 2

    # This flag marks nodes that were converted from NULL_JOIN to HOOK nodes.
    const WAS_NULL_JOIN = 1 << 3

    # This flag marks nodes that were converted from ASSIGN_NULL to ASSIGN nodes.
    const WAS_ASSIGN_NULL = 1 << 4
  }

  # Nodes represent executable code (variable initializers and function bodies)
  class Node {
    const id = _createID
    var kind NodeKind
    var flags = 0
    var range Range = null
    var internalRange Range = null
    var symbol Symbol = null
    var content Content = null
    var resolvedType Type = null
    var comments List<string> = null
    var _parent Node = null
    var _firstChild Node = null
    var _lastChild Node = null
    var _previousSibling Node = null
    var _nextSibling Node = null

    def _cloneWithoutChildren Node {
      var clone = new(kind)
      clone.flags = flags
      clone.range = range
      clone.internalRange = internalRange
      clone.symbol = symbol
      clone.content = content
      clone.resolvedType = resolvedType
      clone.comments = comments?.clone
      return clone
    }

    # When used with become(), this provides a convenient way to wrap a node in
    # an operation without the caller needing to be aware of replaceWith():
    #
    #  node.become(Node.createUnary(.NOT, node.cloneAndStealChildren))
    #
    def cloneAndStealChildren Node {
      var clone = _cloneWithoutChildren
      while hasChildren {
        clone.appendChild(_firstChild.remove)
      }
      return clone
    }

    def clone Node {
      var clone = _cloneWithoutChildren
      if kind == .LAMBDA {
        clone.symbol = symbol.asFunctionSymbol.clone
        clone.appendChild(clone.symbol.asFunctionSymbol.block)
      } else if kind == .VARIABLE {
        clone.symbol = symbol.asVariableSymbol.clone
        clone.appendChild(clone.symbol.asVariableSymbol.value)
      } else {
        for child = _firstChild; child != null; child = child._nextSibling {
          clone.appendChild(child.clone)
        }
      }
      return clone
    }

    # Change self node in place to become the provided node. The parent node is
    # not changed, so become() can be called within a nested method and does not
    # need to report the updated node reference to the caller since the reference
    # does not change.
    def become(node Node) {
      if node == self {
        return
      }
      assert(node._parent == null)
      kind = node.kind
      flags = node.flags
      range = node.range
      internalRange = node.internalRange
      symbol = node.symbol
      content = node.content
      resolvedType = node.resolvedType
      comments = node.comments
      removeChildren
      appendChildrenFrom(node)
    }

    def parent Node {
      return _parent
    }

    def firstChild Node {
      return _firstChild
    }

    def lastChild Node {
      return _lastChild
    }

    def previousSibling Node {
      return _previousSibling
    }

    def nextSibling Node {
      return _nextSibling
    }

    def isImplicitReturn bool {
      return (flags & IS_IMPLICIT_RETURN) != 0
    }

    def isInsideParentheses bool {
      return (flags & IS_INSIDE_PARENTHESES) != 0
    }

    def hasControlFlowAtEnd bool {
      return (flags & HAS_CONTROL_FLOW_AT_END) != 0
    }

    def wasNullJoin bool {
      return (flags & WAS_NULL_JOIN) != 0
    }

    def wasAssignNull bool {
      return (flags & WAS_ASSIGN_NULL) != 0
    }

    # This is cheaper than childCount == 0
    def hasChildren bool {
      return _firstChild != null
    }

    # This is cheaper than childCount == 1
    def hasOneChild bool {
      return hasChildren && _firstChild == _lastChild
    }

    # This is cheaper than childCount == 2
    def hasTwoChildren bool {
      return hasChildren && _firstChild.nextSibling == _lastChild
    }

    # This is cheaper than childCount == 3
    def hasThreeChildren bool {
      return hasChildren && _firstChild.nextSibling == _lastChild.previousSibling
    }

    # This is cheaper than childCount == 4
    def hasFourChildren bool {
      return hasChildren && _firstChild.nextSibling != null && _firstChild.nextSibling.nextSibling == _lastChild.previousSibling
    }

    def childCount int {
      var count = 0
      for child = _firstChild; child != null; child = child._nextSibling {
        count++
      }
      return count
    }

    def withFlags(value int) Node {
      flags = value
      return self
    }

    def withType(value Type) Node {
      resolvedType = value
      return self
    }

    def withSymbol(value Symbol) Node {
      symbol = value
      return self
    }

    def withContent(value Content) Node {
      content = value
      return self
    }

    def withRange(value Range) Node {
      range = value
      return self
    }

    def withInternalRange(value Range) Node {
      internalRange = value
      return self
    }

    def withComments(value List<string>) Node {
      assert(comments == null)
      comments = value
      return self
    }

    def internalRangeOrRange Range {
      return internalRange ?? range
    }

    def prependChild(node Node) Node {
      if node == null {
        return self
      }

      assert(node != self)
      assert(node._parent == null)
      assert(node._previousSibling == null)
      assert(node._nextSibling == null)
      node._parent = self

      if hasChildren {
        node._nextSibling = _firstChild
        _firstChild._previousSibling = node
        _firstChild = node
      } else {
        _lastChild = _firstChild = node
      }

      return self
    }

    def appendChild(node Node) Node {
      if node == null {
        return self
      }

      assert(node != self)
      assert(node._parent == null)
      assert(node._previousSibling == null)
      assert(node._nextSibling == null)
      node._parent = self

      if hasChildren {
        node._previousSibling = _lastChild
        _lastChild._nextSibling = node
        _lastChild = node
      } else {
        _lastChild = _firstChild = node
      }

      return self
    }

    def appendChildrenFrom(node Node) Node {
      assert(node != self)
      while node.hasChildren {
        appendChild(node._firstChild.remove)
      }
      return self
    }

    def insertChildBefore(after Node, before Node) Node {
      if before == null {
        return self
      }

      assert(before != after)
      assert(before._parent == null)
      assert(before._previousSibling == null)
      assert(before._nextSibling == null)
      assert(after == null || after._parent == self)

      if after == null {
        return appendChild(before)
      }

      before._parent = self
      before._previousSibling = after._previousSibling
      before._nextSibling = after

      if after._previousSibling != null {
        assert(after == after._previousSibling._nextSibling)
        after._previousSibling._nextSibling = before
      } else {
        assert(after == _firstChild)
        _firstChild = before
      }

      after._previousSibling = before
      return self
    }

    def insertChildAfter(before Node, after Node) Node {
      if after == null {
        return self
      }

      assert(before != after)
      assert(after._parent == null)
      assert(after._previousSibling == null)
      assert(after._nextSibling == null)
      assert(before == null || before._parent == self)

      if before == null {
        return prependChild(after)
      }

      after._parent = self
      after._previousSibling = before
      after._nextSibling = before._nextSibling

      if before._nextSibling != null {
        assert(before == before._nextSibling._previousSibling)
        before._nextSibling._previousSibling = after
      } else {
        assert(before == _lastChild)
        _lastChild = after
      }

      before._nextSibling = after
      return self
    }

    def insertChildrenAfterFrom(from Node, after Node) {
      while from.hasChildren {
        insertChildAfter(after, from.lastChild.remove)
      }
    }

    def remove Node {
      assert(_parent != null)

      if _previousSibling != null {
        assert(_previousSibling._nextSibling == self)
        _previousSibling._nextSibling = _nextSibling
      } else {
        assert(_parent._firstChild == self)
        _parent._firstChild = _nextSibling
      }

      if _nextSibling != null {
        assert(_nextSibling._previousSibling == self)
        _nextSibling._previousSibling = _previousSibling
      } else {
        assert(_parent._lastChild == self)
        _parent._lastChild = _previousSibling
      }

      _parent = null
      _previousSibling = null
      _nextSibling = null
      return self
    }

    def removeChildren {
      while hasChildren {
        _firstChild.remove
      }
    }

    def replaceWith(node Node) Node {
      assert(node != self)
      assert(_parent != null)
      assert(node._parent == null)
      assert(node._previousSibling == null)
      assert(node._nextSibling == null)

      node._parent = _parent
      node._previousSibling = _previousSibling
      node._nextSibling = _nextSibling

      if _previousSibling != null {
        assert(_previousSibling._nextSibling == self)
        _previousSibling._nextSibling = node
      } else {
        assert(_parent._firstChild == self)
        _parent._firstChild = node
      }

      if _nextSibling != null {
        assert(_nextSibling._previousSibling == self)
        _nextSibling._previousSibling = node
      } else {
        assert(_parent._lastChild == self)
        _parent._lastChild = node
      }

      _parent = null
      _previousSibling = null
      _nextSibling = null
      return self
    }

    def replaceWithChildrenFrom(node Node) Node {
      assert(node != self)
      var parent = _parent
      while node.hasChildren {
        parent.insertChildBefore(self, node._firstChild.remove)
      }
      return remove
    }

    def swapWith(node Node) {
      assert(node != self)
      assert(_parent != null && _parent == node._parent)

      var parent = _parent
      var nextSibling = _nextSibling

      if node == _previousSibling {
        parent.insertChildBefore(node, remove)
      } else if node == nextSibling {
        parent.insertChildAfter(node, remove)
      } else {
        parent.insertChildBefore(node, remove)
        parent.insertChildBefore(nextSibling, node.remove)
      }
    }
  }

  namespace Node {
    def _createID int {
      return ++_nextID
    }

    var _nextID = 0

    def _symbolsOrStringsLookTheSame(left Node, right Node) bool {
      return
        left.symbol != null && left.symbol == right.symbol ||
        left.symbol == null && right.symbol == null && left.asString == right.asString
    }

    def _childrenLookTheSame(left Node, right Node) bool {
      var leftChild = left.firstChild
      var rightChild = right.firstChild

      while leftChild != null && rightChild != null {
        if !_looksTheSame(leftChild, rightChild) {
          return false
        }

        leftChild = leftChild.nextSibling
        rightChild = rightChild.nextSibling
      }

      return leftChild == null && rightChild == null
    }

    def _looksTheSame(left Node, right Node) bool {
      if left.kind == right.kind {
        switch left.kind {
          case .NULL { return true }
          case .NAME { return _symbolsOrStringsLookTheSame(left, right) }
          case .DOT { return _symbolsOrStringsLookTheSame(left, right) && _looksTheSame(left.dotTarget, right.dotTarget) }

          case .CONSTANT {
            switch left.content.kind {
              case .INT { return right.isInt && left.asInt == right.asInt }
              case .BOOL { return right.isBool && left.asBool == right.asBool }
              case .DOUBLE { return right.isDouble && left.asDouble == right.asDouble }
              case .STRING { return right.isString && left.asString == right.asString }
            }
          }

          case
            .BLOCK, .BREAK, .CONTINUE, .EXPRESSION, .IF, .RETURN, .THROW, .WHILE,
            .ASSIGN_INDEX, .CALL, .HOOK, .INDEX, .INITIALIZER_LIST, .INITIALIZER_MAP, .PAIR, .SEQUENCE,
            .COMPLEMENT, .NEGATIVE, .NOT, .POSITIVE, .POSTFIX_DECREMENT, .POSTFIX_INCREMENT, .PREFIX_DECREMENT, .PREFIX_INCREMENT {
            return _childrenLookTheSame(left, right)
          }

          default {
            if left.kind.isBinary { return _childrenLookTheSame(left, right) }
          }
        }
      }

      # Null literals are always implicitly casted, so unwrap implicit casts
      if left.kind == .CAST { return _looksTheSame(left.castValue, right) }
      if right.kind == .CAST { return _looksTheSame(left, right.castValue) }
      return false
    }
  }

  # Node-specific queries
  class Node {
    def isSuperCallStatement bool {
      return kind == .EXPRESSION && (expressionValue.kind == .SUPER || expressionValue.kind == .CALL && expressionValue.callValue.kind == .SUPER)
    }

    def isEmptySequence bool {
      return kind == .SEQUENCE && !hasChildren
    }

    def isTrue bool {
      return kind == .CONSTANT && content.kind == .BOOL && content.asBool
    }

    def isFalse bool {
      return kind == .CONSTANT && content.kind == .BOOL && !content.asBool
    }

    def isType bool {
      return kind == .TYPE || kind == .LAMBDA_TYPE || (kind == .NAME || kind == .DOT || kind == .PARAMETERIZE) && symbol != null && symbol.kind.isType
    }

    def isAssignTarget bool {
      return _parent != null && (_parent.kind.isUnaryAssign || _parent.kind.isBinaryAssign && self == _parent.binaryLeft)
    }

    def isNumberLessThanZero bool {
      return isInt && asInt < 0 || isDouble && asDouble < 0
    }

    def hasNoSideEffects bool {
      assert(kind.isExpression)
      switch kind {
        case .CONSTANT, .NAME, .NULL, .TYPE { return true }
        case .CAST { return castValue.hasNoSideEffects }
        case .HOOK { return hookTest.hasNoSideEffects && hookTrue.hasNoSideEffects && hookFalse.hasNoSideEffects }
        case .DOT { return dotTarget.hasNoSideEffects }
        case .COMPLEMENT, .NEGATIVE, .NOT, .POSITIVE, .POSTFIX_DECREMENT, .POSTFIX_INCREMENT, .PREFIX_DECREMENT, .PREFIX_INCREMENT {
          return !kind.isUnaryAssign && unaryValue.hasNoSideEffects
        }
        default {
          if kind.isBinary { return !kind.isBinaryAssign && binaryLeft.hasNoSideEffects && binaryRight.hasNoSideEffects }
        }
      }
      return false
    }

    def looksTheSameAs(node Node) bool {
      return _looksTheSame(self, node)
    }

    def invertBooleanCondition(cache TypeCache) {
      assert(kind.isExpression)
      switch kind {
        case .CONSTANT {
          if content.kind == .BOOL {
            content = BoolContent.new(!content.asBool)
          }
          return
        }

        case .NOT {
          become(unaryValue.remove)
          return
        }

        case .EQUAL {
          kind = .NOT_EQUAL
          return
        }

        case .NOT_EQUAL {
          kind = .EQUAL
          return
        }

        case .LOGICAL_OR {
          kind = .LOGICAL_AND
          binaryLeft.invertBooleanCondition(cache)
          binaryRight.invertBooleanCondition(cache)
          return
        }

        case .LOGICAL_AND {
          kind = .LOGICAL_OR
          binaryLeft.invertBooleanCondition(cache)
          binaryRight.invertBooleanCondition(cache)
          return
        }

        # Non-equality comparison operators involving floating-point numbers
        # can't be inverted because one or both of those values may be NAN.
        # Equality comparisons still work fine because inverting the test
        # inverts the result as expected:
        #
        #   Test        |  Result
        # --------------+----------
        #   0 == NAN    |  false
        #   0 != NAN    |  true
        #   0 < NAN     |  false
        #   0 > NAN     |  false
        #   0 <= NAN    |  false
        #   0 >= NAN    |  false
        #   NAN == NAN  |  false
        #   NAN != NAN  |  true
        #   NAN < NAN   |  false
        #   NAN > NAN   |  false
        #   NAN <= NAN  |  false
        #   NAN >= NAN  |  false
        #
        case .LESS_THAN, .GREATER_THAN, .LESS_THAN_OR_EQUAL, .GREATER_THAN_OR_EQUAL {
          var commonType = cache.commonImplicitType(binaryLeft.resolvedType, binaryRight.resolvedType)
          if commonType != null && commonType != cache.doubleType {
            switch kind {
              case .LESS_THAN { kind = .GREATER_THAN_OR_EQUAL }
              case .GREATER_THAN { kind = .LESS_THAN_OR_EQUAL }
              case .LESS_THAN_OR_EQUAL { kind = .GREATER_THAN }
              case .GREATER_THAN_OR_EQUAL { kind = .LESS_THAN }
            }
            return
          }
        }

        case .SEQUENCE {
          _lastChild.invertBooleanCondition(cache)
          return
        }
      }

      become(createUnary(.NOT, cloneAndStealChildren).withType(cache.boolType))
    }

    def replaceVariableWith(node Node) Node {
      assert(kind == .VARIABLE)
      assert(parent != null)
      assert(parent.kind == .VARIABLES)

      # "var x = 0" becomes "node"
      if _previousSibling == null && _nextSibling == null {
        parent.replaceWith(node)
      }

      # "var x = 0, y = 0" becomes "node; var y = 0"
      else if _previousSibling == null {
        parent._parent.insertChildBefore(parent, node)
      }

      # "var x = 0, y = 0" becomes "var x = 0; node"
      else if _nextSibling == null {
        parent._parent.insertChildAfter(parent, node)
      }

      # "var x = 0, y = 0, z = 0" becomes "var x = 0; node; var z = 0"
      else {
        var variables = Node.createVariables
        parent._parent.insertChildAfter(parent, node)
        parent._parent.insertChildAfter(node, variables)
        while _nextSibling != null {
          variables.appendChild(_nextSibling.remove)
        }
      }

      return remove
    }

    # "a + (b + c)" => "(a + b) + c"
    def rotateBinaryRightToLeft {
      assert(kind == binaryRight.kind)

      var left = binaryLeft
      var right = binaryRight
      var rightLeft = right.binaryLeft
      var rightRight = right.binaryRight

      # "a + (b + c)" => "(b + c) + a"
      left.swapWith(right)

      # "a + (b + c)" => "(c + b) + a"
      rightLeft.swapWith(rightRight)

      # "a + (b + c)" => "(a + c + b)"
      right.prependChild(left.remove)

      # "a + (b + c)" => "(a + b) + c"
      appendChild(rightRight.remove)
    }
  }

  # Factory functions
  namespace Node {
    def createAnnotation(value Node, test Node) Node {
      assert(value.kind.isExpression)
      assert(test == null || test.kind.isExpression)
      return new(.ANNOTATION).appendChild(value).appendChild(test)
    }

    def createBlock Node {
      return new(.BLOCK)
    }

    def createCase Node {
      return new(.CASE)
    }

    def createCatch(symbol VariableSymbol, block Node) Node {
      assert(block.kind == .BLOCK)
      return new(.CATCH).appendChild(block).withSymbol(symbol)
    }

    def createBreak Node {
      return new(.BREAK)
    }

    def createContinue Node {
      return new(.CONTINUE)
    }

    def createExpression(value Node) Node {
      assert(value.kind.isExpression)
      return new(.EXPRESSION).appendChild(value)
    }

    def createFor(setup Node, test Node, update Node, block Node) Node {
      assert(setup.kind.isExpression || setup.kind == .VARIABLES)
      assert(test.kind.isExpression)
      assert(update.kind.isExpression)
      assert(block.kind == .BLOCK)
      return new(.FOR).appendChild(setup).appendChild(test).appendChild(update).appendChild(block)
    }

    def createForeach(symbol VariableSymbol, value Node, block Node) Node {
      assert(value.kind.isExpression)
      assert(block.kind == .BLOCK)
      return new(.FOREACH).withSymbol(symbol).appendChild(value).appendChild(block)
    }

    def createIf(test Node, trueBlock Node, falseBlock Node) Node {
      assert(test.kind.isExpression)
      assert(trueBlock.kind == .BLOCK)
      assert(falseBlock == null || falseBlock.kind == .BLOCK)
      return new(.IF).appendChild(test).appendChild(trueBlock).appendChild(falseBlock)
    }

    def createReturn(value Node) Node {
      assert(value == null || value.kind.isExpression)
      return new(.RETURN).appendChild(value)
    }

    def createSwitch(value Node) Node {
      assert(value.kind.isExpression)
      return new(.SWITCH).appendChild(value)
    }

    def createThrow(value Node) Node {
      assert(value.kind.isExpression)
      return new(.THROW).appendChild(value)
    }

    def createTry(tryBlock Node) Node {
      assert(tryBlock.kind == .BLOCK)
      return new(.TRY).appendChild(tryBlock)
    }

    # This adds the initializer expression to the tree for ease of traversal
    def createVariable(symbol VariableSymbol) Node {
      return new(.VARIABLE).appendChild(symbol.value).withSymbol(symbol)
    }

    def createVariables Node {
      return new(.VARIABLES)
    }

    def createWhile(test Node, block Node) Node {
      return new(.WHILE).appendChild(test).appendChild(block)
    }

    def createAssignIndex(left Node, center Node, right Node) Node {
      assert(left.kind.isExpression)
      assert(center.kind.isExpression)
      assert(right.kind.isExpression)
      return new(.ASSIGN_INDEX).appendChild(left).appendChild(center).appendChild(right)
    }

    def createIndex(left Node, right Node) Node {
      assert(left.kind.isExpression)
      assert(right.kind.isExpression)
      return new(.INDEX).appendChild(left).appendChild(right)
    }

    def createCall(target Node) Node {
      assert(target.kind.isExpression)
      return new(.CALL).appendChild(target)
    }

    def createCast(value Node, type Node) Node {
      assert(value.kind.isExpression)
      assert(type.kind.isExpression)
      return new(.CAST).appendChild(value).appendChild(type)
    }

    def createBool(value bool) Node {
      return createConstant(BoolContent.new(value))
    }

    def createInt(value int) Node {
      return createConstant(IntContent.new(value))
    }

    def createDouble(value double) Node {
      return createConstant(DoubleContent.new(value))
    }

    def createString(value string) Node {
      return createConstant(StringContent.new(value))
    }

    def createConstant(value Content) Node {
      return new(.CONSTANT).withContent(value)
    }

    def createDot(target Node, name string) Node {
      return new(.DOT).withContent(StringContent.new(name)).appendChild(target)
    }

    def createHook(test Node, trueValue Node, falseValue Node) Node {
      assert(test.kind.isExpression)
      assert(trueValue.kind.isExpression)
      assert(falseValue.kind.isExpression)
      return new(.HOOK).appendChild(test).appendChild(trueValue).appendChild(falseValue)
    }

    def createList Node {
      return new(.INITIALIZER_LIST)
    }

    def createInitializer(kind NodeKind) Node {
      assert(kind.isInitializer)
      return new(kind)
    }

    # This adds the block to the tree for ease of traversal
    def createLambda(symbol FunctionSymbol) Node {
      return new(.LAMBDA).appendChild(symbol.block).withSymbol(symbol)
    }

    def createName(text string) Node {
      return new(.NAME).withContent(StringContent.new(text))
    }

    def createNull Node {
      return new(.NULL)
    }

    def createNullDot(target Node, name string) Node {
      return new(.NULL_DOT).withContent(StringContent.new(name)).appendChild(target)
    }

    def createPair(first Node, second Node) Node {
      assert(first.kind.isExpression)
      assert(second.kind.isExpression)
      return new(.PAIR).appendChild(first).appendChild(second)
    }

    def createParameterize(value Node) Node {
      assert(value.kind.isExpression)
      return new(.PARAMETERIZE).appendChild(value)
    }

    def createSequence Node {
      return new(.SEQUENCE)
    }

    def createSequence(before Node, after Node) Node {
      assert(before.kind.isExpression)
      assert(after.kind.isExpression)

      if before.kind == .SEQUENCE {
        if after.kind == .SEQUENCE {
          return before.appendChildrenFrom(after)
        }
        return before.appendChild(after)
      }
      if after.kind == .SEQUENCE {
        return after.prependChild(before)
      }
      return createSequence.appendChild(before).appendChild(after)
    }

    def createSuper Node {
      return new(.SUPER)
    }

    def createType(type Type) Node {
      return new(.TYPE).withType(type)
    }

    def createTypeCheck(value Node, type Node) Node {
      assert(value.kind.isExpression)
      assert(type.kind.isExpression)
      return new(.TYPE_CHECK).appendChild(value).appendChild(type)
    }

    def createUnary(kind NodeKind, value Node) Node {
      assert(kind.isUnary)
      assert(value.kind.isExpression)
      return new(kind).appendChild(value)
    }

    def createBinary(kind NodeKind, left Node, right Node) Node {
      assert(kind.isBinary)
      assert(left.kind.isExpression)
      assert(right.kind.isExpression)
      return new(kind).appendChild(left).appendChild(right)
    }

    def createLambdaType Node {
      return new(.LAMBDA_TYPE).appendChild(createType(null))
    }

    def createSymbolReference(symbol Symbol) Node {
      return createName(symbol.name).withSymbol(symbol).withType(symbol.resolvedType)
    }

    def createMemberReference(target Node, member Symbol) Node {
      return createDot(target, member.name).withSymbol(member).withType(member.resolvedType)
    }

    def createSymbolCall(symbol Symbol) Node {
      return createCall(createSymbolReference(symbol)).withSymbol(symbol).withType(symbol.resolvedType.returnType)
    }
  }

  # Getters, most of which should be inlineable when asserts are skipped in release
  class Node {
    def isInt bool {
      return kind == .CONSTANT && content.kind == .INT
    }

    def isBool bool {
      return kind == .CONSTANT && content.kind == .BOOL
    }

    def isDouble bool {
      return kind == .CONSTANT && content.kind == .DOUBLE
    }

    def isString bool {
      return kind == .CONSTANT && content.kind == .STRING
    }

    def asInt int {
      assert(kind == .CONSTANT)
      return content.asInt
    }

    def asBool bool {
      assert(kind == .CONSTANT)
      return content.asBool
    }

    def asDouble double {
      assert(kind == .CONSTANT)
      return content.asDouble
    }

    def asString string {
      assert(kind == .NAME || kind == .DOT || kind == .CONSTANT || kind == .NULL_DOT)
      return content.asString
    }

    def blockStatement Node {
      assert(kind == .BLOCK)
      return hasOneChild ? _firstChild : null
    }

    def firstValue Node {
      assert(kind == .PAIR)
      assert(childCount == 2)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def secondValue Node {
      assert(kind == .PAIR)
      assert(childCount == 2)
      assert(_lastChild.kind.isExpression)
      return _lastChild
    }

    def dotTarget Node {
      assert(kind == .DOT || kind == .NULL_DOT)
      assert(childCount <= 1)
      assert(_firstChild == null || _firstChild.kind.isExpression)
      return _firstChild
    }

    def annotationValue Node {
      assert(kind == .ANNOTATION)
      assert(childCount == 1 || childCount == 2)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def annotationTest Node {
      assert(kind == .ANNOTATION)
      assert(childCount == 1 || childCount == 2)
      assert(_firstChild._nextSibling == null || _firstChild._nextSibling.kind.isExpression)
      return _firstChild._nextSibling
    }

    def caseBlock Node {
      assert(kind == .CASE)
      assert(childCount >= 1)
      assert(_lastChild.kind == .BLOCK)
      return _lastChild
    }

    def catchBlock Node {
      assert(kind == .CATCH)
      assert(childCount == 1)
      assert(_firstChild.kind == .BLOCK)
      return _firstChild
    }

    def expressionValue Node {
      assert(kind == .EXPRESSION)
      assert(childCount == 1)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def returnValue Node {
      assert(kind == .RETURN)
      assert(childCount <= 1)
      assert(_firstChild == null || _firstChild.kind.isExpression)
      return _firstChild
    }

    def switchValue Node {
      assert(kind == .SWITCH)
      assert(childCount >= 1)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def defaultCase Node {
      assert(kind == .SWITCH)
      assert(childCount >= 1)
      return !hasOneChild && _lastChild.hasOneChild ? _lastChild : null # The default case is always the last one
    }

    def parameterizeValue Node {
      assert(kind == .PARAMETERIZE)
      assert(childCount >= 1)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def callValue Node {
      assert(kind == .CALL)
      assert(childCount >= 1)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def castValue Node {
      assert(kind == .CAST)
      assert(childCount == 2)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def castType Node {
      assert(kind == .CAST)
      assert(childCount == 2)
      assert(_lastChild.kind.isExpression)
      return _lastChild
    }

    def typeCheckValue Node {
      assert(kind == .TYPE_CHECK)
      assert(childCount == 2)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def typeCheckType Node {
      assert(kind == .TYPE_CHECK)
      assert(childCount == 2)
      assert(_lastChild.kind.isExpression)
      return _lastChild
    }

    def unaryValue Node {
      assert(kind.isUnary)
      assert(childCount == 1)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def binaryLeft Node {
      assert(kind.isBinary)
      assert(childCount == 2)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def binaryRight Node {
      assert(kind.isBinary)
      assert(childCount == 2)
      assert(_lastChild.kind.isExpression)
      return _lastChild
    }

    def throwValue Node {
      assert(childCount == 1)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def tryBlock Node {
      assert(kind == .TRY)
      assert(childCount >= 1)
      assert(_firstChild.kind == .BLOCK)
      return _firstChild
    }

    def finallyBlock Node {
      assert(kind == .TRY)
      assert(childCount >= 1)
      var finallyBlock = _lastChild
      return finallyBlock != tryBlock && finallyBlock.kind == .BLOCK ? finallyBlock : null
    }

    def variableValue Node {
      assert(kind == .VARIABLE)
      assert(childCount <= 1)
      assert(_firstChild == null || _firstChild.kind.isExpression)
      return _firstChild
    }

    def whileTest Node {
      assert(kind == .WHILE)
      assert(childCount == 2)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def whileBlock Node {
      assert(kind == .WHILE)
      assert(childCount == 2)
      assert(_lastChild.kind == .BLOCK)
      return _lastChild
    }

    def forSetup Node {
      assert(kind == .FOR)
      assert(childCount == 4)
      assert(_firstChild.kind.isExpression || _firstChild.kind == .VARIABLES)
      return _firstChild
    }

    def forTest Node {
      assert(kind == .FOR)
      assert(childCount == 4)
      assert(_firstChild._nextSibling.kind.isExpression)
      return _firstChild._nextSibling
    }

    def forUpdate Node {
      assert(kind == .FOR)
      assert(childCount == 4)
      assert(_lastChild._previousSibling.kind.isExpression)
      return _lastChild._previousSibling
    }

    def forBlock Node {
      assert(kind == .FOR)
      assert(childCount == 4)
      assert(_lastChild.kind == .BLOCK)
      return _lastChild
    }

    def foreachValue Node {
      assert(kind == .FOREACH)
      assert(childCount == 2)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def foreachBlock Node {
      assert(kind == .FOREACH)
      assert(childCount == 2)
      assert(_lastChild.kind == .BLOCK)
      return _lastChild
    }

    def ifTest Node {
      assert(kind == .IF)
      assert(childCount == 2 || childCount == 3)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def ifTrue Node {
      assert(kind == .IF)
      assert(childCount == 2 || childCount == 3)
      assert(_firstChild._nextSibling.kind == .BLOCK)
      return _firstChild._nextSibling
    }

    def ifFalse Node {
      assert(kind == .IF)
      assert(childCount == 2 || childCount == 3)
      assert(_firstChild._nextSibling._nextSibling == null || _firstChild._nextSibling._nextSibling.kind == .BLOCK)
      return _firstChild._nextSibling._nextSibling
    }

    def hookTest Node {
      assert(kind == .HOOK)
      assert(childCount == 3)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def hookTrue Node {
      assert(kind == .HOOK)
      assert(childCount == 3)
      assert(_firstChild._nextSibling.kind.isExpression)
      return _firstChild._nextSibling
    }

    def hookFalse Node {
      assert(kind == .HOOK)
      assert(childCount == 3)
      assert(_lastChild.kind.isExpression)
      return _lastChild
    }

    def indexLeft Node {
      assert(kind == .INDEX)
      assert(childCount == 2)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def indexRight Node {
      assert(kind == .INDEX)
      assert(childCount == 2)
      assert(_firstChild._nextSibling.kind.isExpression)
      return _firstChild._nextSibling
    }

    def assignIndexLeft Node {
      assert(kind == .ASSIGN_INDEX)
      assert(childCount == 3)
      assert(_firstChild.kind.isExpression)
      return _firstChild
    }

    def assignIndexCenter Node {
      assert(kind == .ASSIGN_INDEX)
      assert(childCount == 3)
      assert(_firstChild._nextSibling.kind.isExpression)
      return _firstChild._nextSibling
    }

    def assignIndexRight Node {
      assert(kind == .ASSIGN_INDEX)
      assert(childCount == 3)
      assert(_lastChild.kind.isExpression)
      return _lastChild
    }

    def lambdaBlock Node {
      assert(kind == .LAMBDA)
      assert(childCount == 1)
      assert(_firstChild.kind == .BLOCK)
      return _firstChild
    }

    def lambdaReturnType Node {
      assert(kind == .LAMBDA_TYPE)
      assert(childCount >= 1)
      assert(_lastChild.kind.isExpression)
      return _lastChild
    }
  }
}
