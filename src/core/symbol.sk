namespace Skew {
  enum SymbolKind {
    PARAMETER_FUNCTION
    PARAMETER_OBJECT

    OBJECT_CLASS
    OBJECT_ENUM
    OBJECT_GLOBAL
    OBJECT_INTERFACE
    OBJECT_NAMESPACE

    FUNCTION_ANNOTATION
    FUNCTION_CONSTRUCTOR
    FUNCTION_GLOBAL
    FUNCTION_INSTANCE
    FUNCTION_LOCAL

    OVERLOADED_ANNOTATION
    OVERLOADED_GLOBAL
    OVERLOADED_INSTANCE

    VARIABLE_ENUM
    VARIABLE_GLOBAL
    VARIABLE_INSTANCE
    VARIABLE_LOCAL

    def isType bool {
      return self as int >= PARAMETER_FUNCTION as int && self as int <= OBJECT_NAMESPACE as int
    }

    def isParameter bool {
      return self as int >= PARAMETER_FUNCTION as int && self as int <= PARAMETER_OBJECT as int
    }

    def isObject bool {
      return self as int >= OBJECT_CLASS as int && self as int <= OBJECT_NAMESPACE as int
    }

    def isFunction bool {
      return self as int >= FUNCTION_ANNOTATION as int && self as int <= FUNCTION_LOCAL as int
    }

    def isOverloadedFunction bool {
      return self as int >= OVERLOADED_ANNOTATION as int && self as int <= OVERLOADED_INSTANCE as int
    }

    def isFunctionOrOverloadedFunction bool {
      return self as int >= FUNCTION_ANNOTATION as int && self as int <= OVERLOADED_INSTANCE as int
    }

    def isVariable bool {
      return self as int >= VARIABLE_ENUM as int && self as int <= VARIABLE_LOCAL as int
    }

    def isGlobalReference bool {
      return
        self == VARIABLE_ENUM || self == VARIABLE_GLOBAL ||
        self == FUNCTION_GLOBAL || self == FUNCTION_CONSTRUCTOR ||
        self == OVERLOADED_GLOBAL || isType
    }

    def hasInstances bool {
      return self == OBJECT_CLASS || self == OBJECT_ENUM || self == OBJECT_INTERFACE
    }

    def isOnInstances bool {
      return self == FUNCTION_INSTANCE || self == VARIABLE_INSTANCE || self == OVERLOADED_INSTANCE
    }

    def isLocal bool {
      return self == FUNCTION_LOCAL || self == VARIABLE_LOCAL
    }
  }

  enum SymbolState {
    UNINITIALIZED
    INITIALIZING
    INITIALIZED
  }

  namespace Symbol {
    # Flags
    const IS_AUTOMATICALLY_GENERATED = 1 << 0
    const IS_CONST = 1 << 1
    const IS_GETTER = 1 << 2
    const IS_LOOP_VARIABLE = 1 << 3
    const IS_OVER = 1 << 4
    const IS_SETTER = 1 << 5
    const IS_VALUE_TYPE = 1 << 6
    const SHOULD_INFER_RETURN_TYPE = 1 << 7

    # Modifiers
    const IS_DEPRECATED = 1 << 8
    const IS_ENTRY_POINT = 1 << 9
    const IS_EXPORTED = 1 << 10
    const IS_IMPORTED = 1 << 11
    const IS_PREFERRED = 1 << 12
    const IS_PRIVATE = 1 << 13
    const IS_PROTECTED = 1 << 14
    const IS_RENAMED = 1 << 15
    const IS_SKIPPED = 1 << 16

    # Pass-specific flags
    const IS_MERGED = 1 << 17
    const IS_OBSOLETE = 1 << 18
    const IS_PRIMARY_CONSTRUCTOR = 1 << 19
  }

  class Symbol {
    const id = createID
    var kind SymbolKind
    var name string
    var range Range = null # The location of the name in the source code
    var parent Symbol = null # Automatically set by the merging step
    var resolvedType Type = null # Automatically set by the resolving step
    var scope Scope = null # Automatically set by the merging step (resolving step for local variables)
    var state SymbolState = .UNINITIALIZED
    var annotations List<Node> = null
    var comments List<string> = null
    var flags = 0

    # Flags
    def isAutomaticallyGenerated bool { return (flags & IS_AUTOMATICALLY_GENERATED) != 0 }
    def isConst bool                  { return (flags & IS_CONST) != 0 }
    def isGetter bool                 { return (flags & IS_GETTER) != 0 }
    def isLoopVariable bool           { return (flags & IS_LOOP_VARIABLE) != 0 }
    def isOver bool                   { return (flags & IS_OVER) != 0 }
    def isSetter bool                 { return (flags & IS_SETTER) != 0 }
    def isValueType bool              { return (flags & IS_VALUE_TYPE) != 0 }
    def shouldInferReturnType bool    { return (flags & SHOULD_INFER_RETURN_TYPE) != 0 }

    # Modifiers
    def isDeprecated bool { return (flags & IS_DEPRECATED) != 0 }
    def isEntryPoint bool { return (flags & IS_ENTRY_POINT) != 0 }
    def isExported bool   { return (flags & IS_EXPORTED) != 0 }
    def isImported bool   { return (flags & IS_IMPORTED) != 0 }
    def isPreferred bool  { return (flags & IS_PREFERRED) != 0 }
    def isPrivate bool    { return (flags & IS_PRIVATE) != 0 }
    def isProtected bool  { return (flags & IS_PROTECTED) != 0 }
    def isRenamed bool    { return (flags & IS_RENAMED) != 0 }
    def isSkipped bool    { return (flags & IS_SKIPPED) != 0 }

    # Pass-specific flags
    def isMerged bool             { return (flags & IS_MERGED) != 0 }
    def isObsolete bool           { return (flags & IS_OBSOLETE) != 0 }
    def isPrimaryConstructor bool { return (flags & IS_PRIMARY_CONSTRUCTOR) != 0 }

    # Combinations
    def isPrivateOrProtected bool { return (flags & (IS_PRIVATE | IS_PROTECTED)) != 0 }
    def isImportedOrExported bool { return (flags & (IS_IMPORTED | IS_EXPORTED)) != 0 }

    def asParameterSymbol ParameterSymbol {
      assert(kind.isParameter)
      return self as ParameterSymbol
    }

    def asObjectSymbol ObjectSymbol {
      assert(kind.isObject)
      return self as ObjectSymbol
    }

    def asFunctionSymbol FunctionSymbol {
      assert(kind.isFunction)
      return self as FunctionSymbol
    }

    def asOverloadedFunctionSymbol OverloadedFunctionSymbol {
      assert(kind.isOverloadedFunction)
      return self as OverloadedFunctionSymbol
    }

    def asVariableSymbol VariableSymbol {
      assert(kind.isVariable)
      return self as VariableSymbol
    }

    def fullName string {
      if parent != null && parent.kind != .OBJECT_GLOBAL && !kind.isParameter {
        return parent.fullName + "." + name
      }
      return name
    }

    def mergeAnnotationsAndCommentsFrom(symbol Symbol) {
      if annotations == null {
        annotations = symbol.annotations
      } else if symbol.annotations != null {
        annotations.append(symbol.annotations)
      }
      if comments == null {
        comments = symbol.comments
      } else if symbol.comments != null {
        comments.append(symbol.comments)
      }
    }

    def nameWithRenaming string {
      if isRenamed {
        for annotation in annotations {
          if annotation.symbol != null && annotation.symbol.fullName == "rename" {
            var children = annotation.annotationValue.children
            if children.count == 2 {
              return children.last.content.asString
            }
          }
        }
      }
      return name
    }
  }

  namespace Symbol {
    @private {
      def createID int {
        nextID++
        return nextID
      }

      var nextID = 0
    }
  }

  class ParameterSymbol : Symbol {
  }

  class Guard {
    var parent ObjectSymbol
    var test Node
    var contents ObjectSymbol
    var elseGuard Guard
  }

  class ObjectSymbol : Symbol {
    var base Node = null
    var baseClass ObjectSymbol = null
    var members StringMap<Symbol> = {}
    var objects List<ObjectSymbol> = []
    var functions List<FunctionSymbol> = []
    var variables List<VariableSymbol> = []
    var parameters List<ParameterSymbol> = null
    var guards List<Guard> = [] # Compile-time if statements

    def hasBaseClass(symbol Symbol) bool {
      return baseClass != null && (baseClass == symbol || baseClass.hasBaseClass(symbol))
    }
  }

  class FunctionSymbol : Symbol {
    var overridden FunctionSymbol = null
    var overloaded OverloadedFunctionSymbol = null
    var parameters List<ParameterSymbol> = null
    var arguments List<VariableSymbol> = []
    var self VariableSymbol = null # For instance functions and constructors
    var argumentOnlyType Type = null # For quickly comparing the argument types of two function symbols
    var returnType Node = null
    var block Node = null
  }

  class VariableSymbol : Symbol {
    var type Node = null
    var value Node = null
  }

  class OverloadedFunctionSymbol : Symbol {
    var overridden OverloadedFunctionSymbol = null
    var symbols List<FunctionSymbol>
  }
}
