namespace astral {
  enum SymbolKind {
    NONE

    TYPE_CLASS
    TYPE_GLOBAL
    TYPE_INTERFACE
    TYPE_NAMESPACE

    FUNC_CONSTRUCTOR
    FUNC_GLOBAL
    FUNC_INSTANCE
    FUNC_LOCAL
    FUNC_OVERLOADED_CONSTRUCTOR
    FUNC_OVERLOADED_GLOBAL
    FUNC_OVERLOADED_INSTANCE

    VAR_GLOBAL
    VAR_INSTANCE
    VAR_LOCAL
  }

  in SymbolKind {
    bool isType() {
      return this >= TYPE_CLASS && this <= TYPE_NAMESPACE
    }

    bool isFunc() {
      return this >= FUNC_CONSTRUCTOR && this <= FUNC_OVERLOADED_INSTANCE
    }

    bool isVar() {
      return this >= VAR_GLOBAL && this <= VAR_LOCAL
    }

    bool isOverloadable() {
      return this >= FUNC_CONSTRUCTOR && this <= FUNC_INSTANCE
    }

    bool isOverloaded() {
      return this >= FUNC_OVERLOADED_CONSTRUCTOR && this <= FUNC_OVERLOADED_INSTANCE
    }

    SymbolKind toOverloaded() {
      assert isOverloadable()
      return (SymbolKind)(FUNC_OVERLOADED_CONSTRUCTOR - FUNC_CONSTRUCTOR + this)
    }

    SymbolKind fromOverloaded() {
      assert isOverloaded()
      return (SymbolKind)(FUNC_CONSTRUCTOR - FUNC_OVERLOADED_CONSTRUCTOR + this)
    }
  }

  enum SymbolState {
    UNINITIALIZED
    INITIALIZING
    INITIALIZED
  }

  class Symbol {
    int id = createID()
    SymbolKind kind
    string name
    Range range = null // The location of the name in the source code
    Symbol parent = null // Automatically set by the merging step
    Type resolvedType = null // Automatically set by the resolving step
    SymbolState state = .UNINITIALIZED

    TypeSymbol asType() {
      assert kind.isType()
      return (TypeSymbol)this
    }

    FuncSymbol asFunc() {
      assert kind.isFunc()
      return (FuncSymbol)this
    }

    VarSymbol asVar() {
      assert kind.isVar()
      return (VarSymbol)this
    }

    string fullName() {
      if (parent != null && parent.kind != .TYPE_GLOBAL) {
        return parent.fullName() + "." + name
      }
      return name
    }

    private static {
      int createID() {
        nextID++
        return nextID
      }

      int nextID = 0
    }
  }

  class TypeSymbol : Symbol {
    Node base = null
    StringMap<Symbol> members = {}
    List<TypeSymbol> types = []
    List<FuncSymbol> funcs = []
    List<VarSymbol> vars = []
  }

  class FuncSymbol : Symbol {
    OverloadedFuncSymbol overloaded = null
    List<VarSymbol> args = []
    Node returnType = null
    Node block = null
  }

  class VarSymbol : Symbol {
    Node type = null
    Node value = null
  }

  class OverloadedFuncSymbol : Symbol {
    List<FuncSymbol> symbols
  }
}
