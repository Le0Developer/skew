namespace skew {
  enum SymbolKind {
    NONE
    PARAMETER_FUNCTION
    PARAMETER_OBJECT

    OBJECT_CLASS
    OBJECT_ENUM
    OBJECT_GLOBAL
    OBJECT_INTERFACE
    OBJECT_NAMESPACE

    FUNCTION_ANNOTATION
    FUNCTION_CONSTRUCTOR
    FUNCTION_GLOBAL
    FUNCTION_INSTANCE
    FUNCTION_LOCAL

    OVERLOADED_GLOBAL
    OVERLOADED_INSTANCE

    VARIABLE_ENUM
    VARIABLE_GLOBAL
    VARIABLE_INSTANCE
    VARIABLE_LOCAL
  }

  in SymbolKind {
    bool isType() {
      return this >= PARAMETER_FUNCTION && this <= OBJECT_NAMESPACE
    }

    bool isParameter() {
      return this >= PARAMETER_FUNCTION && this <= PARAMETER_OBJECT
    }

    bool isObject() {
      return this >= OBJECT_CLASS && this <= OBJECT_NAMESPACE
    }

    bool isFunction() {
      return this >= FUNCTION_ANNOTATION && this <= FUNCTION_LOCAL
    }

    bool isOverloadedFunction() {
      return this >= OVERLOADED_GLOBAL && this <= OVERLOADED_INSTANCE
    }

    bool isFunctionOrOverloadedFunction() {
      return this >= FUNCTION_ANNOTATION && this <= OVERLOADED_INSTANCE
    }

    bool isVariable() {
      return this >= VARIABLE_ENUM && this <= VARIABLE_LOCAL
    }

    bool isOverloadableFunction() {
      return this >= FUNCTION_CONSTRUCTOR && this <= FUNCTION_INSTANCE
    }

    bool isGlobalReference() {
      return
        this == VARIABLE_ENUM || this == VARIABLE_GLOBAL ||
        this == FUNCTION_GLOBAL || this == FUNCTION_CONSTRUCTOR ||
        this == OVERLOADED_GLOBAL || isType()
    }

    bool hasInstances() {
      return this == OBJECT_CLASS || this == OBJECT_ENUM || this == OBJECT_INTERFACE
    }

    bool isOnInstances() {
      return this == FUNCTION_INSTANCE || this == VARIABLE_INSTANCE || this == OVERLOADED_INSTANCE
    }
  }

  enum flags SymbolFlags {
    AUTOMATICALLY_GENERATED
    CONST
    GETTER
    INFER_RETURN_TYPE
    OVER
    SETTER
    VALUE_TYPE

    // Modifiers
    EXPORT
    IMPORT
    PREFER
    PRIVATE
    PROTECTED
    RENAME
    SKIP
  }

  enum SymbolState {
    UNINITIALIZED
    INITIALIZING
    INITIALIZED
  }

  class Symbol {
    final int id = createID()
    SymbolKind kind
    string name
    Range range = null // The location of the name in the source code
    Symbol parent = null // Automatically set by the merging step
    Type resolvedType = null // Automatically set by the resolving step
    Scope scope = null // Automatically set by the merging step (resolving step for local variables)
    SymbolState state = .UNINITIALIZED
    SymbolFlags flags = 0
    List<Node> annotations = null
    List<string> comments = null

    ParameterSymbol asParameterSymbol() {
      assert kind.isParameter()
      return (ParameterSymbol)this
    }

    ObjectSymbol asObjectSymbol() {
      assert kind.isObject()
      return (ObjectSymbol)this
    }

    FunctionSymbol asFunctionSymbol() {
      assert kind.isFunction()
      return (FunctionSymbol)this
    }

    OverloadedFunctionSymbol asOverloadedFunctionSymbol() {
      assert kind.isOverloadedFunction()
      return (OverloadedFunctionSymbol)this
    }

    VariableSymbol asVariableSymbol() {
      assert kind.isVariable()
      return (VariableSymbol)this
    }

    string fullName() {
      if (parent != null && parent.kind != .OBJECT_GLOBAL && !kind.isParameter()) {
        return parent.fullName() + "." + name
      }
      return name
    }

    bool isValueType() {
      return (flags & .VALUE_TYPE) != 0
    }

    bool isAutomaticallyGenerated() {
      return (flags & .AUTOMATICALLY_GENERATED) != 0
    }

    bool isConst() {
      return (flags & .CONST) != 0
    }

    bool isGetter() {
      return (flags & .GETTER) != 0
    }

    bool isSetter() {
      return (flags & .SETTER) != 0
    }

    bool shouldInferReturnType() {
      return (flags & .INFER_RETURN_TYPE) != 0
    }

    bool isExported() {
      return (flags & .EXPORT) != 0
    }

    bool isImported() {
      return (flags & .IMPORT) != 0
    }

    bool isImportedOrExported() {
      return (flags & (.IMPORT | .EXPORT)) != 0
    }

    bool isOver() {
      return (flags & .OVER) != 0
    }

    bool isPreferred() {
      return (flags & .PREFER) != 0
    }

    bool isPrivate() {
      return (flags & .PRIVATE) != 0
    }

    bool isProtected() {
      return (flags & .PROTECTED) != 0
    }

    bool isPrivateOrProtected() {
      return (flags & (.PRIVATE | .PROTECTED)) != 0
    }

    bool isRenamed() {
      return (flags & .RENAME) != 0
    }

    bool isSkipped() {
      return (flags & .SKIP) != 0
    }

    private static {
      int createID() {
        nextID++
        return nextID
      }

      int nextID = 0
    }
  }

  class ParameterSymbol : Symbol {
  }

  class ObjectSymbol : Symbol {
    Node base = null
    ObjectSymbol baseClass = null
    StringMap<Symbol> members = {}
    List<ObjectSymbol> objects = []
    List<FunctionSymbol> functions = []
    List<VariableSymbol> variables = []
    List<ParameterSymbol> parameters = null

    bool hasBaseClass(Symbol symbol) {
      return baseClass != null && (baseClass == symbol || baseClass.hasBaseClass(symbol))
    }
  }

  class FunctionSymbol : Symbol {
    FunctionSymbol overridden = null
    OverloadedFunctionSymbol overloaded = null
    List<ParameterSymbol> parameters = null
    List<VariableSymbol> arguments = []
    VariableSymbol self = null // For instance functions and constructors
    Type argumentOnlyType = null // For quickly comparing the argument types of two function symbols
    Node returnType = null
    Node block = null
  }

  class VariableSymbol : Symbol {
    Node type = null
    Node value = null
    int enumValue = 0
  }

  class OverloadedFunctionSymbol : Symbol {
    OverloadedFunctionSymbol overridden = null
    List<FunctionSymbol> symbols
  }
}
