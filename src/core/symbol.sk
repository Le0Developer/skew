namespace astral {
  enum SymbolKind {
    NONE
    PARAMETER

    TYPE_CLASS
    TYPE_GLOBAL
    TYPE_INTERFACE
    TYPE_NAMESPACE

    FUNCTION_CONSTRUCTOR
    FUNCTION_GLOBAL
    FUNCTION_INSTANCE
    FUNCTION_LOCAL
    FUNCTION_OVERLOADED_CONSTRUCTOR
    FUNCTION_OVERLOADED_GLOBAL
    FUNCTION_OVERLOADED_INSTANCE

    VARIABLE_GLOBAL
    VARIABLE_INSTANCE
    VARIABLE_LOCAL
  }

  in SymbolKind {
    bool isType() {
      return this >= TYPE_CLASS && this <= TYPE_NAMESPACE
    }

    bool isFunction() {
      return this >= FUNCTION_CONSTRUCTOR && this <= FUNCTION_OVERLOADED_INSTANCE
    }

    bool isVariable() {
      return this >= VARIABLE_GLOBAL && this <= VARIABLE_LOCAL
    }

    bool isOverloadable() {
      return this >= FUNCTION_CONSTRUCTOR && this <= FUNCTION_INSTANCE
    }

    bool isOverloaded() {
      return this >= FUNCTION_OVERLOADED_CONSTRUCTOR && this <= FUNCTION_OVERLOADED_INSTANCE
    }

    SymbolKind toOverloaded() {
      assert isOverloadable()
      return (SymbolKind)(FUNCTION_OVERLOADED_CONSTRUCTOR - FUNCTION_CONSTRUCTOR + this)
    }

    SymbolKind fromOverloaded() {
      assert isOverloaded()
      return (SymbolKind)(FUNCTION_CONSTRUCTOR - FUNCTION_OVERLOADED_CONSTRUCTOR + this)
    }
  }

  enum SymbolState {
    UNINITIALIZED
    INITIALIZING
    INITIALIZED
  }

  class Symbol {
    int id = createID()
    SymbolKind kind
    string name
    Range range = null // The location of the name in the source code
    Symbol parent = null // Automatically set by the merging step
    Type resolvedType = null // Automatically set by the resolving step
    SymbolState state = .UNINITIALIZED

    ParameterSymbol asParameter() {
      assert kind == .PARAMETER
      return (ParameterSymbol)this
    }

    TypeSymbol asType() {
      assert kind.isType()
      return (TypeSymbol)this
    }

    FunctionSymbol asFunction() {
      assert kind.isFunction()
      return (FunctionSymbol)this
    }

    VariableSymbol asVariable() {
      assert kind.isVariable()
      return (VariableSymbol)this
    }

    string fullName() {
      if (parent != null && parent.kind != .TYPE_GLOBAL) {
        return parent.fullName() + "." + name
      }
      return name
    }

    private static {
      int createID() {
        nextID++
        return nextID
      }

      int nextID = 0
    }
  }

  class ParameterSymbol : Symbol {
  }

  class TypeSymbol : Symbol {
    Node base = null
    StringMap<Symbol> members = {}
    List<TypeSymbol> types = []
    List<FunctionSymbol> funcs = []
    List<VariableSymbol> vars = []
    List<ParameterSymbol> parameters = []
  }

  class FunctionSymbol : Symbol {
    OverloadedFunctionSymbol overloaded = null
    List<VariableSymbol> arguments = []
    List<ParameterSymbol> parameters = []
    Node returnType = null
    Node block = null
  }

  class VariableSymbol : Symbol {
    Node type = null
    Node value = null
  }

  class OverloadedFunctionSymbol : Symbol {
    List<FunctionSymbol> symbols
  }
}
