namespace astral {
  enum TypeKind {
    DYNAMIC
    FUNCTION
    NULL
    SYMBOL
  }

  class Type {
    TypeKind kind

    static var DYNAMIC = Type(.DYNAMIC)
    static var NULL = Type(.NULL)

    SymbolType asSymbolType() {
      assert kind == .SYMBOL
      return (SymbolType)this
    }

    FunctionType asFunctionType() {
      assert kind == .FUNCTION
      return (FunctionType)this
    }

    string toString() {
      switch (kind) {
        case .DYNAMIC { return "dynamic" }
        case .SYMBOL { return asSymbolType().symbol.fullName() }
        default { return "null" }
      }
    }
  }

  class SymbolType : Type {
    Symbol symbol

    new(Symbol symbol) : super(.SYMBOL), symbol = symbol {
    }
  }

  class FunctionType : Type {
    List<Type> argumentTypes
    Type returnType
  }

  class TypeCache {
    SymbolType boolType = null
    SymbolType doubleType = null
    SymbolType intType = null
    SymbolType stringType = null

    void loadGlobals(Log log, TypeSymbol global) {
      boolType = loadGlobalClass(log, global, "bool")
      doubleType = loadGlobalClass(log, global, "double")
      intType = loadGlobalClass(log, global, "int")
      stringType = loadGlobalClass(log, global, "string")
    }

    private static SymbolType loadGlobalClass(Log log, TypeSymbol global, string name) {
      var symbol = global.members.getOrDefault(name, null)
      assert symbol != null
      assert symbol.kind == .TYPE_CLASS
      var type = SymbolType(symbol.asType())
      symbol.resolvedType = type
      return type
    }
  }
}
