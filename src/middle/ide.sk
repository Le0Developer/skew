namespace Skew.IDE {
  class SymbolQuery {
    const source Source
    const index int

    var resolvedType Type = null
    var symbol Symbol = null
    var range Range = null

    def generateTooltip string {
      if symbol == null {
        return null
      }

      var text = ""
      if symbol.comments != null {
        for comment in symbol.comments {
          text += "#" + comment
        }
      }

      switch symbol.kind {
        case .FUNCTION_ANNOTATION, .FUNCTION_CONSTRUCTOR, .FUNCTION_GLOBAL, .FUNCTION_INSTANCE {
          var arguments = symbol.asFunctionSymbol.arguments
          text += "\(symbol.isOver ? "over" : "def") \(symbol.name)\(_parameters(symbol.asFunctionSymbol.parameters))"
          if resolvedType != null {
            assert(resolvedType.argumentTypes != null)
            if !arguments.isEmpty {
              text += "("
              for i in 0..arguments.count {
                if i != 0 {
                  text += ", "
                }
                text += "\(arguments[i].name) \(resolvedType.argumentTypes[i])"
              }
              text += ")"
            }
            if resolvedType.returnType != null {
              text += " \(resolvedType.returnType)"
            }
          } else {
            text += " dynamic"
          }
        }

        case .VARIABLE_ARGUMENT, .VARIABLE_ENUM, .VARIABLE_GLOBAL, .VARIABLE_INSTANCE, .VARIABLE_LOCAL {
          var value = symbol.asVariableSymbol.value
          text += "\(symbol.isConst ? "const" : "var") \(symbol.name)"
          text += resolvedType != null ? " \(resolvedType)" : " dynamic"
          if symbol.isConst && !symbol.isLoopVariable && value != null && value.kind == .CONSTANT {
            text += " = "
            switch value.content.kind {
              case .BOOL { text += value.asBool.toString }
              case .DOUBLE { text += value.asDouble.toString }
              case .INT { text += value.asInt.toString }
              case .STRING { text += quoteString(value.asString, .DOUBLE, .NORMAL) }
            }
          }
        }

        case .OBJECT_CLASS {
          text += "class \(symbol.name)\(_parameters(symbol.asObjectSymbol.parameters))"
          if symbol.asObjectSymbol.baseType != null {
            text += " : \(symbol.asObjectSymbol.baseType)"
          }
          if symbol.asObjectSymbol.interfaceTypes != null {
            var types = symbol.asObjectSymbol.interfaceTypes
            for i in 0..types.count {
              text += "\(i != 0 ? ", " : " :: ")\(types[i])"
            }
          }
        }

        case .OBJECT_WRAPPED {
          text += "type \(symbol.name)\(_parameters(symbol.asObjectSymbol.parameters))"
          if symbol.asObjectSymbol.wrappedType != null {
            text += " = \(symbol.asObjectSymbol.wrappedType)"
          }
        }

        case .OBJECT_ENUM {
          text += "\(symbol.isFlags ? "flags" : "enum") \(symbol.name)"
        }

        case .OBJECT_INTERFACE {
          text += "interface \(symbol.name)\(_parameters(symbol.asObjectSymbol.parameters))"
        }

        case .OBJECT_NAMESPACE {
          text += "namespace \(symbol.name)"
        }

        default {
          text += symbol.name
        }
      }

      return text
    }

    def run(global ObjectSymbol) {
      var findSymbolInSymbol fn(Symbol) bool
      var findSymbolInObject fn(ObjectSymbol) bool
      var findSymbolInParameter fn(ParameterSymbol) bool
      var findSymbolInFunction fn(FunctionSymbol) bool
      var findSymbolInVariable fn(VariableSymbol) bool
      var findSymbolInNode fn(Node) bool

      findSymbolInSymbol = symbol => {
        while true {
          if symbol.annotations != null {
            for node in symbol.annotations {
              if findSymbolInNode(node) {
                return true
              }
            }
          }
          if _findSymbolInRange(symbol.range, symbol) {
            resolvedType = symbol.resolvedType
            return true
          }
          if symbol.nextMergedSymbol == null {
            return false
          }
          symbol = symbol.nextMergedSymbol
        }
      }

      findSymbolInObject = symbol => {
        return
          findSymbolInSymbol(symbol) ||
          symbol.objects.any(findSymbolInObject) ||
          symbol.parameters != null && symbol.parameters.any(findSymbolInParameter) ||
          symbol.functions.any(findSymbolInFunction) ||
          symbol.variables.any(findSymbolInVariable) ||
          findSymbolInNode(symbol.extends) ||
          symbol.implements != null && symbol.implements.any(findSymbolInNode)
      }

      findSymbolInParameter = symbol => {
        return findSymbolInSymbol(symbol)
      }

      findSymbolInFunction = symbol => {
        if symbol.isAutomaticallyGenerated {
          return false
        }
        return
          findSymbolInSymbol(symbol) ||
          symbol.parameters != null && symbol.parameters.any(findSymbolInParameter) ||
          symbol.arguments.any(findSymbolInVariable) ||
          findSymbolInNode(symbol.returnType) ||
          findSymbolInNode(symbol.block)
      }

      findSymbolInVariable = symbol => {
        return
          findSymbolInSymbol(symbol) ||
          findSymbolInNode(symbol.value) ||
          findSymbolInNode(symbol.type)
      }

      findSymbolInNode = node => {
        if node != null {
          var kind = node.kind

          if kind == .VARIABLE {
            return findSymbolInVariable(node.symbol.asVariableSymbol)
          }

          for child = node.firstChild; child != null; child = child.nextSibling {
            if findSymbolInNode(child) {
              return true
            }
          }

          if !node.isIgnoredByIDE {
            if kind == .NAME && _findSymbolInRange(node.range, node.symbol) {
              resolvedType = node.resolvedType
              return true
            }

            if (kind == .DOT || kind.isUnary || kind.isBinary) && _findSymbolInRange(node.internalRangeOrRange, node.symbol) {
              resolvedType = kind == .DOT ? node.resolvedType : node.symbol?.resolvedType
              return true
            }
          }

          if kind == .LAMBDA {
            return
              node.symbol.asFunctionSymbol.arguments.any(findSymbolInVariable) ||
              findSymbolInNode(node.symbol.asFunctionSymbol.returnType)
          }
        }

        return false
      }

      findSymbolInObject(global)
    }

    def _findSymbolInRange(queryRange Range, querySymbol Symbol) bool {
      if queryRange != null && queryRange.source == source && queryRange.touches(index) {
        symbol = querySymbol
        range = queryRange
        return true
      }

      return false
    }

    def _parameters(parameters List<ParameterSymbol>) string {
      var text = ""
      if parameters != null {
        text += "<"
        for i in 0..parameters.count {
          if i != 0 {
            text += ", "
          }
          text += parameters[i].name
        }
        text += ">"
      }
      return text
    }
  }

  class SymbolsQuery {
    const source Source
    const symbols List<Symbol> = []

    def run(symbol ObjectSymbol) {
      _collectSymbol(symbol)

      for object in symbol.objects {
        run(object)
      }

      for function in symbol.functions {
        _collectSymbol(function)
      }

      for variable in symbol.variables {
        _collectSymbol(variable)
      }
    }

    def _collectSymbol(symbol Symbol) {
      if symbol.range != null && symbol.range.source == source && !symbol.isAutomaticallyGenerated {
        symbols.append(symbol)
      }
    }
  }
}
