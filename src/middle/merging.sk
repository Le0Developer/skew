namespace skew {
  def mergingPass(log Log, global ObjectSymbol) {
    merging.mergeObject(log, null, global, global)
  }
}

namespace skew.merging {
  def mergeObject(log Log, parent ObjectSymbol, target ObjectSymbol, symbol ObjectSymbol) {
    target.scope = ObjectScope.new(parent != null ? parent.scope : null, target)
    symbol.parent = parent

    if symbol.parameters != null {
      for parameter in symbol.parameters {
        parameter.scope = parent.scope
        parameter.parent = target

        # Type parameters cannot merge with any members
        var other = target.members.get(parameter.name, null)
        if other != null {
          log.semanticErrorDuplicateSymbol(parameter.range, parameter.name, other.range)
          continue
        }

        target.members[parameter.name] = parameter
      }
    }

    mergeObjects(log, target, symbol.objects)
    mergeFunctions(log, target, symbol.functions)
    mergeVariables(log, target, symbol.variables)
  }

  def mergeObjects(log Log, parent ObjectSymbol, children List<ObjectSymbol>) {
    var members = parent.members
    var n = children.count
    var count = 0

    for i in 0..n {
      var child = children[i]
      var other = members.get(child.name, null)

      # Simple case: no merging
      if other == null {
        members[child.name] = child
        children[count] = child
        count += 1
        mergeObject(log, parent, child, child)
        continue
      }

      # Can only merge with another of the same kind or with a namespace
      if other.kind == .OBJECT_NAMESPACE {
        other.kind = child.kind
      } else if child.kind != .OBJECT_NAMESPACE && child.kind != other.kind {
        log.semanticErrorDuplicateSymbol(child.range, child.name, other.range)
        continue
      }

      # Classes can only have one base type
      var object = other.asObjectSymbol
      if child.base != null && object.base != null {
        log.semanticErrorDuplicateBaseType(child.base.range, child.name, object.base.range)
        continue
      }
      if child.base != null {
        object.base = child.base
      }

      # Cannot merge two objects that both have type parameters
      if child.parameters != null && object.parameters != null {
        log.semanticErrorDuplicateTypeParameters(rangeOfParameters(child.parameters), child.name, rangeOfParameters(object.parameters))
        continue
      }

      # Merge "child" into "other"
      mergeObject(log, parent, object, child)
      object.mergeAnnotationsAndCommentsFrom(child)
      object.objects.append(child.objects)
      object.functions.append(child.functions)
      object.variables.append(child.variables)
      if child.parameters != null {
        object.parameters = child.parameters
      }
    }

    # Remove merged declarations using O(n), would be O(n^2) if removeAt was used
    while n > count {
      children.removeLast
      n -= 1
    }
  }

  def mergeFunctions(log Log, parent ObjectSymbol, children List<FunctionSymbol>) {
    var members = parent.members

    for child in children {
      var other = members.get(child.name, null)
      var scope = FunctionScope.new(parent.scope, child)
      child.scope = scope
      child.parent = parent

      if child.parameters != null {
        for parameter in child.parameters {
          parameter.scope = scope
          parameter.parent = child

          # Type parameters cannot merge with other parameters on this function
          var previous = scope.parameters.get(parameter.name, null)
          if previous != null {
            log.semanticErrorDuplicateSymbol(parameter.range, parameter.name, previous.range)
            continue
          }

          scope.parameters[parameter.name] = parameter
        }
      }

      # Simple case: no merging
      if other == null {
        members[child.name] = child
        continue
      }

      var childKind = overloadedKind(child.kind)
      var otherKind = overloadedKind(other.kind)

      # Merge with another symbol of the same overloaded group type
      if childKind != otherKind || !childKind.isOverloadedFunction {
        log.semanticErrorDuplicateSymbol(child.range, child.name, other.range)
        continue
      }

      # Merge with a group of overloaded functions
      if other.kind.isOverloadedFunction {
        other.asOverloadedFunctionSymbol.symbols.append(child)
        child.overloaded = other.asOverloadedFunctionSymbol
        continue
      }

      # Create an overload group
      var overloaded = OverloadedFunctionSymbol.new(childKind, child.name, [other.asFunctionSymbol, child])
      members[child.name] = overloaded
      other.asFunctionSymbol.overloaded = overloaded
      child.overloaded = overloaded
      overloaded.scope = parent.scope
      overloaded.parent = parent
    }
  }

  def overloadedKind(kind SymbolKind) SymbolKind {
    return
      kind == .FUNCTION_CONSTRUCTOR || kind == .FUNCTION_GLOBAL ? .OVERLOADED_GLOBAL :
      kind == .FUNCTION_INSTANCE ? .OVERLOADED_INSTANCE :
      kind
  }

  def mergeVariables(log Log, parent ObjectSymbol, children List<VariableSymbol>) {
    var members = parent.members

    for child in children {
      var other = members.get(child.name, null)
      child.scope = VariableScope.new(parent.scope, child)
      child.parent = parent

      # Variables never merge
      if other != null {
        log.semanticErrorDuplicateSymbol(child.range, child.name, other.range)
        continue
      }

      members[child.name] = child
    }
  }

  def rangeOfParameters(parameters List<ParameterSymbol>) Range {
    return Range.span(parameters.first.range, parameters.last.range)
  }
}
