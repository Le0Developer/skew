namespace skew {
  using skew.merging

  void mergingPass(Log log, ObjectSymbol global) {
    mergeObject(log, null, global, global)
  }
}

namespace skew.merging {
  void mergeObject(Log log, ObjectSymbol parent, ObjectSymbol target, ObjectSymbol symbol) {
    target.scope = ObjectScope(parent != null ? parent.scope : null, target)
    symbol.parent = parent

    if (symbol.parameters != null) {
      for (var i = 0; i < symbol.parameters.size(); i++) {
        var parameter = symbol.parameters[i]
        parameter.scope = parent.scope
        parameter.parent = target

        // Type parameters cannot merge with any members
        var other = target.members.getOrDefault(parameter.name, null)
        if (other != null) {
          log.semanticErrorDuplicateSymbol(parameter.range, parameter.name, other.range)
          continue
        }

        target.members[parameter.name] = parameter
      }
    }

    mergeObjects(log, target, symbol.objects)
    mergeFunctions(log, target, symbol.functions)
    mergeVariables(log, target, symbol.variables)
  }

  void mergeObjects(Log log, ObjectSymbol parent, List<ObjectSymbol> children) {
    var members = parent.members
    var n = children.size()
    var count = 0

    for (var i = 0; i < n; i++) {
      var child = children[i]
      var other = members.getOrDefault(child.name, null)

      // Simple case: no merging
      if (other == null) {
        members[child.name] = child
        children[count] = child
        count++
        mergeObject(log, parent, child, child)
        continue
      }

      // Can only merge with another of the same kind or with a namespace
      if (other.kind == .OBJECT_NAMESPACE) {
        other.kind = child.kind
      } else if (child.kind != .OBJECT_NAMESPACE && child.kind != other.kind) {
        log.semanticErrorDuplicateSymbol(child.range, child.name, other.range)
        continue
      }

      // Classes can only have one base type
      var object = (ObjectSymbol)other
      if (child.base != null && object.base != null) {
        log.semanticErrorDuplicateBaseType(child.base.range, child.name, object.base.range)
        continue
      }
      if (child.base != null) {
        object.base = child.base
      }

      // Cannot merge two objects that both have type parameters
      if (child.parameters != null && object.parameters != null) {
        log.semanticErrorDuplicateTypeParameters(child.range, child.name, object.range)
        continue
      }

      // Merge "child" into "other"
      mergeObject(log, parent, object, child)
      object.objects.pushAll(child.objects)
      object.functions.pushAll(child.functions)
      object.variables.pushAll(child.variables)
      if (child.parameters != null) {
        object.parameters = child.parameters
      }
    }

    // Remove merged declarations using O(n), would be O(n^2) if removeAt() was used
    while (n > count) {
      children.pop()
      n--
    }
  }

  void mergeFunctions(Log log, ObjectSymbol parent, List<FunctionSymbol> children) {
    var members = parent.members

    for (var i = 0, n = children.size(); i < n; i++) {
      var child = children[i]
      var other = members.getOrDefault(child.name, null)
      var scope = FunctionScope(parent.scope, child)
      child.scope = scope
      child.parent = parent

      if (child.parameters != null) {
        for (var j = 0; j < child.parameters.size(); j++) {
          var parameter = child.parameters[j]
          parameter.scope = scope
          parameter.parent = child

          // Type parameters cannot merge with other parameters on this function
          var previous = scope.parameters.getOrDefault(parameter.name, null)
          if (previous != null) {
            log.semanticErrorDuplicateSymbol(parameter.range, parameter.name, previous.range)
            continue
          }

          scope.parameters[parameter.name] = parameter
        }
      }

      // Simple case: no merging
      if (other == null) {
        members[child.name] = child
        continue
      }

      var childKind = overloadedKind(child.kind)
      var otherKind = overloadedKind(other.kind)

      // Merge with another symbol of the same overloaded group type
      if (childKind != otherKind || !childKind.isOverloadedFunction()) {
        log.semanticErrorDuplicateSymbol(child.range, child.name, other.range)
        continue
      }

      // Merge with a group of overloaded functions
      if (other.kind.isOverloadedFunction()) {
        ((OverloadedFunctionSymbol)other).symbols.push(child)
        child.overloaded = (OverloadedFunctionSymbol)other
        continue
      }

      // Create an overload group
      var overloaded = OverloadedFunctionSymbol(childKind, child.name, [(FunctionSymbol)other, child])
      members[child.name] = overloaded
      ((FunctionSymbol)other).overloaded = overloaded
      child.overloaded = overloaded
      overloaded.scope = parent.scope
      overloaded.parent = parent
    }
  }

  SymbolKind overloadedKind(SymbolKind kind) {
    return
      kind == .FUNCTION_CONSTRUCTOR ? .OVERLOADED_CONSTRUCTOR :
      kind == .FUNCTION_GLOBAL ? .OVERLOADED_GLOBAL :
      kind == .FUNCTION_INSTANCE ? .OVERLOADED_INSTANCE :
      kind
  }

  void mergeVariables(Log log, ObjectSymbol parent, List<VariableSymbol> children) {
    var members = parent.members

    for (var i = 0, n = children.size(); i < n; i++) {
      var child = children[i]
      var other = members.getOrDefault(child.name, null)
      child.scope = parent.scope
      child.parent = parent

      // Variables never merge
      if (other != null) {
        log.semanticErrorDuplicateSymbol(child.range, child.name, other.range)
        continue
      }

      members[child.name] = child
    }
  }
}
