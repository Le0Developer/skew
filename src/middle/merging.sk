namespace astral {
  void mergingPass(Log log, TypeSymbol global) {
    mergeType(log, null, global, global)
  }

  void mergeType(Log log, TypeSymbol parent, TypeSymbol target, TypeSymbol symbol) {
    symbol.parent = parent
    mergeTypes(log, target, symbol.types)
    mergeFunctions(log, target, symbol.funcs)
    mergeVariables(log, target, symbol.vars)
  }

  void mergeTypes(Log log, TypeSymbol parent, List<TypeSymbol> children) {
    var members = parent.members
    var n = children.size()
    var count = 0

    for (var i = 0; i < n; i++) {
      var child = children[i]
      var other = members.getOrDefault(child.name, null)

      // Simple case: no merging
      if (other == null) {
        members[child.name] = child
        children[count] = child
        count++
        mergeType(log, parent, child, child)
        continue
      }

      // Can only merge with another of the same type
      if (child.kind != other.kind) {
        log.semanticErrorDuplicateSymbol(child.range, child.name, other.range)
        continue
      }

      // Classes can only have one base type
      var type = (TypeSymbol)other
      if (child.base != null && type.base != null) {
        log.semanticErrorDuplicateBaseType(child.base.range, child.name, type.base.range)
        continue
      }
      if (child.base != null) {
        type.base = child.base
      }

      // Merge "child" into "other"
      mergeType(log, parent, type, child)
      type.types.pushAll(child.types)
      type.funcs.pushAll(child.funcs)
      type.vars.pushAll(child.vars)
    }

    // Remove merged declarations using O(n), would be O(n^2) if removeAt() was used
    while (n > count) {
      children.pop()
      n--
    }
  }

  void mergeFunctions(Log log, TypeSymbol parent, List<FunctionSymbol> children) {
    var members = parent.members

    for (var i = 0, n = children.size(); i < n; i++) {
      var child = children[i]
      var other = members.getOrDefault(child.name, null)

      // Simple case: no merging
      if (other == null) {
        members[child.name] = child
        continue
      }

      // Merge with another symbol of the same type
      if (child.kind == other.kind) {
        var overloaded = OverloadedFunctionSymbol(child.kind.toOverloaded(), child.name, [(FunctionSymbol)other, child])
        members[child.name] = overloaded
        ((FunctionSymbol)other).overloaded = overloaded
        child.overloaded = overloaded
        continue
      }

      // Merge with a group of overloaded functions
      if (other.kind.isOverloaded() && child.kind == other.kind.fromOverloaded()) {
        ((OverloadedFunctionSymbol)other).symbols.push(child)
        child.overloaded = (OverloadedFunctionSymbol)other
        continue
      }

      log.semanticErrorDuplicateSymbol(child.range, child.name, other.range)
    }
  }

  void mergeVariables(Log log, TypeSymbol parent, List<VariableSymbol> children) {
    var members = parent.members

    for (var i = 0, n = children.size(); i < n; i++) {
      var child = children[i]
      var other = members.getOrDefault(child.name, null)

      // Variables never merge
      if (other != null) {
        log.semanticErrorDuplicateSymbol(child.range, child.name, other.range)
        continue
      }

      members[child.name] = child
    }
  }
}
