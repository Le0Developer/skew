namespace skew {
  class CallSite {
    const callNode Node
    const enclosingFunction FunctionSymbol
  }

  class CallInfo {
    const symbol FunctionSymbol
    const callSites List<CallSite> = []
  }

  class CallGraph {
    const callInfo List<CallInfo> = []
    const symbolToInfoIndex IntMap<int> = {}

    def new(global ObjectSymbol) {
      visitObject(global)
    }

    @private {
      def visitObject(symbol ObjectSymbol) {
        for object in symbol.objects {
          visitObject(object)
        }

        for function in symbol.functions {
          recordCallSite(function, null, null)
          visitNode(function.block, function)
        }

        for variable in symbol.variables {
          visitNode(variable.value, null)
        }
      }

      def visitNode(node Node, context FunctionSymbol) {
        if node != null {
          if node.children != null {
            for child in node.children {
              visitNode(child, context)
            }
          }

          if node.kind == .CALL && node.symbol != null {
            assert(node.symbol.kind.isFunction)
            recordCallSite(node.symbol.asFunctionSymbol, node, context)
          }
        }
      }

      def recordCallSite(symbol FunctionSymbol, node Node, context FunctionSymbol) {
        var index = symbolToInfoIndex.get(symbol.id, -1)
        var info = index < 0 ? CallInfo.new(symbol) : callInfo[index]
        if index < 0 {
          symbolToInfoIndex[symbol.id] = callInfo.count
          callInfo.append(info)
        }
        if node != null {
          info.callSites.append(CallSite.new(node, context))
        }
      }
    }
  }
}
