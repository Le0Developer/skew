namespace Skew {
  class CompilerTarget {
    def name string { return "" }
    def extension string { return "" }
    def runPostResolvePasses bool { return false }
    def moveEverythingOffEnums bool { return false }
    def requiresIntegerSwitchStatements bool { return false }
    def supportsListForeach bool { return false }
    def supportsNestedTypes bool { return false }
    def editOptions(options CompilerOptions) {}
    def includeSources(sources List<Source>) {}
    def createEmitter(options CompilerOptions, cache TypeCache) Emitter { return null }
  }

  class Define {
    const name Range
    const value Range
  }

  class CompilerOptions {
    var defines StringMap<Define> = {}
    var foldAllConstants = false
    var globalizeAllFunctions = false
    var inlineAllFunctions = false
    var jsMangle = false
    var jsMinify = false
    var jsSourceMap = false
    var verbose = false
    var outputDirectory = ""
    var outputFile = ""
    var target = CompilerTarget.new
    var passes = [
      LexingPass.new,
      TokenProcessingPass.new,
      ParsingPass.new,
      MergingPass.new,
      ResolvingPass.new,
      CallGraphPass.new,
      GlobalizingPass.new,
      MotionPass.new,
      RenamingPass.new,
      FoldingPass.new.onlyRunWhen(options => options.foldAllConstants),
      InliningPass.new.onlyRunWhen(options => options.inlineAllFunctions),
      FoldingPass.new.onlyRunWhen(options => options.inlineAllFunctions && options.foldAllConstants),
      EmittingPass.new,
    ]

    def define(name string, value string) {
      var range = Source.new("<internal>", "--define:" + name + "=" + value).entireRange
      defines[name] = Define.new(range.slice(9, 9 + name.count), range.fromEnd(value.count))
    }
  }

  class Timer {
    var _isStarted = false
    var _startTime = 0.0
    var _totalSeconds = 0.0

    def start {
      assert(!_isStarted)
      _isStarted = true
      _startTime = Timestamp.seconds
    }

    def stop {
      assert(_isStarted)
      _isStarted = false
      _totalSeconds += Timestamp.seconds - _startTime
    }

    def elapsedMilliseconds string {
      return formatNumber(_totalSeconds * 1000) + "ms"
    }

    def isZero bool {
      return _totalSeconds == 0
    }
  }

  enum PassKind {
  }

  class PassContext {
    var log Log
    var options CompilerOptions
    var inputs List<Source>
    var cache = TypeCache.new
    var global = ObjectSymbol.new(.OBJECT_GLOBAL, "<global>")
    var callGraph CallGraph = null
    var tokens List<List<Token>> = []
    var outputs List<Source> = []
  }

  class Pass {
    var _shouldRun fn(CompilerOptions) bool = null

    def kind PassKind
    def run(context PassContext)

    def shouldRun(options CompilerOptions) bool {
      return _shouldRun != null ? _shouldRun(options) : true
    }

    def onlyRunWhen(callback fn(CompilerOptions) bool) Pass {
      _shouldRun = callback
      return self
    }
  }

  class PassTimer {
    var kind PassKind
    var timer = Timer.new
  }

  class CompilerResult {
    var cache TypeCache
    var global ObjectSymbol
    var outputs List<Source>
    var passTimers List<PassTimer>
    var totalTimer Timer

    def statistics string {
      var builder = StringBuilder.new

      # Compilation time
      builder.append("Total time: " + totalTimer.elapsedMilliseconds)
      for passTimer in passTimers {
        builder.append("\n  " + passTimer.kind.toString + ": " + passTimer.timer.elapsedMilliseconds)
      }

      # Sources
      var totalBytes = 0
      var totalLines = 0
      for source in outputs {
        totalBytes += source.contents.count
        totalLines += source.lineCount
      }
      builder.append("\nOutputs: " + outputs.count.toString + " file" + PrettyPrint.plural(outputs.count) +
        " (" + bytesToString(totalBytes) + ", " + totalLines.toString + " line" + PrettyPrint.plural(totalLines) + ")")
      for source in outputs {
        var lines = source.lineCount
        builder.append("\n  " + source.name + " (" + bytesToString(source.contents.count) + ", " + lines.toString + " line" + PrettyPrint.plural(lines) + ")")
      }

      return builder.toString
    }
  }

  def compile(log Log, options CompilerOptions, inputs List<Source>) CompilerResult {
    options.target.includeSources(inputs)
    options.target.editOptions(options)
    inputs.prepend(Source.new("<native>", NATIVE_LIBRARY))

    var context = PassContext.new(log, options, inputs)
    var passTimers List<PassTimer> = []
    var totalTimer = Timer.new
    totalTimer.start

    # Run all passes, errors stop compilation
    for pass in options.passes {
      if log.hasErrors {
        break
      }
      var passTimer = PassTimer.new(pass.kind)
      passTimers.append(passTimer)
      passTimer.timer.start
      if pass.shouldRun(options) {
        pass.run(context)
      }
      passTimer.timer.stop

      # This is expensive but can be used for debugging
      if false {
        _verifyHierarchy(context.global)
      }
    }

    totalTimer.stop
    return CompilerResult.new(context.cache, context.global, context.outputs, passTimers, totalTimer)
  }

  def _verifyHierarchy(symbol ObjectSymbol) {
    for object in symbol.objects {
      _verifyHierarchy(object)
    }

    for function in symbol.functions {
      _verifyHierarchy(function.block, null)
    }

    for variable in symbol.variables {
      _verifyHierarchy(variable.value, null)
    }
  }

  def _verifyHierarchy(node Node, parent Node) {
    if node != null {
      assert(node.parent == parent)
      for child = node.firstChild; child != null; child = child.nextSibling {
        _verifyHierarchy(child, node)
      }
    }
  }
}
