namespace skew {
  enum CompilerTarget {
    NONE
    JAVASCRIPT
    LISP_TREE

    def isTree bool {
      return self == LISP_TREE
    }
  }

  # Strings are better for debugging but ints are better for performance
  enum EnumFormat {
    INT
    STRING
  }

  class CompilerOptions {
    var target CompilerTarget = .NONE
    var outputFile = ""
    var outputDirectory = ""
    var foldAllConstants = false
    var enumFormat EnumFormat = .INT
  }

  class CompilerResult {
    var cache = TypeCache.new
    var global = ObjectSymbol.new(.OBJECT_GLOBAL, "<global>")
    var outputs List<Source> = null
    var totalTime = 0.0
  }

  def compile(log Log, options CompilerOptions, sources List<Source>) CompilerResult {
    var start = timestampInSeconds
    var debug = false
    var result = CompilerResult.new
    sources.prepend(Source.new("<native>", NATIVE_LIBRARY))

    for source in sources {
      var tokens = tokenize(log, source)
      prepareTokens(tokens)
      parsing.parseFile(log, tokens, result.global)
    }

    # Merging pass, errors stop compilation
    if !log.hasErrors {
      mergingPass(log, result.global)

      # Resolving pass, errors stop compilation
      if !log.hasErrors {
        resolvingPass(log, result.global, result.cache)
        if debug {
          verifyHierarchy(result.global)
        }

        # Prepare for emission, code is error-free at this point
        if !log.hasErrors && options.target != .NONE {
          if !options.target.isTree {
            var graph = CallGraph.new(result.global)

            # Make certain functions global
            globalizingPass(result.global, graph)
            if debug {
              verifyHierarchy(result.global)
            }

            # Move symbols around
            motionPass(result.global, graph)
            if debug {
              verifyHierarchy(result.global)
            }

            # Give overloaded functions unique names, rename operator overloads
            renamingPass(result.global)
            if debug {
              verifyHierarchy(result.global)
            }

            # Compile-time partial evaluation
            if options.foldAllConstants {
              foldingPass(result.global, result.cache)
              if debug {
                verifyHierarchy(result.global)
              }
            }
          }

          # Emit in the target language
          var emitter Emitter = null
          switch options.target {
            case .JAVASCRIPT { emitter = JsEmitter.new(options, result.cache) }
            case .LISP_TREE { emitter = LispTreeEmitter.new(options) }
          }
          if emitter != null {
            emitter.visit(result.global)
            result.outputs = emitter.sources
          }
        }
      }
    }

    result.totalTime = timestampInSeconds - start
    return result
  }

  def verifyHierarchy(symbol ObjectSymbol) {
    for object in symbol.objects {
      verifyHierarchy(object)
    }

    for function in symbol.functions {
      verifyHierarchy(function.block, null)
    }

    for variable in symbol.variables {
      verifyHierarchy(variable.value, null)
    }
  }

  def verifyHierarchy(node Node, parent Node) {
    if node != null {
      assert(node.parent == parent)
      if node.children != null {
        for child in node.children {
          verifyHierarchy(child, node)
        }
      }

      if node.kind == .VAR {
        verifyHierarchy(node.symbol.asVariableSymbol.value, null)
      }

      if node.kind == .LAMBDA {
        verifyHierarchy(node.symbol.asFunctionSymbol.block, null)
      }
    }
  }
}
