namespace Skew {
  class CompilerTarget {
    def name string { return "" }
    def extension string { return "" }
    def runPostResolvePasses bool { return false }
    def moveEverythingOffEnums bool { return false }
    def requiresIntegerSwitchStatements bool { return false }
    def supportsListForEach bool { return false }
    def editOptions(options CompilerOptions) {}
    def includeSources(sources List<Source>) {}
    def createEmitter(options CompilerOptions, cache TypeCache) Emitter { return null }
  }

  class JavaScriptTarget : CompilerTarget {
    over name string { return "JavaScript" }
    over extension string { return "js" }
    over runPostResolvePasses bool { return true }
    over editOptions(options CompilerOptions) { options.define("TARGET", "JAVASCRIPT") }
    over includeSources(sources List<Source>) { sources.prepend(Source.new("<native-js>", NATIVE_LIBRARY_JS)) }
    over createEmitter(options CompilerOptions, cache TypeCache) Emitter { return JavaScriptEmitter.new(options, cache) }
  }

  class CSharpTarget : CompilerTarget {
    over name string { return "C#" }
    over extension string { return "cs" }
    over runPostResolvePasses bool { return true }
    over moveEverythingOffEnums bool { return true }
    over requiresIntegerSwitchStatements bool { return true }
    over supportsListForEach bool { return true }
    over editOptions(options CompilerOptions) { options.define("TARGET", "CSHARP") }
    over includeSources(sources List<Source>) { sources.prepend(Source.new("<native-cs>", NATIVE_LIBRARY_CS)) }
    over createEmitter(options CompilerOptions, cache TypeCache) Emitter { return CSharpEmitter.new(options, cache) }
  }

  class LispTreeTarget : CompilerTarget {
    over name string { return "S-expression" }
    over extension string { return "lisp" }
    over runPostResolvePasses bool { return false }
    over createEmitter(options CompilerOptions, cache TypeCache) Emitter { return LispTreeEmitter.new(options) }
  }

  class Define {
    const name Range
    const value Range
  }

  class CompilerOptions {
    var defines StringMap<Define> = {}
    var foldAllConstants = false
    var globalizeAllFunctions = false
    var inlineAllFunctions = false
    var jsMangle = false
    var jsMinify = false
    var jsSourceMap = false
    var outputDirectory = ""
    var outputFile = ""
    var target CompilerTarget = CompilerTarget.new

    def define(name string, value string) {
      var range = Source.new("<internal>", "--define:" + name + "=" + value).entireRange
      defines[name] = Define.new(range.slice(9, 9 + name.count), range.fromEnd(value.count))
    }
  }

  class CompilerResult {
    var cache = TypeCache.new
    var global = ObjectSymbol.new(.OBJECT_GLOBAL, "<global>")
    var outputs List<Source> = null
    var totalTime = 0.0
  }

  def compile(log Log, options CompilerOptions, sources List<Source>) CompilerResult {
    var start = Timestamp.seconds
    var debug = !RELEASE
    var result = CompilerResult.new

    options.target.includeSources(sources)
    options.target.editOptions(options)
    sources.prepend(Source.new("<native>", NATIVE_LIBRARY))

    for source in sources {
      var tokens = tokenize(log, source)
      prepareTokens(tokens)
      parseFile(log, tokens, result.global)
    }

    # Merging pass, errors stop compilation
    if !log.hasErrors {
      mergingPass(log, result.global)

      # Resolving pass, errors stop compilation
      if !log.hasErrors {
        resolvingPass(log, result.global, result.cache, options)
        if debug {
          verifyHierarchy(result.global)
        }

        # Prepare for emission, code is error-free at this point
        if !log.hasErrors {
          if options.target.runPostResolvePasses {
            var graph = CallGraph.new(result.global)

            # Make certain functions global
            globalizingPass(result.global, graph, options)
            if debug {
              verifyHierarchy(result.global)
            }

            # Move symbols around
            motionPass(result.global, options)
            if debug {
              verifyHierarchy(result.global)
            }

            # Give overloaded functions unique names, rename operator overloads
            renamingPass(result.global)
            if debug {
              verifyHierarchy(result.global)
            }

            # Partial evaluation before inlining to make more functions inlineable by removing dead code
            if options.foldAllConstants {
              foldingPass(result.global, result.cache)
              if debug {
                verifyHierarchy(result.global)
              }
            }

            # Function inlining
            if options.inlineAllFunctions {
              inliningPass(graph)
              if debug {
                verifyHierarchy(result.global)
              }

              # Partial evaluation after inlining will simplify inlined expressions
              if options.foldAllConstants {
                foldingPass(result.global, result.cache)
                if debug {
                  verifyHierarchy(result.global)
                }
              }
            }
          }

          # Emit in the target language
          var emitter = options.target.createEmitter(options, result.cache)
          if emitter != null {
            emitter.visit(result.global)
            result.outputs = emitter.sources
          }
        }
      }
    }

    result.totalTime = Timestamp.seconds - start
    return result
  }

  def verifyHierarchy(symbol ObjectSymbol) {
    for object in symbol.objects {
      verifyHierarchy(object)
    }

    for function in symbol.functions {
      verifyHierarchy(function.block, null)
    }

    for variable in symbol.variables {
      verifyHierarchy(variable.value, null)
    }
  }

  def verifyHierarchy(node Node, parent Node) {
    if node != null {
      assert(node.parent == parent)
      if node.children != null {
        for child in node.children {
          verifyHierarchy(child, node)
        }
      }
    }
  }
}
