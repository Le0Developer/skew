namespace Skew {
  class CompilerTarget {
    def name string { return "" }
    def extension string { return "" }
    def runPostResolvePasses bool { return false }
    def moveEverythingOffEnums bool { return false }
    def requiresIntegerSwitchStatements bool { return false }
    def supportsListForeach bool { return false }
    def editOptions(options CompilerOptions) {}
    def includeSources(sources List<Source>) {}
    def createEmitter(options CompilerOptions, cache TypeCache) Emitter { return null }
  }

  class JavaScriptTarget : CompilerTarget {
    over name string { return "JavaScript" }
    over extension string { return "js" }
    over runPostResolvePasses bool { return true }
    over editOptions(options CompilerOptions) { options.define("TARGET", "JAVASCRIPT") }
    over includeSources(sources List<Source>) { sources.prepend(Source.new("<native-js>", NATIVE_LIBRARY_JS)) }
    over createEmitter(options CompilerOptions, cache TypeCache) Emitter { return JavaScriptEmitter.new(options, cache) }
  }

  class CSharpTarget : CompilerTarget {
    over name string { return "C#" }
    over extension string { return "cs" }
    over runPostResolvePasses bool { return true }
    over moveEverythingOffEnums bool { return true }
    over requiresIntegerSwitchStatements bool { return true }
    over supportsListForeach bool { return true }
    over editOptions(options CompilerOptions) { options.define("TARGET", "CSHARP") }
    over includeSources(sources List<Source>) { sources.prepend(Source.new("<native-cs>", NATIVE_LIBRARY_CS)) }
    over createEmitter(options CompilerOptions, cache TypeCache) Emitter { return CSharpEmitter.new(options, cache) }
  }

  class LispTreeTarget : CompilerTarget {
    over name string { return "S-expression" }
    over extension string { return "lisp" }
    over runPostResolvePasses bool { return false }
    over createEmitter(options CompilerOptions, cache TypeCache) Emitter { return LispTreeEmitter.new(options) }
  }

  class Define {
    const name Range
    const value Range
  }

  class CompilerOptions {
    var defines StringMap<Define> = {}
    var foldAllConstants = false
    var globalizeAllFunctions = false
    var inlineAllFunctions = false
    var jsMangle = false
    var jsMinify = false
    var jsSourceMap = false
    var verbose = false
    var outputDirectory = ""
    var outputFile = ""
    var target CompilerTarget = CompilerTarget.new

    def define(name string, value string) {
      var range = Source.new("<internal>", "--define:" + name + "=" + value).entireRange
      defines[name] = Define.new(range.slice(9, 9 + name.count), range.fromEnd(value.count))
    }
  }

  class Timer {
    def start {
      assert(!isStarted)
      isStarted = true
      startTime = Timestamp.seconds
    }

    def stop {
      assert(isStarted)
      isStarted = false
      totalSeconds += Timestamp.seconds - startTime
    }

    def elapsedMilliseconds string {
      return formatNumber(totalSeconds * 1000) + "ms"
    }

    def isZero bool {
      return totalSeconds == 0
    }

    @private {
      var isStarted = false
      var startTime = 0.0
      var totalSeconds = 0.0
    }
  }

  class CompilerResult {
    var cache = TypeCache.new
    var global = ObjectSymbol.new(.OBJECT_GLOBAL, "<global>")
    var outputs List<Source> = []

    # Timers for help tuning performance
    var callGraphTimer = Timer.new
    var emitTimer = Timer.new
    var foldingTimer = Timer.new
    var globalizeTimer = Timer.new
    var inliningTimer = Timer.new
    var motionTimer = Timer.new
    var optimizingTimer = Timer.new
    var parsingTimer = Timer.new
    var renamingTimer = Timer.new
    var resolvingTimer = Timer.new
    var tokenizingTimer = Timer.new
    var totalTimer = Timer.new

    def statistics string {
      var builder = StringBuilder.new

      # Compilation time
      builder.append("Total compile time: " + totalTimer.elapsedMilliseconds)
      if !tokenizingTimer.isZero { builder.append("\n  Tokenizing: " + tokenizingTimer.elapsedMilliseconds) }
      if !parsingTimer.isZero { builder.append("\n  Parsing: " + parsingTimer.elapsedMilliseconds) }
      if !resolvingTimer.isZero { builder.append("\n  Resolving: " + resolvingTimer.elapsedMilliseconds) }
      if !optimizingTimer.isZero {
        builder.append("\n  Optimizing: " + optimizingTimer.elapsedMilliseconds)
        builder.append("\n    Call graph: " + callGraphTimer.elapsedMilliseconds)
        builder.append("\n    Globalize: " + globalizeTimer.elapsedMilliseconds)
        builder.append("\n    Motion: " + motionTimer.elapsedMilliseconds)
        builder.append("\n    Renaming: " + renamingTimer.elapsedMilliseconds)
        builder.append("\n    Folding: " + foldingTimer.elapsedMilliseconds)
        builder.append("\n    Inlining: " + inliningTimer.elapsedMilliseconds)
      }
      if !emitTimer.isZero { builder.append("\n  Emit: " + emitTimer.elapsedMilliseconds) }

      # Sources
      var totalBytes = 0
      var totalLines = 0
      for source in outputs {
        totalBytes += source.contents.count
        totalLines += source.lineCount
      }
      builder.append("\nOutputs: " + outputs.count.toString + " file" + PrettyPrint.plural(outputs.count) +
        " (" + bytesToString(totalBytes) + ", " + totalLines.toString + " line" + PrettyPrint.plural(totalLines) + ")")
      for source in outputs {
        var lines = source.lineCount
        builder.append("\n  " + source.name + " (" + bytesToString(source.contents.count) + ", " + lines.toString + " line" + PrettyPrint.plural(lines) + ")")
      }

      return builder.toString
    }
  }

  def compile(log Log, options CompilerOptions, sources List<Source>) CompilerResult {
    var debug = false
    var result = CompilerResult.new
    result.totalTimer.start

    options.target.includeSources(sources)
    options.target.editOptions(options)
    sources.prepend(Source.new("<native>", NATIVE_LIBRARY))

    for source in sources {
      result.tokenizingTimer.start
      var tokens = tokenize(log, source)
      prepareTokens(tokens)
      result.tokenizingTimer.stop
      result.parsingTimer.start
      parseFile(log, tokens, result.global)
      result.parsingTimer.stop
    }

    # Merging pass, errors stop compilation
    if !log.hasErrors {
      mergingPass(log, result.global)

      # Resolving pass, errors stop compilation
      if !log.hasErrors {
        result.resolvingTimer.start
        resolvingPass(log, result.global, result.cache, options)
        result.resolvingTimer.stop
        if debug { verifyHierarchy(result.global) }

        # Prepare for emission, code is error-free at this point
        if !log.hasErrors {
          if options.target.runPostResolvePasses {
            result.optimizingTimer.start

            result.callGraphTimer.start
            var graph = CallGraph.new(result.global)
            result.callGraphTimer.stop

            # Make certain functions global
            result.globalizeTimer.start
            globalizingPass(result.global, graph, options)
            result.globalizeTimer.stop
            if debug { verifyHierarchy(result.global) }

            # Move symbols around
            result.motionTimer.start
            motionPass(result.global, options)
            result.motionTimer.stop
            if debug { verifyHierarchy(result.global) }

            # Give overloaded functions unique names, rename operator overloads
            result.renamingTimer.start
            renamingPass(result.global)
            result.renamingTimer.stop
            if debug { verifyHierarchy(result.global) }

            # Partial evaluation before inlining to make more functions inlineable by removing dead code
            if options.foldAllConstants {
              result.foldingTimer.start
              foldingPass(result.global, result.cache)
              result.foldingTimer.stop
              if debug { verifyHierarchy(result.global) }
            }

            # Function inlining
            if options.inlineAllFunctions {
              result.inliningTimer.start
              inliningPass(graph)
              result.inliningTimer.stop
              if debug { verifyHierarchy(result.global) }

              # Partial evaluation after inlining will simplify inlined expressions
              if options.foldAllConstants {
                result.foldingTimer.start
                foldingPass(result.global, result.cache)
                result.foldingTimer.stop
                if debug { verifyHierarchy(result.global) }
              }
            }

            result.optimizingTimer.stop
          }

          # Emit in the target language
          var emitter = options.target.createEmitter(options, result.cache)
          if emitter != null {
            result.emitTimer.start
            emitter.visit(result.global)
            result.emitTimer.stop
            result.outputs = emitter.sources
          }
        }
      }
    }

    result.totalTimer.stop
    return result
  }

  def verifyHierarchy(symbol ObjectSymbol) {
    for object in symbol.objects {
      verifyHierarchy(object)
    }

    for function in symbol.functions {
      verifyHierarchy(function.block, null)
    }

    for variable in symbol.variables {
      verifyHierarchy(variable.value, null)
    }
  }

  def verifyHierarchy(node Node, parent Node) {
    if node != null {
      assert(node.parent == parent)
      if node.children != null {
        for child in node.children {
          verifyHierarchy(child, node)
        }
      }
    }
  }
}
