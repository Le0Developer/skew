namespace Skew {
  enum CompilerTarget {
    NONE
    JAVASCRIPT
    LISP_TREE

    def isTree bool {
      return self == LISP_TREE
    }
  }

  class Define {
    const name Range
    const value Range
  }

  class CompilerOptions {
    var defines StringMap<Define> = {}
    var foldAllConstants = false
    var globalizeAllFunctions = false
    var inlineAllFunctions = false
    var jsMangle = false
    var jsMinify = false
    var outputDirectory = ""
    var outputFile = ""
    var target CompilerTarget = .NONE

    def define(name string, value string) {
      var range = Source.new("<internal>", "--define:" + name + "=" + value).entireRange
      defines[name] = Define.new(range.slice(9, 9 + name.count), range.fromEnd(value.count))
    }
  }

  class CompilerResult {
    var cache = TypeCache.new
    var global = ObjectSymbol.new(.OBJECT_GLOBAL, "<global>")
    var outputs List<Source> = null
    var totalTime = 0.0
  }

  def compile(log Log, options CompilerOptions, sources List<Source>) CompilerResult {
    var start = Timestamp.seconds
    var debug = !RELEASE
    var result = CompilerResult.new

    switch options.target {
      case .JAVASCRIPT {
        sources.prepend(Source.new("<native-js>", NATIVE_LIBRARY_JS))
        options.define("TARGET", "JAVASCRIPT")
      }
    }

    sources.prepend(Source.new("<native>", NATIVE_LIBRARY))

    for source in sources {
      var tokens = tokenize(log, source)
      prepareTokens(tokens)
      parseFile(log, tokens, result.global)
    }

    # Merging pass, errors stop compilation
    if !log.hasErrors {
      mergingPass(log, result.global)

      # Resolving pass, errors stop compilation
      if !log.hasErrors {
        resolvingPass(log, result.global, result.cache, options)
        if debug {
          verifyHierarchy(result.global)
        }

        # Prepare for emission, code is error-free at this point
        if !log.hasErrors && options.target != .NONE {
          if !options.target.isTree {
            var graph = CallGraph.new(result.global)

            # Make certain functions global
            globalizingPass(result.global, graph, options)
            if debug {
              verifyHierarchy(result.global)
            }

            # Move symbols around
            motionPass(result.global, graph)
            if debug {
              verifyHierarchy(result.global)
            }

            # Give overloaded functions unique names, rename operator overloads
            renamingPass(result.global)
            if debug {
              verifyHierarchy(result.global)
            }

            # Partial evaluation before inlining to make more functions inlineable by removing dead code
            if options.foldAllConstants {
              foldingPass(result.global, result.cache)
              if debug {
                verifyHierarchy(result.global)
              }
            }

            # Function inlining
            if options.inlineAllFunctions {
              inliningPass(graph)
              if debug {
                verifyHierarchy(result.global)
              }

              # Partial evaluation after inlining will simplify inlined expressions
              if options.foldAllConstants {
                foldingPass(result.global, result.cache)
                if debug {
                  verifyHierarchy(result.global)
                }
              }
            }
          }

          # Emit in the target language
          var emitter Emitter = null
          switch options.target {
            case .JAVASCRIPT { emitter = JsEmitter.new(options, result.cache) }
            case .LISP_TREE { emitter = LispTreeEmitter.new(options) }
          }
          if emitter != null {
            emitter.visit(result.global)
            result.outputs = emitter.sources
          }
        }
      }
    }

    result.totalTime = Timestamp.seconds - start
    return result
  }

  def verifyHierarchy(symbol ObjectSymbol) {
    for object in symbol.objects {
      verifyHierarchy(object)
    }

    for function in symbol.functions {
      verifyHierarchy(function.block, null)
    }

    for variable in symbol.variables {
      verifyHierarchy(variable.value, null)
    }
  }

  def verifyHierarchy(node Node, parent Node) {
    if node != null {
      assert(node.parent == parent)
      if node.children != null {
        for child in node.children {
          verifyHierarchy(child, node)
        }
      }
    }
  }
}
