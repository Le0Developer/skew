namespace skew {
  enum TypeKind {
    DYNAMIC
    LAMBDA
    NULL
    SYMBOL
  }

  class Type {
    final int id

    new() : id = createID() {
    }

    static Type DYNAMIC
    static Type NULL

    virtual TypeKind kind()
    virtual string toString()

    SymbolType asSymbolType() {
      assert kind() == .SYMBOL
      return (SymbolType)this
    }

    LambdaType asLambdaType() {
      assert kind() == .LAMBDA
      return (LambdaType)this
    }

    bool isReference() {
      if (kind() != .SYMBOL) {
        return true
      }

      // Type parameters are not guaranteed to be nullable since generics are
      // implemented through type erasure and the substituted type may be "int"
      var symbol = asSymbolType().symbol
      return !symbol.isValueType() && symbol.kind != .PARAMETER
    }

    bool hasParameters() {
      return typeParameters() != null
    }

    virtual List<ParameterSymbol> typeParameters() {
      return null
    }

    virtual bool isParameterized() {
      return false
    }

    static void intialize() {
      if (DYNAMIC == null) {
        DYNAMIC = SpecialType(.DYNAMIC)
      }
      if (NULL == null) {
        NULL = SpecialType(.NULL)
      }
    }

    private static {
      int createID() {
        nextID++
        return nextID
      }

      int nextID = 0
    }
  }

  class SpecialType : Type {
    private final TypeKind specialKind

    override TypeKind kind() {
      return specialKind
    }

    override string toString() {
      return specialKind == .DYNAMIC ? "dynamic" : "null"
    }
  }

  class SymbolType : Type {
    // This must not be changed because that would change the hash code
    final Symbol symbol

    // Types that have been substituted for the type parameters of this symbol.
    // If non-null, the length must equal symbol.parameters.size().
    List<Type> substitutions = null

    // Generics are implemented with type erasure. Classes, interfaces, and
    // functions can all have type parameters. Every generic symbol has one
    // canonical unparameterized SymbolType stored as its resolvedType. When
    // this type is parameterized, a new SymbolType is created that references
    // the same symbol but contains the parameterization type environment.
    //
    // This maps the members of this TypeSymbol to the parameterized type of
    // that member. The "members" of a FunctionSymbol are just the argument
    // variables.
    IntMap<Type> cache = null

    override TypeKind kind() {
      return .SYMBOL
    }

    override string toString() {
      if (substitutions != null) {
        assert symbol.typeParameters().size() == substitutions.size()
        var name = symbol.name + "<"
        for (var i = 0; i < substitutions.size(); i++) {
          if (i != 0) {
            name += ", "
          }
          name += substitutions[i]
        }
        return name + ">"
      }
      return symbol.name
    }

    override List<ParameterSymbol> typeParameters() {
      return symbol.typeParameters()
    }

    override bool isParameterized() {
      return substitutions != null
    }
  }

  class LambdaType : Type {
    // These must not be changed because that would change the hash code
    final List<Type> argumentTypes
    final Type returnType

    override TypeKind kind() {
      return .LAMBDA
    }

    override string toString() {
      var result = "fn("
      for (var i = 0; i < argumentTypes.size(); i++) {
        if (i != 0) {
          result += ", "
        }
        result += argumentTypes[i]
      }
      return result + (returnType != null ? ") " + returnType : ")")
    }
  }

  class TypeCache {
    SymbolType boolType = null
    SymbolType doubleType = null
    SymbolType intType = null
    SymbolType stringType = null

    new() {
      Type.intialize()
    }

    void loadGlobals(Log log, TypeSymbol global) {
      boolType = loadGlobalClass(log, global, "bool", .VALUE_TYPE)
      doubleType = loadGlobalClass(log, global, "double", .VALUE_TYPE)
      intType = loadGlobalClass(log, global, "int", .VALUE_TYPE)
      stringType = loadGlobalClass(log, global, "string", .VALUE_TYPE)
    }

    bool canImplicitlyConvert(Type from, Type to) {
      if (from == to) return true
      if (from == .NULL && to.isReference()) return true
      if (from == intType && to == doubleType) return true
      // if (from.hasBaseType(to)) return true
      return false
    }

    bool canExplicitlyConvert(Type from, Type to) {
      if (canImplicitlyConvert(from, to)) return true
      if (canCastToNumeric(from) && canCastToNumeric(to)) return true
      // if (to.hasBaseType(from)) return true
      return false
    }

    LambdaType createLambdaType(List<Type> argumentTypes, Type returnType) {
      var hash = hashTypes(returnType != null ? returnType.id : -1, argumentTypes)
      var bucket = lambdaTypes.getOrDefault(hash, null)

      // Check existing types in the bucket for a match
      if (bucket != null) {
        for (var i = 0; i < bucket.size(); i++) {
          var existing = bucket[i]
          if (areTypesEqual(argumentTypes, existing.argumentTypes) && returnType == existing.returnType) {
            return existing
          }
        }
      }

      // Make a new bucket
      else {
        bucket = []
        lambdaTypes[hash] = bucket
      }

      var type = LambdaType(argumentTypes, returnType)
      bucket.push(type)
      return type
    }

    SymbolType parameterize(SymbolType unparameterized, List<Type> substitutions) {
      assert unparameterized.symbol.typeParameters().size() == substitutions.size()
      assert unparameterized.substitutions == null

      // Hash the symbol along with all types
      var symbol = unparameterized.symbol
      var hash = hashTypes(symbol.id, substitutions)
      var bucket = symbolTypes.getOrDefault(hash, null)

      // Check existing types in the bucket for a match
      if (bucket != null) {
        for (var i = 0; i < bucket.size(); i++) {
          var existing = bucket[i]
          if (symbol == existing.symbol && areTypesEqual(substitutions, existing.substitutions)) {
            return existing
          }
        }
      }

      // Make a new bucket
      else {
        bucket = []
        symbolTypes[hash] = bucket
      }

      // We didn't find a match, so make the type for the first time
      var type = SymbolType(symbol)
      type.substitutions = substitutions
      bucket.push(type)
      return type
    }

    private {
      final var lambdaTypes = IntMap<List<LambdaType>>()
      final var symbolTypes = IntMap<List<SymbolType>>()

      bool canCastToNumeric(Type type) {
        return type == intType || type == doubleType || type == boolType
      }

      static SymbolType loadGlobalClass(Log log, TypeSymbol global, string name, SymbolFlags flags) {
        var symbol = global.members.getOrDefault(name, null)
        assert symbol != null
        assert symbol.kind == .TYPE_CLASS
        var type = SymbolType(symbol.asType())
        symbol.resolvedType = type
        symbol.flags |= flags
        return type
      }

      static bool areTypesEqual(List<Type> left, List<Type> right) {
        var n = left.size()
        if (n != right.size()) {
          return false
        }
        for (var i = 0; i < n; i++) {
          if (left[i] != right[i]) {
            return false
          }
        }
        return true
      }

      static int hashTypes(int hash, List<Type> types) {
        for (var i = 0; i < types.size(); i++) {
          hash = hashCombine(hash, types[i].id)
        }
        return hash
      }
    }
  }
}
