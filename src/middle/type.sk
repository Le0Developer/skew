namespace astral {
  enum TypeKind {
    DYNAMIC
    LAMBDA
    NULL
    SYMBOL
  }

  class Type {
    static var DYNAMIC = SpecialType(.DYNAMIC)
    static var NULL = SpecialType(.NULL)

    virtual TypeKind kind()
    virtual string toString()

    SymbolType asSymbolType() {
      assert kind() == .SYMBOL
      return (SymbolType)this
    }

    LambdaType asLambdaType() {
      assert kind() == .LAMBDA
      return (LambdaType)this
    }
  }

  class SpecialType : Type {
    TypeKind specialKind

    override TypeKind kind() {
      return specialKind
    }

    override string toString() {
      return specialKind == .DYNAMIC ? "dynamic" : "null"
    }
  }

  class SymbolType : Type {
    Symbol symbol

    override TypeKind kind() {
      return .SYMBOL
    }

    override string toString() {
      return symbol.fullName()
    }
  }

  class LambdaType : Type {
    List<Type> argumentTypes
    Type returnType

    override TypeKind kind() {
      return .LAMBDA
    }

    override string toString() {
      var result = "fn("
      for (var i = 0; i < argumentTypes.size(); i++) {
        if (i != 0) {
          result += ", "
        }
        result += argumentTypes[i]
      }
      return result + (returnType != null ? ") " + returnType : ")")
    }
  }

  class TypeCache {
    SymbolType boolType = null
    SymbolType doubleType = null
    SymbolType intType = null
    SymbolType stringType = null

    void loadGlobals(Log log, TypeSymbol global) {
      boolType = loadGlobalClass(log, global, "bool")
      doubleType = loadGlobalClass(log, global, "double")
      intType = loadGlobalClass(log, global, "int")
      stringType = loadGlobalClass(log, global, "string")
    }

    private static SymbolType loadGlobalClass(Log log, TypeSymbol global, string name) {
      var symbol = global.members.getOrDefault(name, null)
      assert symbol != null
      assert symbol.kind == .TYPE_CLASS
      var type = SymbolType(symbol.asType())
      symbol.resolvedType = type
      return type
    }
  }
}
