namespace skew {
  enum TypeKind {
    LAMBDA
    SPECIAL
    SYMBOL
  }

  class Type {
    final int id
    TypeKind kind
    Symbol symbol
    Environment environment = null
    List<Type> substitutions = null
    List<Type> argumentTypes = null
    Type returnType = null
    IntMap<Type> substitutionCache = null // Maps a type environment id to this type in that environment

    // TODO: The skewc compiler has a bug that makes this necessary, fix this
    new(TypeKind kind, Symbol symbol) : id = createID(), kind = kind, symbol = symbol {
    }

    static Type DYNAMIC
    static Type NULL

    List<ParameterSymbol> parameters() {
      return
        symbol == null ? null :
        symbol.kind.isObject() ? symbol.asObjectSymbol().parameters :
        symbol.kind.isFunction() ? symbol.asFunctionSymbol().parameters :
        null
    }

    bool isParameterized() {
      return substitutions != null
    }

    bool isClass() {
      return symbol != null && symbol.kind == .OBJECT_CLASS
    }

    // Type parameters are not guaranteed to be nullable since generics are
    // implemented through type erasure and the substituted type may be "int"
    bool isReference() {
      return symbol == null || !symbol.isValueType() && symbol.kind != .PARAMETER
    }

    string toString() {
      if (kind == .SYMBOL) {
        if (substitutions != null) {
          var name = symbol.name + "<"
          for (var i = 0; i < substitutions.size(); i++) {
            if (i != 0) {
              name += ", "
            }
            name += substitutions[i]
          }
          return name + ">"
        }
        return symbol.name
      }

      if (kind == .LAMBDA) {
        var result = "fn("
        for (var i = 0; i < argumentTypes.size(); i++) {
          if (i != 0) {
            result += ", "
          }
          result += argumentTypes[i]
        }
        return result + (returnType != null ? ") " + returnType : ")")
      }

      return this == DYNAMIC ? "dynamic" : "null"
    }

    Type baseClass() {
      if (isClass()) {
        var base = symbol.asObjectSymbol().base
        if (base != null) {
          return base.resolvedType
        }
      }
      return null
    }

    bool hasBaseType(Type type) {
      var base = baseClass()
      return base != null && (base == type || base.hasBaseType(type))
    }

    static void intialize() {
      if (DYNAMIC == null) {
        DYNAMIC = Type(.SPECIAL, null)
      }
      if (NULL == null) {
        NULL = Type(.SPECIAL, null)
      }
    }

    private static {
      int createID() {
        nextID++
        return nextID
      }

      int nextID = 0
    }
  }

  class Environment {
    final int id = createID()
    final List<ParameterSymbol> parameters
    final List<Type> substitutions
    final IntMap<Environment> mergeCache = null

    // This is just for debugging
    string toString() {
      var text = "("
      for (var i = 0; i < parameters.size(); i++) {
        if (i != 0) {
          text += ", "
        }
        text += parameters[i].name + " => " + substitutions[i]
      }
      return text + ")"
    }

    private static {
      int createID() {
        nextID++
        return nextID
      }

      int nextID = 0
    }
  }

  class TypeCache {
    Type boolType = null
    Type doubleType = null
    Type intMapType = null
    Type intType = null
    Type listType = null
    Type stringMapType = null
    Type stringType = null

    new() {
      Type.intialize()
    }

    void loadGlobals(Log log, ObjectSymbol global) {
      boolType = loadGlobalClass(log, global, "bool", .VALUE_TYPE)
      doubleType = loadGlobalClass(log, global, "double", .VALUE_TYPE)
      intMapType = loadGlobalClass(log, global, "IntMap", 0)
      intType = loadGlobalClass(log, global, "int", .VALUE_TYPE)
      listType = loadGlobalClass(log, global, "List", 0)
      stringMapType = loadGlobalClass(log, global, "StringMap", 0)
      stringType = loadGlobalClass(log, global, "string", .VALUE_TYPE)
    }

    bool isNumeric(Type type) {
      return type == intType || type == doubleType
    }

    bool isList(Type type) {
      return type.symbol == listType.symbol
    }

    bool canImplicitlyConvert(Type from, Type to) {
      if (from == to) return true
      if (from == .NULL && to.isReference()) return true
      if (from == intType && to == doubleType) return true
      if (from.hasBaseType(to)) return true
      return false
    }

    bool canExplicitlyConvert(Type from, Type to) {
      if (canImplicitlyConvert(from, to)) return true
      if (canCastToNumeric(from) && canCastToNumeric(to)) return true
      if (to.hasBaseType(from)) return true
      return false
    }

    Type commonImplicitType(Type left, Type right) {
      // Short-circuit early for identical types
      if (left == right) return left

      // Check implicit conversions
      if (canImplicitlyConvert(left, right)) return right
      if (canImplicitlyConvert(right, left)) return left

      // Implement common implicit types for numeric types
      if (isNumeric(left) && isNumeric(right)) {
        return left == intType && right == intType ? intType : doubleType
      }

      // Check for a common base class
      if (left.isClass() && right.isClass()) {
        return commonBaseClass(left, right)
      }

      return null
    }

    Type createListType(Type itemType) {
      return substitute(listType, createEnvironment(listType.parameters(), [itemType]))
    }

    Type createIntMapType(Type valueType) {
      return substitute(intMapType, createEnvironment(intMapType.parameters(), [valueType]))
    }

    Type createStringMapType(Type valueType) {
      return substitute(stringMapType, createEnvironment(stringMapType.parameters(), [valueType]))
    }

    Environment createEnvironment(List<ParameterSymbol> parameters, List<Type> substitutions) {
      assert parameters.size() == substitutions.size()

      // Hash the inputs
      var hash = hashTypes(hashParameters(parameters), substitutions)
      var bucket = environments.getOrDefault(hash, null)

      // Check existing environments in the bucket for a match
      if (bucket != null) {
        for (var i = 0; i < bucket.size(); i++) {
          var existing = bucket[i]
          if (parameters.isEqualTo(existing.parameters) && substitutions.isEqualTo(existing.substitutions)) {
            return existing
          }
        }
      }

      // Make a new bucket
      else {
        bucket = []
        environments[hash] = bucket
      }

      // Make a new environment
      var environment = Environment(parameters, substitutions)
      bucket.push(environment)
      return environment
    }

    Type createLambdaType(List<Type> argumentTypes, Type returnType) {
      var hash = hashTypes(returnType != null ? returnType.id : -1, argumentTypes)
      var bucket = lambdaTypes.getOrDefault(hash, null)

      // Check existing types in the bucket for a match
      if (bucket != null) {
        for (var i = 0; i < bucket.size(); i++) {
          var existing = bucket[i]
          if (argumentTypes.isEqualTo(existing.argumentTypes) && returnType == existing.returnType) {
            return existing
          }
        }
      }

      // Make a new bucket
      else {
        bucket = []
        lambdaTypes[hash] = bucket
      }

      // Make a new lambda type
      var type = Type(.LAMBDA, null)
      type.argumentTypes = argumentTypes
      type.returnType = returnType
      bucket.push(type)
      return type
    }

    Environment mergeEnvironments(Environment a, Environment b) {
      List<ParameterSymbol> parameters = a.parameters.clone()
      List<Type> substitutions = substituteAll(a.substitutions, b)
      for (var i = 0; i < b.parameters.size(); i++) {
        var parameter = b.parameters[i]
        var substitution = b.substitutions[i]
        var index = parameters.indexOf(parameter)
        if (index != -1) {
          substitutions[index] = substitution
        } else {
          parameters.push(parameter)
          substitutions.push(substitution)
        }
      }
      return createEnvironment(parameters, substitutions)
    }

    Type parameterize(Type type) {
      var parameters = type.parameters()
      if (parameters == null) {
        return type
      }
      assert !type.isParameterized()
      List<Type> substitutions = []
      for (var i = 0; i < parameters.size(); i++) {
        substitutions.push(parameters[i].resolvedType)
      }
      return substitute(type, createEnvironment(parameters, substitutions))
    }

    List<Type> substituteAll(List<Type> types, Environment environment) {
      List<Type> substitutions = []
      for (var i = 0; i < types.size(); i++) {
        substitutions.push(substitute(types[i], environment))
      }
      return substitutions
    }

    Type substitute(Type type, Environment environment) {
      var existing = type.environment
      if (environment == null || environment == existing) {
        return type
      }

      // Merge the type environments (this matters for nested generics)
      if (existing != null) {
        if (type.kind == .SYMBOL && type.symbol.kind.isFunctionOrOverloadedFunction()) {
          environment = mergeEnvironments(existing, environment)
        } else {
          environment = createEnvironment(existing.parameters, substituteAll(existing.substitutions, environment))
        }
      }

      // Check to see if this has been computed before
      var rootType = type.kind == .SYMBOL ? type.symbol.resolvedType : type
      if (rootType.substitutionCache == null) {
        rootType.substitutionCache = {}
      }
      var substituted = rootType.substitutionCache.getOrDefault(environment.id, null)
      if (substituted != null) {
        return substituted
      }
      substituted = type

      if (type.kind == .LAMBDA) {
        List<Type> argumentTypes = []
        Type returnType = null

        // Substitute function arguments
        for (var i = 0; i < type.argumentTypes.size(); i++) {
          argumentTypes.push(substitute(type.argumentTypes[i], environment))
        }

        // Substitute return type
        if (type.returnType != null) {
          returnType = substitute(type.returnType, environment)
        }

        substituted = createLambdaType(argumentTypes, returnType)
      }

      else if (type.kind == .SYMBOL) {
        var symbol = type.symbol

        // Parameters just need simple substitution
        if (symbol.kind == .PARAMETER) {
          var index = environment.parameters.indexOf(symbol.asParameterSymbol())
          if (index != -1) {
            substituted = environment.substitutions[index]
          }
        }

        // Symbols with type parameters are more complicated
        else {
          var parameters = type.parameters()

          // Don't need to substitute non-generic types
          if (parameters != null || symbol.kind.isFunction()) {
            substituted = Type(.SYMBOL, symbol)
            substituted.environment = environment

            // Generate type substitutions
            if (parameters != null) {
              var found = true
              for (var i = 0; found && i < parameters.size(); i++) {
                found = parameters[i] in environment.parameters
              }
              if (found) {
                substituted.substitutions = []
                for (var i = 0; i < parameters.size(); i++) {
                  substituted.substitutions.push(substitute(parameters[i].resolvedType, environment))
                }
              }
            }

            // Substitute function arguments
            if (type.argumentTypes != null) {
              substituted.argumentTypes = []
              for (var i = 0; i < type.argumentTypes.size(); i++) {
                substituted.argumentTypes.push(substitute(type.argumentTypes[i], environment))
              }
            }

            // Substitute return type
            if (type.returnType != null) {
              substituted.returnType = substitute(type.returnType, environment)
            }
          }
        }
      }

      rootType.substitutionCache[environment.id] = substituted
      return substituted
    }

    private {
      final var environments = IntMap<List<Environment>>()
      final var lambdaTypes = IntMap<List<Type>>()

      bool canCastToNumeric(Type type) {
        return type == intType || type == doubleType || type == boolType
      }

      static Type loadGlobalClass(Log log, ObjectSymbol global, string name, SymbolFlags flags) {
        var symbol = global.members.getOrDefault(name, null)
        assert symbol != null
        assert symbol.kind == .OBJECT_CLASS
        var type = Type(.SYMBOL, symbol.asObjectSymbol())
        symbol.resolvedType = type
        symbol.flags |= flags
        return type
      }

      static int hashParameters(List<ParameterSymbol> parameters) {
        var hash = 0
        for (var i = 0; i < parameters.size(); i++) {
          hash = hashCombine(hash, parameters[i].id)
        }
        return hash
      }

      static int hashTypes(int hash, List<Type> types) {
        for (var i = 0; i < types.size(); i++) {
          hash = hashCombine(hash, types[i].id)
        }
        return hash
      }

      static Type commonBaseClass(Type left, Type right) {
        for (var a = left; a != null; a = a.baseClass()) {
          for (var b = right; b != null; b = b.baseClass()) {
            if (a == b) {
              return a
            }
          }
        }
        return null
      }
    }
  }
}
