namespace skew {
  enum TypeKind {
    DYNAMIC
    LAMBDA
    NULL
    SYMBOL
  }

  class Type {
    final int id

    new() : id = createID() {
    }

    static Type DYNAMIC
    static Type NULL

    virtual TypeKind kind()
    virtual string toString()

    SymbolType asSymbolType() {
      assert kind() == .SYMBOL
      return (SymbolType)this
    }

    LambdaType asLambdaType() {
      assert kind() == .LAMBDA
      return (LambdaType)this
    }

    bool isReference() {
      if (kind() != .SYMBOL) {
        return true
      }

      // Type parameters are not guaranteed to be nullable since generics are
      // implemented through type erasure and the substituted type may be "int"
      var symbol = asSymbolType().symbol
      return !symbol.isValueType() && symbol.kind != .PARAMETER
    }

    static void intialize() {
      if (DYNAMIC == null) {
        DYNAMIC = SpecialType(.DYNAMIC)
      }
      if (NULL == null) {
        NULL = SpecialType(.NULL)
      }
    }

    private static {
      int createID() {
        nextID++
        return nextID
      }

      int nextID = 0
    }
  }

  class SpecialType : Type {
    private final TypeKind specialKind

    override TypeKind kind() {
      return specialKind
    }

    override string toString() {
      return specialKind == .DYNAMIC ? "dynamic" : "null"
    }
  }

  class SymbolType : Type {
    Symbol symbol

    override TypeKind kind() {
      return .SYMBOL
    }

    override string toString() {
      return symbol.fullName()
    }
  }

  class LambdaType : Type {
    List<Type> argumentTypes
    Type returnType

    override TypeKind kind() {
      return .LAMBDA
    }

    override string toString() {
      var result = "fn("
      for (var i = 0; i < argumentTypes.size(); i++) {
        if (i != 0) {
          result += ", "
        }
        result += argumentTypes[i]
      }
      return result + (returnType != null ? ") " + returnType : ")")
    }
  }

  class TypeCache {
    SymbolType boolType = null
    SymbolType doubleType = null
    SymbolType intType = null
    SymbolType stringType = null

    new() {
      Type.intialize()
    }

    void loadGlobals(Log log, TypeSymbol global) {
      boolType = loadGlobalClass(log, global, "bool", .VALUE_TYPE)
      doubleType = loadGlobalClass(log, global, "double", .VALUE_TYPE)
      intType = loadGlobalClass(log, global, "int", .VALUE_TYPE)
      stringType = loadGlobalClass(log, global, "string", .VALUE_TYPE)
    }

    bool canImplicitlyConvert(Type from, Type to) {
      if (from == to) return true
      if (from == .NULL && to.isReference()) return true
      if (from == intType && to == doubleType) return true
      // if (from.hasBaseType(to)) return true
      return false
    }

    bool canExplicitlyConvert(Type from, Type to) {
      if (canImplicitlyConvert(from, to)) return true
      if (canCastToNumeric(from) && canCastToNumeric(to)) return true
      // if (to.hasBaseType(from)) return true
      return false
    }

    LambdaType createLambdaType(List<Type> argumentTypes, Type returnType) {
      var hash = returnType != null ? returnType.id : -1
      for (var i = 0; i < argumentTypes.size(); i++) {
        hash = hashCombine(hash, argumentTypes[i].id)
      }
      var bucket = lambdaTypes.getOrDefault(hash, null)

      // Check existing types in the bucket for a match
      if (bucket != null) {
        for (var i = 0; i < bucket.size(); i++) {
          var existing = bucket[i]
          if (areTypeListsEqual(argumentTypes, existing.argumentTypes) && returnType == existing.returnType) {
            return existing
          }
        }
      }

      // Make a new bucket
      else {
        bucket = []
        lambdaTypes[hash] = bucket
      }

      var type = LambdaType(argumentTypes, returnType)
      bucket.push(type)
      return type
    }

    private {
      final var lambdaTypes = IntMap<List<LambdaType>>()

      bool canCastToNumeric(Type type) {
        return type == intType || type == doubleType || type == boolType
      }

      static SymbolType loadGlobalClass(Log log, TypeSymbol global, string name, SymbolFlags flags) {
        var symbol = global.members.getOrDefault(name, null)
        assert symbol != null
        assert symbol.kind == .TYPE_CLASS
        var type = SymbolType(symbol.asType())
        symbol.resolvedType = type
        symbol.flags |= flags
        return type
      }

      static bool areTypeListsEqual(List<Type> left, List<Type> right) {
        var n = left.size()
        if (n != right.size()) {
          return false
        }
        for (var i = 0; i < n; i++) {
          if (left[i] != right[i]) {
            return false
          }
        }
        return true
      }
    }
  }
}
