namespace skew {
  enum ScopeKind {
    FUNCTION
    LOCAL
    OBJECT
  }

  class Scope {
    Scope parent

    virtual ScopeKind kind()
    virtual Symbol find(string name)

    ObjectScope asObjectScope() {
      assert kind() == .OBJECT
      return (ObjectScope)this
    }

    FunctionScope asFunctionScope() {
      assert kind() == .FUNCTION
      return (FunctionScope)this
    }

    LocalScope asLocalScope() {
      assert kind() == .LOCAL
      return (LocalScope)this
    }

    FunctionScope findEnclosingFunctionOrLambda() {
      for (var scope = this; scope != null; scope = scope.parent) {
        if (scope.kind() == .FUNCTION) {
          return scope.asFunctionScope()
        }
      }
      return null
    }

    FunctionScope findEnclosingFunction() {
      for (var scope = this; scope != null; scope = scope.parent) {
        if (scope.kind() == .FUNCTION && scope.asFunctionScope().symbol.kind != .FUNCTION_LOCAL) {
          return scope.asFunctionScope()
        }
      }
      return null
    }

    LocalScope findEnclosingLoop() {
      for (var scope = this; scope != null && scope.kind() == .LOCAL; scope = scope.parent) {
        if (scope.asLocalScope().type == .LOOP) {
          return scope.asLocalScope()
        }
      }
      return null
    }
  }

  class ObjectScope : Scope {
    ObjectSymbol symbol

    override ScopeKind kind() {
      return .OBJECT
    }

    override Symbol find(string name) {
      for (var check = symbol; check != null; check = check.baseClass) {
        var result = check.members.getOrDefault(name, null)
        if (result != null) {
          return result
        }
      }
      return parent != null ? parent.find(name) : null
    }
  }

  class FunctionScope : Scope {
    FunctionSymbol symbol
    StringMap<ParameterSymbol> parameters = {}

    override ScopeKind kind() {
      return .FUNCTION
    }

    override Symbol find(string name) {
      var result = parameters.getOrDefault(name, null)
      return result != null ? result : parent != null ? parent.find(name) : null
    }
  }

  enum LocalType {
    LOOP
    NORMAL
  }

  class LocalScope : Scope {
    StringMap<VariableSymbol> locals = {}
    LocalType type

    override ScopeKind kind() {
      return .LOCAL
    }

    override Symbol find(string name) {
      var result = locals.getOrDefault(name, null)
      return result != null ? result : parent != null ? parent.find(name) : null
    }

    void define(VariableSymbol symbol, Log log) {
      symbol.scope = this

      // Check for duplicates
      var other = locals.getOrDefault(symbol.name, null)
      if (other != null) {
        log.semanticErrorDuplicateSymbol(symbol.range, symbol.name, other.range)
        return
      }

      // Check for shadowing
      for (var scope = parent; scope.kind() == .LOCAL; scope = scope.parent) {
        var other = scope.asLocalScope().locals.getOrDefault(symbol.name, null)
        if (other != null) {
          log.semanticErrorShadowedSymbol(symbol.range, symbol.name, other.range)
          return
        }
      }

      locals[symbol.name] = symbol
    }
  }
}
