namespace Skew {
  def renamingPass(global ObjectSymbol) {
    Renaming.renameObject(global)
    Renaming.useOverriddenNames(global) # Use a second pass to avoid ordering issues
  }
}

namespace Skew.Renaming {
  def renameObject(symbol ObjectSymbol) {
    for object in symbol.objects {
      renameObject(object)
    }

    for function in symbol.functions {
      if !function.isImportedOrExported && function.overridden == null {
        var scope = function.scope.parent
        var count = function.arguments.count

        if (count == 0 || count == 1 && function.kind == .FUNCTION_GLOBAL) && function.name in unaryPrefixes {
          function.name = scope.generateName(unaryPrefixes[function.name])
        }

        else if function.name in prefixes {
          function.name = scope.generateName(prefixes[function.name])
        }

        else if function.name != "" && function.name[0] == '@' {
          function.name = scope.generateName(function.name.slice(1))
        }

        else if isInvalidIdentifier(function.name) {
          function.name = scope.generateName(generateValidIdentifier(function.name))
        }

        else if function.overloaded != null && function.overloaded.symbols.count > 1 {
          function.name = scope.generateName(function.name)
        }
      }
    }
  }

  def useOverriddenNames(symbol ObjectSymbol) {
    for object in symbol.objects {
      useOverriddenNames(object)
    }

    for function in symbol.functions {
      if function.overridden != null {
        var overridden = function.overridden
        while overridden.overridden != null {
          overridden = overridden.overridden
        }
        function.name = overridden.name
      }
    }
  }

  def isAlpha(c int) bool {
    return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_'
  }

  def isNumber(c int) bool {
    return c >= '0' && c <= '9'
  }

  def isInvalidIdentifier(name string) bool {
    for i in 0..name.count {
      var c = name[i]
      if !isAlpha(c) && (i == 0 || !isNumber(c)) {
        return true
      }
    }
    return false
  }

  def generateValidIdentifier(name string) string {
    var text = ""
    for i in 0..name.count {
      var c = name[i]
      if isAlpha(c) || isNumber(c) {
        text += name.get(i)
      }
    }
    if name.endsWith("=") {
      return "set" + text.slice(0, 1).toUpperCase + text.slice(1)
    }
    return text == "" || !isAlpha(text[0]) ? "_" + text : text
  }

  const unaryPrefixes = {
    "!": "not",
    "+": "positive",
    "++": "increment",
    "-": "negative",
    "--": "decrement",
    "~": "complement",
  }

  const prefixes = {
    # Binary operators
    "%": "remainder",
    "&": "and",
    "*": "multiply",
    "**": "power",
    "+": "add",
    "-": "subtract",
    "/": "divide",
    "<<": "leftShift",
    "<=>": "compare",
    ">>": "rightShift",
    "^": "xor",
    "|": "or",
    "in": "contains",

    # Binary assignment operators
    "%=": "remainderUpdate",
    "&=": "andUpdate",
    "**=": "powerUpdate",
    "*=": "multiplyUpdate",
    "+=": "addUpdate",
    "-=": "subtractUpdate",
    "/=": "divideUpdate",
    "<<=": "leftShiftUpdate",
    ">>=": "rightShiftUpdate",
    "^=": "xorUpdate",
    "|=": "orUpdate",

    # Index operators
    "[]": "get",
    "[]=": "set",

    # Initializer operators
    "[...]": "append",
    "[new]": "new",
    "{...}": "insert",
    "{new}": "new",
  }
}
