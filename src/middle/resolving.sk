namespace astral {
  class ResolveContext {
    TypeCache cache
    Log log
    Symbol symbol

    ResolveContext withSymbol(Symbol other) {
      return ResolveContext(cache, log, other)
    }
  }

  void resolvingPass(Log log, TypeSymbol global) {
    var cache = TypeCache()
    cache.loadGlobals(log, global)
    if (!log.hasErrors()) {
      resolveType(ResolveContext(cache, log, null), global)
    }
  }

  void initializeSymbol(ResolveContext context, Symbol symbol) {
    // Only initialize the symbol once
    if (symbol.state == .UNINITIALIZED) {
      symbol.state = .INITIALIZING
      symbol.resolvedType = .DYNAMIC
      switch (symbol.kind) {
        case .TYPE_CLASS, .TYPE_GLOBAL, .TYPE_INTERFACE, .TYPE_NAMESPACE { initializeType(context, (TypeSymbol)symbol) }
        case .FUNCTION_CONSTRUCTOR, .FUNCTION_GLOBAL, .FUNCTION_INSTANCE, .FUNCTION_LOCAL { initializeFunction(context, (FunctionSymbol)symbol) }
        case .VARIABLE_GLOBAL, .VARIABLE_INSTANCE, .VARIABLE_LOCAL { initializeVariable(context, (VariableSymbol)symbol) }
        default { assert false }
      }
      symbol.state = .INITIALIZED
    }

    // Detect cyclic symbol references such as "foo foo;"
    else if (symbol.state == .INITIALIZING) {
      context.log.semanticErrorCyclicDeclaration(symbol.range, symbol.name)
      symbol.resolvedType = .DYNAMIC
    }
  }

  void initializeType(ResolveContext context, TypeSymbol symbol) {
    if (symbol.base != null) resolveNode(context, symbol.base)
  }

  void resolveType(ResolveContext context, TypeSymbol symbol) {
    initializeSymbol(context, symbol)
    var nested = context.withSymbol(symbol)
    for (var i = 0; i < symbol.types.size(); i++) resolveType(nested, symbol.types[i])
    for (var i = 0; i < symbol.funcs.size(); i++) resolveFunction(nested, symbol.funcs[i])
    for (var i = 0; i < symbol.vars.size(); i++) resolveVariable(nested, symbol.vars[i])
  }

  void initializeFunction(ResolveContext context, FunctionSymbol symbol) {
    for (var i = 0; i < symbol.arguments.size(); i++) resolveVariable(context, symbol.arguments[i])
    if (symbol.returnType != null) resolveNode(context, symbol.returnType)
    if (symbol.block != null) resolveNode(context, symbol.block)
  }

  void resolveFunction(ResolveContext context, FunctionSymbol symbol) {
    initializeSymbol(context, symbol)
    if (symbol.block != null) resolveNode(context, symbol.block)
  }

  void initializeVariable(ResolveContext context, VariableSymbol symbol) {
    if (symbol.type != null) resolveNode(context, symbol.type)
  }

  void resolveVariable(ResolveContext context, VariableSymbol symbol) {
    initializeSymbol(context, symbol)
    if (symbol.value != null) resolveNode(context, symbol.value)
  }

  void resolveNode(ResolveContext context, Node node) {
    if (node.resolvedType != null) {
      return // Only resolve once
    }

    node.resolvedType = .DYNAMIC
    switch (node.kind) {
      case .BLOCK { resolveBlock(context, node) }

      case .BREAK {}
      case .CONTINUE {}
      case .EXPRESSION { resolveExpression(context, node) }
      case .IF { resolveIf(context, node) }
      case .RETURN { resolveReturn(context, node) }
      case .VAR {}
      case .WHILE { resolveWhile(context, node) }

      case .CALL { resolveCall(context, node) }
      case .CAST {}
      case .CONSTANT { resolveConstant(context, node) }
      case .DOT { resolveDot(context, node) }
      case .DYNAMIC {}
      case .HOOK { resolveHook(context, node) }
      case .LAMBDA {}
      case .LAMBDA_TYPE {}
      case .NAME { resolveName(context, node) }
      case .NULL { node.resolvedType = .NULL }
      case .PARAMETERIZE { resolveParameterize(context, node) }

      default {
        if (node.kind.isUnary()) { resolveUnary(context, node) }
        else if (node.kind.isBinary()) { resolveBinary(context, node) }
        else { assert false }
      }
    }
  }

  void resolveBlock(ResolveContext context, Node node) {
    for (var i = 0; i < node.children.size(); i++) {
      resolveNode(context, node.children[i])
    }
  }

  void resolveExpression(ResolveContext context, Node node) {
    resolveNode(context, node.expressionValue())
  }

  void resolveIf(ResolveContext context, Node node) {
    var ifFalse = node.ifFalse()
    resolveNode(context, node.ifTest())
    resolveNode(context, node.ifTrue())
    if (ifFalse != null) {
      resolveNode(context, ifFalse)
    }
  }

  void resolveReturn(ResolveContext context, Node node) {
    var value = node.returnValue()
    if (value != null) {
      resolveNode(context, value)
    }
  }

  void resolveWhile(ResolveContext context, Node node) {
    resolveNode(context, node.whileTest())
    resolveNode(context, node.whileBlock())
  }

  void resolveCall(ResolveContext context, Node node) {
    for (var i = 0; i < node.children.size(); i++) {
      resolveNode(context, node.children[i])
    }
  }

  void resolveConstant(ResolveContext context, Node node) {
    switch (node.content.kind()) {
      case .BOOL { node.resolvedType = context.cache.boolType }
      case .DOUBLE { node.resolvedType = context.cache.doubleType }
      case .INT { node.resolvedType = context.cache.intType }
      case .STRING { node.resolvedType = context.cache.stringType }
    }
  }

  void resolveDot(ResolveContext context, Node node) {
    var target = node.dotTarget()
    var name = node.asString()
    resolveNode(context, target)

    Symbol member = null
    if (target.resolvedType.kind == .DECL) {
      member = target.resolvedType.asSymbolType().symbol.members.getOrDefault(name, null)
    }

    if (member == null) {
      context.log.semanticErrorUnknownMemberSymbol(node.range, name, target.resolvedType)
      return
    }

    // node.resolvedType = member
  }

  void resolveHook(ResolveContext context, Node node) {
    resolveNode(context, node.hookTest())
    resolveNode(context, node.hookTrue())
    resolveNode(context, node.hookFalse())
  }

  void resolveName(ResolveContext context, Node node) {
    var name = node.asString()

    for (var symbol = context.symbol; symbol != null; symbol = symbol.parent) {
      if (symbol.kind.isType()) {
        node.symbol = symbol.asType().members.getOrDefault(name, null)
        if (node.symbol != null) {
          break
        }
      }
    }

    if (node.symbol == null) {
      context.log.semanticErrorUndeclaredSymbol(node.range, name)
      return
    }

    if (node.symbol.state != .INITIALIZED) {
      initializeSymbol(context.withSymbol(node.symbol.parent), node.symbol)
    }

    node.resolvedType = node.symbol.resolvedType
  }

  void resolveParameterize(ResolveContext context, Node node) {
    for (var i = 0; i < node.children.size(); i++) {
      resolveNode(context, node.children[i])
    }
  }

  void resolveUnary(ResolveContext context, Node node) {
    var value = node.unaryValue()
    resolveNode(context, value)
  }

  void resolveBinary(ResolveContext context, Node node) {
    var left = node.binaryLeft()
    var right = node.binaryRight()
    resolveNode(context, left)
    resolveNode(context, right)
  }
}
