namespace skew {
  using skew.resolving

  void resolvingPass(Log log, ObjectSymbol global) {
    var cache = TypeCache()
    cache.loadGlobals(log, global)
    if (!log.hasErrors()) {
      Resolver(cache, log).resolveObject(global)
    }
  }
}

namespace skew.resolving {
  enum ConversionKind {
    IMPLICIT
    EXPLICIT
  }

  enum FailureMode {
    SILENT_FAILURE
    ERROR_FAILURE
  }

  class Resolver {
    TypeCache cache
    Log log

    void initializeSymbol(Symbol symbol) {
      // The scope should have been set by the merging pass (or by this pass for local variables)
      assert symbol.scope != null

      // Only initialize the symbol once
      if (symbol.state == .UNINITIALIZED) {
        symbol.state = .INITIALIZING

        switch (symbol.kind) {
          case .OBJECT_CLASS, .OBJECT_GLOBAL, .OBJECT_INTERFACE, .OBJECT_NAMESPACE {
            initializeObject(symbol.asObjectSymbol())
          }

          case .FUNCTION_CONSTRUCTOR, .FUNCTION_GLOBAL, .FUNCTION_INSTANCE, .FUNCTION_LOCAL {
            initializeFunction(symbol.asFunctionSymbol())
          }

          case .VARIABLE_GLOBAL, .VARIABLE_INSTANCE, .VARIABLE_LOCAL {
            initializeVariable(symbol.asVariableSymbol())
          }

          case .PARAMETER {
            initializeParameter(symbol.asParameterSymbol())
          }

          case .OVERLOADED_GLOBAL, .OVERLOADED_INSTANCE {
            initializeOverloadedFunction(symbol.asOverloadedFunctionSymbol())
          }

          default {
            assert false
          }
        }

        assert symbol.resolvedType != null
        symbol.state = .INITIALIZED
      }

      // Detect cyclic symbol references such as "foo foo;"
      else if (symbol.state == .INITIALIZING) {
        log.semanticErrorCyclicDeclaration(symbol.range, symbol.name)
        symbol.resolvedType = .DYNAMIC
      }
    }

    void resolveParameters(List<ParameterSymbol> parameters) {
      if (parameters != null) {
        for (var i = 0; i < parameters.size(); i++) {
          resolveParameter(parameters[i])
        }
      }
    }

    void initializeParameter(ParameterSymbol symbol) {
      if (symbol.resolvedType == null) {
        symbol.resolvedType = Type(.SYMBOL, symbol)
      }
    }

    void resolveParameter(ParameterSymbol symbol) {
      initializeSymbol(symbol)
    }

    void initializeObject(ObjectSymbol symbol) {
      if (symbol.resolvedType == null) {
        symbol.resolvedType = Type(.SYMBOL, symbol)
      }

      // Resolve the base type (only for classes)
      if (symbol.base != null) {
        resolveAsParameterizedType(symbol.base, symbol.scope)
      }
    }

    void resolveObject(ObjectSymbol symbol) {
      initializeSymbol(symbol)
      resolveParameters(symbol.parameters)

      for (var i = 0; i < symbol.objects.size(); i++) {
        resolveObject(symbol.objects[i])
      }

      for (var i = 0; i < symbol.functions.size(); i++) {
        resolveFunction(symbol.functions[i])
      }

      for (var i = 0; i < symbol.variables.size(); i++) {
        resolveVariable(symbol.variables[i])
      }
    }

    void initializeFunction(FunctionSymbol symbol) {
      if (symbol.resolvedType == null) {
        symbol.resolvedType = Type(.SYMBOL, symbol)
      }

      resolveParameters(symbol.parameters)

      // Resolve the argument variables
      symbol.resolvedType.argumentTypes = []
      for (var i = 0; i < symbol.arguments.size(); i++) {
        var argument = symbol.arguments[i]
        argument.scope = symbol.scope
        resolveVariable(argument)
        symbol.resolvedType.argumentTypes.push(argument.resolvedType)
      }

      // Resolve the return type if present (no return type means "void")
      if (symbol.returnType != null) {
        if (symbol.kind == .FUNCTION_CONSTRUCTOR) {
          log.semanticErrorConstructorReturnType(symbol.returnType.range)
        } else {
          resolveAsParameterizedType(symbol.returnType, symbol.scope)
          symbol.resolvedType.returnType = symbol.returnType.resolvedType
        }
      }

      // Constructors always return the type they construct
      if (symbol.kind == .FUNCTION_CONSTRUCTOR) {
        symbol.resolvedType.returnType = cache.parameterize(symbol.parent.resolvedType)
      }

      // Setters must have one argument
      if (symbol.isSetter() && symbol.arguments.size() != 1) {
        log.semanticErrorSetterWrongArgumentCount(symbol.range, symbol.name)
        symbol.flags &= ~.SETTER
      }
    }

    void resolveFunction(FunctionSymbol symbol) {
      initializeSymbol(symbol)

      var scope = LocalScope(symbol.scope)

      // Referencing a normal variable instead of a special node kind for "this"
      // makes many things much easier including lambda capture and devirtualization
      if (symbol.kind == .FUNCTION_INSTANCE || symbol.kind == .FUNCTION_CONSTRUCTOR) {
        symbol.self = VariableSymbol(.VARIABLE_LOCAL, "self")
        symbol.self.resolvedType = symbol.parent.resolvedType
        symbol.self.state = .INITIALIZED
        scope.define(symbol.self, log)
      }

      // Default values for argument variables aren't resolved with this local
      // scope since they are evaluated at the call site, not inside the
      // function body, and shouldn't have access to other arguments
      for (var i = 0; i < symbol.arguments.size(); i++) {
        scope.define(symbol.arguments[i], log)
      }

      // The function is considered abstract if the body is missing
      if (symbol.block != null) {
        resolveNode(symbol.block, scope, null)

        // Missing a return statement is an error
        if (symbol.kind != .FUNCTION_CONSTRUCTOR) {
          var returnType = symbol.resolvedType.returnType
          if (returnType != null && returnType != .DYNAMIC && !symbol.block.blockAlwaysEndsWithReturn()) {
            log.semanticErrorMissingReturn(symbol.range, symbol.name, returnType)
          }
        }
      }
    }

    void initializeVariable(VariableSymbol symbol) {
      if (symbol.type != null) {
        resolveAsParameterizedType(symbol.type, symbol.scope)
        symbol.resolvedType = symbol.type.resolvedType
      }

      // Implicitly-typed variables take their type from their initializer
      else if (symbol.value != null) {
        resolveAsParameterizedExpression(symbol.value, symbol.scope)
        var type = symbol.value.resolvedType
        symbol.resolvedType = type

        // Forbid certain types
        if (!isValidVariableType(type)) {
          log.semanticErrorBadVariableType(symbol.range, type)
          symbol.resolvedType = .DYNAMIC
        }
      }

      // Use a different error for lambda arguments which cannot have an initializer
      else if (symbol.scope.kind() == .FUNCTION && symbol.scope.asFunctionScope().symbol.kind == .FUNCTION_LOCAL) {
        log.semanticErrorVarMissingType(symbol.range, symbol.name)
        symbol.resolvedType = .DYNAMIC
      }

      // Variables without a type are an error
      else {
        log.semanticErrorVarMissingValue(symbol.range)
        symbol.resolvedType = .DYNAMIC
      }
    }

    void resolveVariable(VariableSymbol symbol) {
      initializeSymbol(symbol)

      if (symbol.value != null) {
        resolveAsParameterizedExpressionWithConversion(symbol.value, symbol.scope, symbol.resolvedType)
      }

      // Default-initialize varliables that aren't explicitly initialized
      else if (symbol.kind != .VARIABLE_LOCAL) {
        symbol.value = defaultValueForType(symbol.resolvedType)
      }
    }

    void initializeOverloadedFunction(OverloadedFunctionSymbol symbol) {
      var symbols = symbol.symbols

      if (symbol.resolvedType == null) {
        symbol.resolvedType = Type(.SYMBOL, symbol)
      }

      // Ensure each overload has a valid type
      for (var i = 0; i < symbols.size(); i++) {
        initializeSymbol(symbols[i])
      }
    }

    void resolveNode(Node node, Scope scope, Type context) {
      if (node.resolvedType != null) {
        return // Only resolve once
      }

      node.resolvedType = .DYNAMIC
      switch (node.kind) {
        case .BLOCK { resolveBlock(node, scope) }

        // Statements
        case .BREAK {}
        case .CONTINUE {}
        case .EXPRESSION { resolveExpression(node, scope) }
        case .IF { resolveIf(node, scope) }
        case .IMPLICIT_RETURN, .RETURN { resolveReturn(node, scope) }
        case .VAR { resolveVar(node, scope) }
        case .WHILE { resolveWhile(node, scope) }

        // Expressions
        case .ASSIGN_INDEX { resolveIndex(node, scope) }
        case .CALL { resolveCall(node, scope) }
        case .CAST { resolveCast(node, scope) }
        case .CONSTANT { resolveConstant(node, scope) }
        case .DOT { resolveDot(node, scope) }
        case .DYNAMIC {}
        case .HOOK { resolveHook(node, scope) }
        case .INDEX { resolveIndex(node, scope) }
        case .LAMBDA { resolveLambda(node, scope, context) }
        case .LAMBDA_TYPE { resolveLambdaType(node, scope) }
        case .NAME { resolveName(node, scope) }
        case .NULL { node.resolvedType = .NULL }
        case .PARAMETERIZE { resolveParameterize(node, scope) }

        default {
          if (node.kind.isUnary()) { resolveUnary(node, scope) }
          else if (node.kind.isBinary()) { resolveBinary(node, scope) }
          else { assert false }
        }
      }

      assert node.resolvedType != null
    }

    void resolveAsParameterizedType(Node node, Scope scope) {
      assert node.kind.isExpression()
      resolveNode(node, scope, null)
      checkIsType(node)
      checkIsParameterized(node)
    }

    void resolveAsParameterizedExpression(Node node, Scope scope) {
      assert node.kind.isExpression()
      resolveNode(node, scope, null)
      checkIsInstance(node)
      checkIsParameterized(node)
    }

    void resolveAsParameterizedExpressionWithTypeContext(Node node, Scope scope, Type type) {
      assert node.kind.isExpression()
      resolveNode(node, scope, type)
      checkIsInstance(node)
      checkIsParameterized(node)
    }

    void resolveAsParameterizedExpressionWithConversion(Node node, Scope scope, Type type) {
      resolveAsParameterizedExpressionWithTypeContext(node, scope, type)
      checkConversion(node, type, .IMPLICIT)
    }

    void checkUnusedExpression(Node node) {
      var kind = node.kind
      if (kind == .HOOK) {
        checkUnusedExpression(node.hookTrue())
        checkUnusedExpression(node.hookFalse())
      } else if (node.range != null && node.resolvedType != .DYNAMIC && kind != .CALL && !kind.isBinaryAssign()) {
        log.semanticWarningUnusedExpression(node.range)
      }
    }

    void checkIsInstance(Node node) {
      if (node.resolvedType != .DYNAMIC && node.isType()) {
        log.semanticErrorUnexpectedType(node.range, node.resolvedType)
        node.resolvedType = .DYNAMIC
      }
    }

    void checkIsType(Node node) {
      if (node.resolvedType != .DYNAMIC && !node.isType()) {
        log.semanticErrorUnexpectedExpression(node.range, node.resolvedType)
        node.resolvedType = .DYNAMIC
      }
    }

    void checkIsParameterized(Node node) {
      if (node.resolvedType.parameters() != null && !node.resolvedType.isParameterized()) {
        log.semanticErrorUnparameterizedType(node.range, node.resolvedType)
        node.resolvedType = .DYNAMIC
      }
    }

    void checkStorage(Node node) {
      if (node.kind != .NAME && node.kind != .DOT || node.symbol != null && !node.symbol.kind.isVariable()) {
        log.semanticErrorBadStorage(node.range)
      }
    }

    void checkConversion(Node node, Type to, ConversionKind kind) {
      var from = node.resolvedType
      assert from != null
      assert to != null

      // The "dynamic" type is a hole in the type system
      if (from == .DYNAMIC || to == .DYNAMIC) {
        return
      }

      // No conversion is needed for identical types
      if (from == to) {
        return
      }

      // The implicit conversion must be valid
      if (kind == .IMPLICIT && !cache.canImplicitlyConvert(from, to) ||
          kind == .EXPLICIT && !cache.canExplicitlyConvert(from, to)) {
        log.semanticErrorIncompatibleTypes(node.range, from, to, cache.canExplicitlyConvert(from, to))
        node.resolvedType = .DYNAMIC
        return
      }

      // Make the implicit conversion explicit for convenience later on
      if (kind == .IMPLICIT) {
        var value = Node.createNull()
        value.become(node)
        node.become(Node.createCast(value, Node.createType(to)).withType(to).withRange(node.range))
      }
    }

    void resolveBlock(Node node, Scope scope) {
      assert node.kind == .BLOCK

      // Introduce a new scope for nested blocks
      if (node.parent != null) {
        scope = LocalScope(scope)
      }

      var children = node.children
      var n = children.size()

      for (var i = 0; i < n; i++) {
        var child = children[i]

        // There is a well-known ambiguity in languages like JavaScript where
        // a return statement followed by a newline and a value can either be
        // parsed as a single return statement with a value or as two
        // statements, a return statement without a value and an expression
        // statement. Luckily, we're better off than JavaScript since we know
        // the type of the function. Parse a single statement in a non-void
        // function but two statements in a void function.
        if (child.kind == .RETURN && i + 1 < n && child.returnValue() == null && children[i + 1].kind == .EXPRESSION) {
          var function = scope.findEnclosingFunction().symbol
          if (function.kind != .FUNCTION_CONSTRUCTOR && function.resolvedType.returnType != null) {
            child.replaceChild(0, node.removeChildAtIndex(i + 1).expressionValue().replaceWithNull())
            n--
          }
        }

        resolveNode(child, scope, null)
      }
    }

    void resolveExpression(Node node, Scope scope) {
      var value = node.expressionValue()
      resolveAsParameterizedExpression(value, scope)
      checkUnusedExpression(value)
    }

    void resolveIf(Node node, Scope scope) {
      var ifFalse = node.ifFalse()
      resolveAsParameterizedExpressionWithConversion(node.ifTest(), scope, cache.boolType)
      resolveBlock(node.ifTrue(), scope)
      if (ifFalse != null) {
        resolveBlock(ifFalse, scope)
      }
    }

    void resolveReturn(Node node, Scope scope) {
      var value = node.returnValue()
      var function = scope.findEnclosingFunction().symbol
      var returnType = function.kind != .FUNCTION_CONSTRUCTOR ? function.resolvedType.returnType : null

      // Check for a returned value
      if (value == null) {
        if (returnType != null) {
          log.semanticErrorExpectedReturnValue(node.range, returnType)
        }
        return
      }

      // Check the type of the returned value
      if (returnType != null) {
        resolveAsParameterizedExpressionWithConversion(value, scope, returnType)
        return
      }

      // If there's no return type, still check for other errors
      resolveAsParameterizedExpression(value, scope)

      // Lambdas without a return type or an explicit "return" statement get special treatment
      if (node.kind != .IMPLICIT_RETURN) {
        log.semanticErrorUnexpectedReturnValue(value.range)
        return
      }

      // Check for a return value of type "void"
      if (!function.shouldInferReturnType() || value.kind == .CALL && value.symbol != null && value.symbol.resolvedType.returnType == null) {
        checkUnusedExpression(value)
        node.kind = .EXPRESSION
        return
      }

      // Check for an invalid return type
      var type = value.resolvedType
      if (!isValidVariableType(type)) {
        log.semanticErrorBadReturnType(value.range, type)
        node.kind = .EXPRESSION
        return
      }

      // Mutate the return type to the type from the returned value
      function.returnType = Node.createType(type)
    }

    void resolveVar(Node node, Scope scope) {
      var symbol = node.symbol.asVariableSymbol()
      scope.asLocalScope().define(symbol, log)
      resolveVariable(symbol)
    }

    void resolveWhile(Node node, Scope scope) {
      resolveAsParameterizedExpressionWithConversion(node.whileTest(), scope, cache.boolType)
      resolveBlock(node.whileBlock(), scope)
    }

    void resolveCall(Node node, Scope scope) {
      var value = node.callValue()
      resolveAsParameterizedExpression(value, scope)
      var type = value.resolvedType

      switch (type.kind) {
        // Each function has its own type for simplicity
        case .SYMBOL {
          if (resolveSymbolCall(node, scope, type)) {
            return
          }
        }

        // Lambda types look like "fn(int, int) int"
        case .LAMBDA {
          if (resolveLambdaCall(node, scope, type)) {
            return
          }
        }

        // Can't call other types (the null type, for example)
        default {
          if (type != .DYNAMIC) {
            log.semanticErrorInvalidCall(node.internalRange, value.resolvedType)
          }
        }
      }

      // If there was an error, resolve the arguments to check for further
      // errors but use a dynamic type context to avoid introducing errors
      for (var i = 1; i < node.children.size(); i++) {
        resolveAsParameterizedExpressionWithConversion(node.children[i], scope, .DYNAMIC)
      }
    }

    bool resolveSymbolCall(Node node, Scope scope, Type type) {
      var symbol = type.symbol
      var parent = node.parent

      // Getters are called implicitly, so explicitly calling one is an error.
      // This error prevents a getter returning a lambda which is then called,
      // but that's really strange and I think this error is more useful.
      if (symbol.isGetter() && parent != null && parent.kind == .CALL && node == parent.callValue()) {
        log.semanticErrorGetterCalledTwice(parent.internalRange, symbol.name)
        return false
      }

      // Check for calling a function directly
      if (symbol.kind.isFunction()) {
        return resolveFunctionCall(node, scope, type)
      }

      // Check for calling a set of functions, must not be ambiguous
      if (symbol.kind.isOverloadedFunction()) {
        return resolveOverloadedFunctionCall(node, scope, symbol.asOverloadedFunctionSymbol())
      }

      // Can't call other symbols
      log.semanticErrorInvalidCall(node.internalRange, node.callValue().resolvedType)
      return false
    }

    bool resolveFunctionCall(Node node, Scope scope, Type type) {
      var function = type.symbol.asFunctionSymbol()
      var expected = type.argumentTypes.size()
      var count = node.children.size() - 1
      node.symbol = function

      // Use the return type even if there were errors
      if (type.returnType != null) {
        node.resolvedType = type.returnType
      }

      // There is no "void" type, so make sure this return value isn't used
      else if (isVoidExpressionUsed(node)) {
        log.semanticErrorUseOfVoidFunction(node.range, function.name)
      }

      // Check argument count
      if (expected != count) {
        log.semanticErrorArgumentCount(node.internalRange, expected, count)
        return false
      }

      // Check argument types
      for (var i = 0; i < count; i++) {
        resolveAsParameterizedExpressionWithConversion(node.children[i + 1], scope, type.argumentTypes[i])
      }

      return true
    }

    bool resolveOverloadedFunctionCall(Node node, Scope scope, OverloadedFunctionSymbol overloaded) {
      var count = node.children.size() - 1
      List<FunctionSymbol> candidates = []

      // Filter by argument length
      for (var i = 0; i < overloaded.symbols.size(); i++) {
        var overload = overloaded.symbols[i]
        if (overload.arguments.size() == count) {
          candidates.push(overload)
        }
      }

      // Check for matches
      if (candidates.size() < 1) {
        log.semanticErrorNoMatchingOverload(node.callValue().range, overloaded.name, count)
        return false
      }

      // Check for ambiguity
      if (candidates.size() > 1) {
        log.semanticErrorAmbiguousOperator(node.callValue().range, overloaded.name, count)
        return false
      }

      // Target is unambiguous
      return resolveFunctionCall(node, scope, candidates[0].resolvedType) // TODO: This doesn't work for generic types
    }

    bool resolveLambdaCall(Node node, Scope scope, Type type) {
      var expected = type.argumentTypes.size()
      var count = node.children.size() - 1

      // Use the return type even if there were errors
      if (type.returnType != null) {
        node.resolvedType = type.returnType
      }

      // There is no "void" type, so make sure this return value isn't used
      else if (isVoidExpressionUsed(node)) {
        log.semanticErrorUseOfVoidLambda(node.range)
      }

      // Check argument count
      if (expected != count) {
        log.semanticErrorArgumentCount(node.internalRange, expected, count)
        return false
      }

      // Check argument types
      for (var i = 0; i < count; i++) {
        resolveAsParameterizedExpressionWithConversion(node.children[i + 1], scope, type.argumentTypes[i])
      }

      return true
    }

    void resolveCast(Node node, Scope scope) {
      var value = node.castValue()
      var type = node.castType()
      resolveAsParameterizedType(type, scope)
      resolveAsParameterizedExpressionWithTypeContext(value, scope, type.resolvedType)
      checkConversion(value, type.resolvedType, .EXPLICIT)
      node.resolvedType = type.resolvedType
    }

    void resolveConstant(Node node, Scope scope) {
      switch (node.content.kind()) {
        case .BOOL { node.resolvedType = cache.boolType }
        case .DOUBLE { node.resolvedType = cache.doubleType }
        case .INT { node.resolvedType = cache.intType }
        case .STRING { node.resolvedType = cache.stringType }
        default { assert false }
      }
    }

    Symbol findMember(Type type, string name, Range range, FailureMode mode) {
      if (type.kind == .SYMBOL) {
        var symbol = type.symbol
        if (symbol.kind.isObject()) {
          var member = symbol.asObjectSymbol().members.getOrDefault(name, null)
          if (member != null) {
            initializeSymbol(member)
            return member
          }
        }
      }

      // Member lookup can optionally be performed silently to try different names
      if (mode == .ERROR_FAILURE && type != .DYNAMIC) {
        log.semanticErrorUnknownMemberSymbol(range, name, type)
      }

      return null
    }

    void resolveDot(Node node, Scope scope) {
      var target = node.dotTarget()
      var name = node.asString()
      resolveNode(target, scope, null)
      checkIsParameterized(target)

      // Search for a setter first, then search for a normal member
      Symbol symbol = null
      if (shouldCheckForSetter(node)) {
        symbol = findMember(target.resolvedType, name + "=", node.internalRange, .SILENT_FAILURE)
      }
      if (symbol == null) {
        symbol = findMember(target.resolvedType, name, node.internalRange, .ERROR_FAILURE)
        if (symbol == null) {
          return
        }
      }

      var isType = target.isType()
      var needsType = !symbol.kind.isOnInstances()

      // Make sure the global/instance context matches the intended usage
      if (isType && !needsType) {
        log.semanticErrorMemberUnexpectedInstance(node.internalRange, symbol.name)
      } else if (!isType && needsType) {
        log.semanticErrorMemberUnexpectedGlobal(node.internalRange, symbol.name)
      }

      node.symbol = symbol
      node.resolvedType = cache.substitute(symbol.resolvedType, target.resolvedType.environment)
      automaticallyCallGetter(node, scope)
    }

    void resolveHook(Node node, Scope scope) {
      resolveAsParameterizedExpressionWithConversion(node.hookTest(), scope, cache.boolType)
      resolveAsParameterizedExpression(node.hookTrue(), scope) // TODO: resolveAsParameterizedExpressionWithConversion()
      resolveAsParameterizedExpression(node.hookFalse(), scope) // TODO: resolveAsParameterizedExpressionWithConversion()
    }

    void resolveLambda(Node node, Scope scope, Type context) {
      var symbol = node.symbol.asFunctionSymbol()
      var count = symbol.arguments.size()
      symbol.scope = FunctionScope(scope, symbol)

      // Use type context to implicitly set missing types
      if (context != null && context.kind == .LAMBDA) {

        // Copy over the argument types if they line up
        if (context.argumentTypes.size() == count) {
          for (var i = 0; i < count; i++) {
            var argument = symbol.arguments[i]
            if (argument.type == null) {
              argument.type = Node.createType(context.argumentTypes[i])
            }
          }
        }

        // Copy over the return type
        if (symbol.returnType == null && context.returnType != null) {
          symbol.returnType = Node.createType(context.returnType)
        }
      }

      // Only infer non-void return types if there's no type context
      else if (symbol.returnType == null) {
        symbol.flags |= .INFER_RETURN_TYPE
      }

      resolveFunction(symbol)

      // Use a LambdaType instead of a SymbolType for the node
      List<Type> argumentTypes = []
      var returnType = symbol.returnType
      for (var i = 0; i < count; i++) {
        argumentTypes.push(symbol.arguments[i].resolvedType)
      }
      node.resolvedType = cache.createLambdaType(argumentTypes, returnType != null ? returnType.resolvedType : null)
    }

    void resolveLambdaType(Node node, Scope scope) {
      var children = node.children
      List<Type> types = []

      for (var i = 0; i < children.size(); i++) {
        var child = children[i]
        if (child != null) {
          resolveAsParameterizedType(child, scope)
          types.push(child.resolvedType)
        } else {
          types.push(null)
        }
      }

      var returnType = types.pop()
      node.resolvedType = cache.createLambdaType(types, returnType)
    }

    void resolveName(Node node, Scope scope) {
      var name = node.asString()
      Symbol symbol = null

      // Search for a setter first, then search for a normal symbol
      if (shouldCheckForSetter(node)) {
        symbol = scope.find(name + "=")
      }

      // If a setter wasn't found, search for a normal symbol
      if (symbol == null) {
        symbol = scope.find(name)
        if (symbol == null) {
          log.semanticErrorUndeclaredSymbol(node.range, name)
          return
        }
      }

      initializeSymbol(symbol)
      node.symbol = symbol
      node.resolvedType = symbol.resolvedType
      automaticallyCallGetter(node, scope)
    }

    void resolveParameterize(Node node, Scope scope) {
      var value = node.parameterizeValue()
      resolveNode(value, scope, null)

      // Resolve parameter types
      List<Type> substitutions = []
      var count = node.children.size() - 1
      for (var i = 0; i < count; i++) {
        var child = node.children[i + 1]
        resolveAsParameterizedType(child, scope)
        substitutions.push(child.resolvedType)
      }

      // Check for type parameters
      var type = value.resolvedType
      var parameters = type.parameters()
      if (parameters == null || type.isParameterized()) {
        log.semanticErrorCannotParameterize(node.range, type)
        value.resolvedType = .DYNAMIC
        return
      }

      // Check parameter count
      var expected = parameters.size()
      if (count != expected) {
        log.semanticErrorParameterCount(node.internalRange, expected, count)
        value.resolvedType = .DYNAMIC
        return
      }

      // Make sure all parameters have types
      for (var i = 0; i < parameters.size(); i++) {
        initializeSymbol(parameters[i])
      }

      // Include the symbol for use with Node.isType()
      node.resolvedType = cache.substitute(type, cache.createEnvironment(parameters, substitutions))
      node.symbol = value.symbol
    }

    void resolveUnary(Node node, Scope scope) {
      resolveAsParameterizedExpression(node.unaryValue(), scope)
      resolveOperatorOverload(node, scope)
    }

    void resolveBinary(Node node, Scope scope) {
      var left = node.binaryLeft()
      var right = node.binaryRight()

      // To make code emission easier, assignments are only allowed in statement position
      if (node.kind.isBinaryAssign() && isVoidExpressionUsed(node)) {
        log.semanticErrorUseOfVoidAssignment(node.range, operatorInfo[node.kind].text)
      }

      resolveAsParameterizedExpression(left, scope)

      if (node.kind == .ASSIGN) {
        // Automatically call setters
        if (left.symbol != null && left.symbol.isSetter()) {
          node.become(Node.createCall(left.replaceWithNull(), [right.replaceWithNull()]).withRange(node.range).withInternalRange(right.range))
          resolveAsParameterizedExpression(node, scope)
          return
        }

        // Resolve the right side using type context from the left side
        resolveAsParameterizedExpressionWithConversion(right, scope, left.resolvedType)
        checkStorage(left)
      }

      else {
        resolveAsParameterizedExpression(right, scope) // TODO: Pass type context if the member is unambiguous
        resolveOperatorOverload(node, scope)
      }
    }

    void resolveIndex(Node node, Scope scope) {
      // To make code emission easier, assignments are only allowed in statement position
      if (node.kind == .ASSIGN_INDEX && isVoidExpressionUsed(node)) {
        log.semanticErrorUseOfVoidAssignment(node.range, operatorInfo[node.kind].text)
      }

      for (var i = 0; i < node.children.size(); i++) {
        resolveAsParameterizedExpression(node.children[i], scope)
      }

      resolveOperatorOverload(node, scope)
    }

    void resolveOperatorOverload(Node node, Scope scope) {
      // The order of operands are reversed for the "in" operator
      var reverseBinaryOrder = node.kind == .IN
      var target = node.children[reverseBinaryOrder ? 1 : 0]
      var type = target.resolvedType
      if (type == .DYNAMIC) {
        return
      }

      // Check if the operator can be overridden at all
      var info = operatorInfo[node.kind]
      if (info.kind != .OVERRIDABLE) {
        log.semanticErrorUnknownMemberSymbol(node.internalRange, info.text, type)
        return
      }

      // Find the operator method
      var symbol = findMember(type, info.text, node.internalRange, .ERROR_FAILURE)
      if (symbol == null) {
        return
      }

      // Resolve the method call
      var value = node.replaceChild(0, Node.createDot(target.replaceWithNull(), info.text).withRange(node.internalRange).withInternalRange(node.internalRange))
      if (reverseBinaryOrder) {
        node.replaceChild(1, value)
      }
      node.kind = .CALL
      node.resolvedType = null
      resolveAsParameterizedExpression(node, scope)
    }

    Node defaultValueForType(Type type) {
      return
        type == cache.boolType ? Node.createBool(false) :
        type == cache.doubleType ? Node.createDouble(0.0) :
        type == cache.intType ? Node.createInt(0) :
        type == cache.stringType ? Node.createString("") :
        Node.createNull()
    }

    void automaticallyCallGetter(Node node, Scope scope) {
      var symbol = node.symbol
      if (symbol == null) {
        return
      }
      var isGetter = symbol.isGetter()

      // The check for getters is complicated by overloaded functions
      if (!isGetter && symbol.kind.isOverloadedFunction() && (node.parent == null || node.parent.kind != .CALL || node != node.parent.callValue() || node.parent.children.size() == 1)) {
        var overloaded = symbol.asOverloadedFunctionSymbol()
        for (var i = 0; i < overloaded.symbols.size(); i++) {
          var getter = overloaded.symbols[i]

          // Just return the first getter assuming errors for duplicate getters
          // were already logged when the overloaded symbol was initialized
          if (getter.isGetter()) {
            node.resolvedType = getter.resolvedType
            node.symbol = getter
            isGetter = true
            break
          }
        }
      }

      // Automatically wrap the getter in a call expression
      if (isGetter) {
        var value = Node.createNull()
        value.become(node)
        node.become(Node.createCall(value, []).withRange(node.range))
        resolveAsParameterizedExpression(node, scope)
      }
    }

    static bool shouldCheckForSetter(Node node) {
      return node.parent != null && node.parent.kind == .ASSIGN && node == node.parent.binaryLeft()
    }

    static bool isVoidExpressionUsed(Node node) {
      // Check for a null parent to handle variable initializers
      return node.parent == null || node.parent.kind != .EXPRESSION && node.parent.kind != .IMPLICIT_RETURN
    }

    static bool isValidVariableType(Type type) {
      return type != .NULL && (type.kind != .SYMBOL || !type.symbol.kind.isFunctionOrOverloadedFunction())
    }
  }
}
