namespace Skew {
  enum PassKind {
    RESOLVING
  }

  class ResolvingPass : Pass {
    over kind PassKind {
      return .RESOLVING
    }

    over run(context PassContext) {
      context.cache.loadGlobals(context.log, context.global)
      if !context.log.hasErrors {
        var resolver = Resolving.Resolver.new(context.global, context.options, context.options.defines.clone, context.cache, context.log)
        resolver.constantFolder = Folding.ConstantFolder.new(context.cache, context.options, symbol => resolver.initializeSymbol(symbol))
        resolver.initializeGlobals
        resolver.iterativelyMergeGuards
        resolver.resolveGlobal
        resolver.removeObsoleteFunctions(context.global)
      }
    }
  }
}

namespace Skew.Resolving {
  enum ConversionKind {
    IMPLICIT
    EXPLICIT
  }

  enum SymbolStatistic {
    READ
    WRITE
  }

  class LocalVariableStatistics {
    var symbol VariableSymbol
    var readCount = 0
    var writeCount = 0
  }

  class Resolver {
    const global ObjectSymbol
    const options CompilerOptions
    const defines StringMap<Define>
    const cache TypeCache
    const log Log
    const foreachLoops List<Node> = []
    const localVariableStatistics IntMap<LocalVariableStatistics> = {}
    var controlFlow = ControlFlowAnalyzer.new
    var constantFolder Folding.ConstantFolder = null
    var isMergingGuards = true

    def initializeSymbol(symbol Symbol) {
      # The scope should have been set by the merging pass (or by this pass for local variables)
      assert(symbol.scope != null)

      # Only initialize the symbol once
      if symbol.state == .UNINITIALIZED {
        symbol.state = .INITIALIZING

        switch symbol.kind {
          case .OBJECT_CLASS, .OBJECT_ENUM, .OBJECT_GLOBAL, .OBJECT_INTERFACE, .OBJECT_NAMESPACE, .OBJECT_WRAPPED {
            initializeObject(symbol.asObjectSymbol)
          }

          case .FUNCTION_ANNOTATION, .FUNCTION_CONSTRUCTOR, .FUNCTION_GLOBAL, .FUNCTION_INSTANCE, .FUNCTION_LOCAL {
            initializeFunction(symbol.asFunctionSymbol)
          }

          case .VARIABLE_ARGUMENT, .VARIABLE_ENUM, .VARIABLE_GLOBAL, .VARIABLE_INSTANCE, .VARIABLE_LOCAL {
            initializeVariable(symbol.asVariableSymbol)
          }

          case .PARAMETER_FUNCTION, .PARAMETER_OBJECT {
            initializeParameter(symbol.asParameterSymbol)
          }

          case .OVERLOADED_ANNOTATION, .OVERLOADED_GLOBAL, .OVERLOADED_INSTANCE {
            initializeOverloadedFunction(symbol.asOverloadedFunctionSymbol)
          }

          default {
            assert(false)
          }
        }

        assert(symbol.resolvedType != null)
        symbol.state = .INITIALIZED

        if symbol.kind.isFunction {
          var function = symbol.asFunctionSymbol
          var overloaded = function.overloaded

          # After initializing a function symbol, ensure the entire overload set is initialized
          if overloaded != null && overloaded.state == .UNINITIALIZED {
            initializeSymbol(overloaded)
          }

          if symbol.isEntryPoint {
            validateEntryPoint(function)
          }
        }
      }

      # Detect cyclic symbol references such as "foo foo;"
      else if symbol.state == .INITIALIZING {
        log.semanticErrorCyclicDeclaration(symbol.range, symbol.name)
        symbol.resolvedType = .DYNAMIC
      }
    }

    def validateEntryPoint(symbol FunctionSymbol) {
      # Detect duplicate entry points
      if cache.entryPointSymbol != null {
        log.semanticErrorDuplicateEntryPoint(symbol.range, cache.entryPointSymbol.range)
        return
      }

      cache.entryPointSymbol = symbol

      # Only recognize a few entry point types
      var type = symbol.resolvedType
      if type != .DYNAMIC {
        var argumentTypes = type.argumentTypes

        # The argument list must be empty or one argument of type "List<string>"
        if argumentTypes.count > 1 || argumentTypes.count == 1 && argumentTypes.first != cache.createListType(cache.stringType) {
          log.semanticErrorInvalidEntryPointArguments(Range.span(symbol.arguments.first.range, symbol.arguments.last.type.range), symbol.name)
        }

        # The return type must be nothing or "int"
        else if type.returnType != null && type.returnType != cache.intType {
          log.semanticErrorInvalidEntryPointReturnType(symbol.returnType.range, symbol.name)
        }
      }
    }

    def resolveDefines(symbol VariableSymbol) {
      var key = symbol.fullName
      var define = defines.get(key, null)

      if define == null {
        return
      }

      # Remove the define so we can tell what defines weren't used later on
      defines.remove(key)

      var type = symbol.resolvedType
      var range = define.value
      var value = range.toString
      var node Node = null

      # Special-case booleans
      if type == cache.boolType {
        if value == "true" || value == "false" {
          node = Node.createBool(value == "true")
        }
      }

      # Special-case doubles
      else if type == cache.doubleType {
        var number = Parsing.parseDoubleLiteral(value)
        if !number.isNaN {
          node = Node.createDouble(number)
        }
      }

      # Special-case strings
      else if type == cache.stringType {
        node = Node.createString(value)
      }

      # Special-case enums
      else if type.isEnum {
        node = Node.createDot(null, value)
      }

      # Integers can also apply to doubles
      if node == null && cache.isNumeric(type) {
        var box = Parsing.parseIntLiteral(value)
        if box != null {
          node = Node.createInt(box.value)
        }
      }

      # Stop if anything failed above
      if node == null {
        log.semanticErrorInvalidDefine(range, value, type, key)
        return
      }

      resolveAsParameterizedExpressionWithConversion(node.withRange(range), global.scope, type)
      symbol.value = node
    }

    def resolveAnnotations(symbol Symbol) {
      var parent = symbol.parent
      var annotations = symbol.annotations

      # The import/export annotations are inherited, except import isn't inherited for implemented functions
      if parent != null {
        symbol.flags |= parent.flags & (symbol.kind.isFunction && symbol.asFunctionSymbol.block != null ? Symbol.IS_EXPORTED : Symbol.IS_IMPORTED | Symbol.IS_EXPORTED)
      }

      # Resolve annotations on this symbol after annotation inheritance. Don't
      # use removeIf() since this annotation list may be shared elsewhere.
      if annotations != null {
        symbol.annotations = annotations.filter(annotation => resolveAnnotation(annotation, symbol))
      }

      # Protected access used to be an annotation. It's now indicated with just
      # a leading underscore.
      if symbol.name.startsWith("_") && !symbol.kind.isLocal {
        symbol.flags |= Symbol.IS_PROTECTED
      }
    }

    def resolveParameters(parameters List<ParameterSymbol>) {
      if parameters != null {
        for parameter in parameters {
          resolveParameter(parameter)
        }
      }
    }

    def initializeParameter(symbol ParameterSymbol) {
      if symbol.resolvedType == null {
        symbol.resolvedType = Type.new(.SYMBOL, symbol)
      }

      resolveAnnotations(symbol)
    }

    def resolveParameter(symbol ParameterSymbol) {
      initializeSymbol(symbol)
    }

    def initializeObject(symbol ObjectSymbol) {
      if symbol.resolvedType == null {
        symbol.resolvedType = Type.new(.SYMBOL, symbol)
      }

      resolveParameters(symbol.parameters)
      forbidOverriddenSymbol(symbol)

      # Resolve the base type (only for classes and wrapped types)
      if symbol.base != null {
        resolveAsParameterizedType(symbol.base, symbol.scope)
        var baseType = symbol.base.resolvedType
        if symbol.kind == .OBJECT_WRAPPED {
          symbol.wrappedType = baseType
          symbol.resolvedType.environment = baseType.environment # Don't lose the type parameters from the base type
        } else if baseType.kind == .SYMBOL && baseType.symbol.kind == .OBJECT_CLASS && !baseType.symbol.isValueType {
          symbol.baseClass = baseType.symbol.asObjectSymbol
          symbol.resolvedType.environment = baseType.environment # Don't lose the type parameters from the base type
        } else if baseType != .DYNAMIC {
          log.semanticErrorInvalidBaseType(symbol.base.range, baseType)
        }
      }

      # Wrapped types without something to wrap don't make sense
      else if symbol.kind == .OBJECT_WRAPPED {
        log.semanticErrorMissingWrappedType(symbol.range, symbol.fullName)
      }

      # Assign values for all enums before they are initialized
      if symbol.kind == .OBJECT_ENUM {
        var nextEnumValue = 0
        for variable in symbol.variables {
          if variable.kind == .VARIABLE_ENUM {
            variable.value = Node.createInt(nextEnumValue).withType(symbol.resolvedType).withRange(variable.range)
            nextEnumValue++
          }
        }
        symbol.flags |= Symbol.IS_VALUE_TYPE
      }

      resolveAnnotations(symbol)

      # Create a default constructor if one doesn't exist
      var constructor = symbol.members.get("new", null)
      if symbol.kind == .OBJECT_CLASS && !symbol.isImported && constructor == null {
        var baseConstructor = symbol.baseClass != null ? symbol.baseClass.members.get("new", null) : null

        # Unwrap the overload group if present
        if baseConstructor != null && baseConstructor.kind == .OVERLOADED_GLOBAL {
          var overloaded = baseConstructor.asOverloadedFunctionSymbol
          for overload in overloaded.symbols {
            if overload.kind == .FUNCTION_CONSTRUCTOR {
              if baseConstructor.kind == .FUNCTION_CONSTRUCTOR {
                baseConstructor = null # Signal that there isn't a single base constructor
                break
              }
              baseConstructor = overload
            }
          }
        }

        # A default constructor can only be created if the base class has a single constructor
        if symbol.baseClass == null || baseConstructor != null && baseConstructor.kind == .FUNCTION_CONSTRUCTOR {
          var generated = FunctionSymbol.new(.FUNCTION_CONSTRUCTOR, "new")
          generated.scope = FunctionScope.new(symbol.scope, generated)
          generated.flags |= Symbol.IS_AUTOMATICALLY_GENERATED
          generated.parent = symbol
          generated.range = symbol.range
          generated.overridden = baseConstructor != null ? baseConstructor.asFunctionSymbol : null
          symbol.functions.append(generated)
          symbol.members[generated.name] = generated
        }
      }

      # Create a default toString if one doesn't exist
      if symbol.kind == .OBJECT_ENUM && !symbol.isImported && !("toString" in symbol.members) {
        var generated = FunctionSymbol.new(.FUNCTION_INSTANCE, "toString")
        generated.scope = FunctionScope.new(symbol.scope, generated)
        generated.flags |= Symbol.IS_AUTOMATICALLY_GENERATED
        generated.parent = symbol
        generated.range = symbol.range
        symbol.functions.append(generated)
        symbol.members[generated.name] = generated
      }
    }

    def isAbstractObject(symbol ObjectSymbol) bool {
      if !symbol.hasCheckedForAbstract {
        symbol.hasCheckedForAbstract = true

        if symbol.kind == .OBJECT_CLASS && !symbol.isImported {
          for function in symbol.functions {
            initializeSymbol(function)

            if !function.isImported && !function.isObsolete && function.block == null {
              symbol.isAbstractBecauseOf = function
              break
            }
          }
        }
      }

      return symbol.isAbstract
    }

    def initializeGlobals {
      initializeSymbol(cache.boolType.symbol)
      initializeSymbol(cache.doubleType.symbol)
      initializeSymbol(cache.intMapType.symbol)
      initializeSymbol(cache.intType.symbol)
      initializeSymbol(cache.listType.symbol)
      initializeSymbol(cache.stringMapType.symbol)
      initializeSymbol(cache.stringType.symbol)
    }

    def resolveGlobal {
      resolveObject(global)
      convertForeachLoops
      scanLocalVariables
      discardUnusedDefines
    }

    def removeObsoleteFunctions(symbol ObjectSymbol) {
      for object in symbol.objects {
        removeObsoleteFunctions(object)
      }
      symbol.functions.removeIf(function => function.isObsolete)
    }

    def iterativelyMergeGuards {
      var guards List<Guard>

      # Iterate until a fixed point is reached
      while true {
        guards = []
        scanForGuards(global, guards)
        if guards.isEmpty {
          break
        }

        # Each iteration must remove at least one guard to continue
        if !processGuards(guards) {
          break
        }
      }

      isMergingGuards = false

      # All remaining guards are errors
      for guard in guards {
        var count = log.errorCount
        resolveAsParameterizedExpressionWithConversion(guard.test, guard.parent.scope, cache.boolType)
        if log.errorCount == count {
          log.semanticErrorExpectedConstant(guard.test.range)
        }
      }
    }

    def scanForGuards(symbol ObjectSymbol, guards List<Guard>) {
      guards.append(symbol.guards)

      for object in symbol.objects {
        scanForGuards(object, guards)
      }
    }

    if TARGET == .CSHARP {
      class GuardMergingFailure : dynamic.System.Exception {
      }
    }

    else {
      class GuardMergingFailure {
      }
    }

    def reportGuardMergingFailure(node Node) {
      if isMergingGuards {
        while node != null {
          node.resolvedType = null
          node = node.parent
        }
        throw GuardMergingFailure.new
      }
    }

    def attemptToResolveGuardConstant(node Node, scope Scope) bool {
      assert(scope != null)
      try {
        resolveAsParameterizedExpressionWithConversion(node, scope, cache.boolType)
        constantFolder.foldConstants(node)
        return true
      } catch failure GuardMergingFailure {
      }
      return false
    }

    def processGuards(guards List<Guard>) bool {
      var wasGuardRemoved = false

      for guard in guards {
        var test = guard.test
        var parent = guard.parent

        # If it's not a constant, we'll just try again in the next iteration
        if !attemptToResolveGuardConstant(test, parent.scope) {
          continue
        }

        if test.isBool {
          parent.guards.removeOne(guard)
          wasGuardRemoved = true

          if test.isTrue {
            mergeGuardIntoObject(guard, parent)
          } else {
            var elseGuard = guard.elseGuard
            if elseGuard != null {
              if elseGuard.test != null {
                elseGuard.parent = parent
                parent.guards.append(elseGuard)
              } else {
                mergeGuardIntoObject(elseGuard, parent)
              }
            }
          }
        }
      }

      return wasGuardRemoved
    }

    def mergeGuardIntoObject(guard Guard, object ObjectSymbol) {
      var symbol = guard.contents
      Merging.mergeObjects(log, object, symbol.objects)
      Merging.mergeFunctions(log, object, symbol.functions)
      Merging.mergeVariables(log, object, symbol.variables)
      object.objects.append(symbol.objects)
      object.functions.append(symbol.functions)
      object.variables.append(symbol.variables)

      # Handle nested guard clauses like this:
      #
      #   if true {
      #     if true {
      #       var foo = 0
      #     }
      #   }
      #
      for nested in symbol.guards {
        nested.parent = object
        object.guards.append(nested)
      }
    }

    # Foreach loops are converted to for loops after everything is resolved
    # because that process needs to generate symbol names and it's much easier
    # to generate non-conflicting symbol names after all local variables have
    # been defined.
    def convertForeachLoops {
      for node in foreachLoops {
        var symbol = node.symbol.asVariableSymbol
        var scope = symbol.scope.findEnclosingFunctionOrLambda # Generate names at the function level to avoid conflicts with local scopes
        var value = node.foreachValue
        var block = node.foreachBlock

        # Handle "for i in 0..10"
        if value.kind == .PAIR {
          var first = value.firstValue
          var second = value.secondValue
          var setup = Node.createVariables.appendChild(Node.createVariable(symbol))
          var symbolName = Node.createSymbolReference(symbol)
          var update = Node.createUnary(.INCREMENT, symbolName)
          var test Node

          # Special-case constant iteration limits to generate simpler code
          if second.kind == .CONSTANT || second.kind == .NAME && second.symbol != null && second.symbol.isConst {
            test = Node.createBinary(.LESS_THAN, symbolName.clone, second.remove)
          }

          # Otherwise, save the iteration limit in case it changes during iteration
          else {
            var count = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("count"))
            count.resolvedType = cache.intType
            count.value = second.remove
            count.state = .INITIALIZED
            setup.appendChild(Node.createVariable(count))
            test = Node.createBinary(.LESS_THAN, symbolName.clone, Node.createSymbolReference(count))
          }

          # Use a C-style for loop to implement this foreach loop
          symbol.flags &= ~Symbol.IS_CONST
          symbol.value = first.remove
          node.become(Node.createFor(setup, test, update, block.remove).withComments(node.comments).withRange(node.range))

          # Make sure the new expressions are resolved
          resolveNode(test, symbol.scope, null)
          resolveNode(update, symbol.scope, null)
        }

        else if cache.isList(value.resolvedType) && !options.target.supportsListForeach {
          # Create the index variable
          var index = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("i"))
          index.resolvedType = cache.intType
          index.value = Node.createInt(0).withType(cache.intType)
          index.state = .INITIALIZED
          var indexName = Node.createSymbolReference(index)

          # Create the list variable
          var list = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("list"))
          list.resolvedType = value.resolvedType
          list.value = value.remove
          list.state = .INITIALIZED
          var listName = Node.createSymbolReference(list)

          # Create the count variable
          var count = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("count"))
          count.resolvedType = cache.intType
          count.value = Node.createDot(listName, "count")
          count.state = .INITIALIZED
          var countName = Node.createSymbolReference(count)

          # Move the loop variable into the loop body
          symbol.value = Node.createIndex(listName.clone, indexName)
          block.prependChild(Node.createVariables.appendChild(Node.createVariable(symbol)))

          # Use a C-style for loop to implement this foreach loop
          var setup = Node.createVariables.appendChild(Node.createVariable(index)).appendChild(Node.createVariable(list)).appendChild(Node.createVariable(count))
          var test = Node.createBinary(.LESS_THAN, indexName.clone, countName)
          var update = Node.createUnary(.INCREMENT, indexName.clone)
          node.become(Node.createFor(setup, test, update, block.remove).withComments(node.comments).withRange(node.range))

          # Make sure the new expressions are resolved
          resolveNode(symbol.value, symbol.scope, null)
          resolveNode(count.value, symbol.scope, null)
          resolveNode(test, symbol.scope, null)
          resolveNode(update, symbol.scope, null)
        }
      }
    }

    def scanLocalVariables {
      for info in localVariableStatistics.values {
        var symbol = info.symbol

        # Variables that are never re-assigned can safely be considered constants for constant folding
        if symbol.value != null && info.writeCount == 0 {
          symbol.flags |= Symbol.IS_CONST
        }

        # Unused local variables can safely be removed, but don't warn about "for i in 0..10 {}"
        if info.readCount == 0 && !symbol.isLoopVariable {
          log.semanticWarningUnreadLocalVariable(symbol.range, symbol.name)
        }

        # Rename local variables that conflict
        var scope = symbol.scope
        while scope.kind == .LOCAL {
          scope = scope.parent
        }
        if scope.used != null && scope.used.get(symbol.name, null) != symbol {
          symbol.name = scope.generateName(symbol.name)
        }
      }
    }

    def discardUnusedDefines {
      for key in defines.keys {
        log.semanticErrorInvalidDefine(defines[key].name, key)
      }
    }

    def resolveObject(symbol ObjectSymbol) {
      initializeSymbol(symbol)

      for object in symbol.objects {
        resolveObject(object)
      }

      for function in symbol.functions {
        resolveFunction(function)
      }

      for variable in symbol.variables {
        resolveVariable(variable)
      }

      isAbstractObject(symbol)
    }

    def initializeFunction(symbol FunctionSymbol) {
      if symbol.resolvedType == null {
        symbol.resolvedType = Type.new(.SYMBOL, symbol)
      }

      # Referencing a normal variable instead of a special node kind for "this"
      # makes many things much easier including lambda capture and devirtualization
      if symbol.kind == .FUNCTION_INSTANCE || symbol.kind == .FUNCTION_CONSTRUCTOR {
        symbol.this = VariableSymbol.new(.VARIABLE_ARGUMENT, "self")
        symbol.this.flags |= Symbol.IS_CONST
        symbol.this.resolvedType = cache.parameterize(symbol.parent.resolvedType)
        symbol.this.state = .INITIALIZED
      }

      # Lazily-initialize automatically generated functions
      if symbol.isAutomaticallyGenerated {
        if symbol.kind == .FUNCTION_CONSTRUCTOR {
          assert(symbol.name == "new")
          automaticallyGenerateClassConstructor(symbol)
        } else if symbol.kind == .FUNCTION_INSTANCE {
          assert(symbol.name == "toString")
          automaticallyGenerateEnumToString(symbol)
        }
      }

      # Find the overridden function or overloaded function in the base class
      var overridden = findOverriddenMember(symbol)
      if overridden != null {
        var symbolKind = Merging.overloadedKind(symbol.kind)
        var overriddenKind = Merging.overloadedKind(overridden.kind)

        # Make sure the overridden symbol can be merged with this symbol
        if symbolKind != overriddenKind {
          log.semanticErrorBadOverride(symbol.range, symbol.name, symbol.parent.asObjectSymbol.base.resolvedType, overridden.range)
          overridden = null
        }

        # Overriding something makes both symbols overloaded for simplicity
        else {
          ensureFunctionIsOverloaded(symbol)
          if overridden.kind.isFunction {
            var function = overridden.asFunctionSymbol
            ensureFunctionIsOverloaded(function)
            overridden = function.overloaded
          }
        }
      }

      resolveParameters(symbol.parameters)

      # Resolve the argument variables
      symbol.resolvedType.argumentTypes = []
      for argument in symbol.arguments {
        argument.scope = symbol.scope
        resolveVariable(argument)
        symbol.resolvedType.argumentTypes.append(argument.resolvedType)
      }
      symbol.argumentOnlyType = cache.createLambdaType(symbol.resolvedType.argumentTypes, null)

      # Resolve the return type if present (no return type means "void")
      var returnType Type = null
      if symbol.returnType != null {
        if symbol.kind == .FUNCTION_CONSTRUCTOR {
          log.semanticErrorConstructorReturnType(symbol.returnType.range)
        } else {
          resolveAsParameterizedType(symbol.returnType, symbol.scope)
          returnType = symbol.returnType.resolvedType
        }
      }

      # Constructors always return the type they construct
      if symbol.kind == .FUNCTION_CONSTRUCTOR {
        returnType = cache.parameterize(symbol.parent.resolvedType)
      }

      # The "<=>" operator must return a numeric value for comparison with zero
      var count = symbol.arguments.count
      if symbol.name == "<=>" {
        if returnType == null || returnType != cache.intType {
          log.semanticErrorComparisonOperatorNotInt(symbol.returnType != null ? symbol.returnType.range : symbol.range)
          returnType = .DYNAMIC
        } else if count != 1 {
          log.semanticErrorWrongArgumentCount(symbol.range, symbol.name, 1)
        }
      }

      # Setters must have one argument
      else if symbol.isSetter && count != 1 {
        log.semanticErrorWrongArgumentCount(symbol.range, symbol.name, 1)
        symbol.flags &= ~Symbol.IS_SETTER
      }

      # Validate argument count
      else {
        var argumentCount = argumentCountForOperator(symbol.name)

        if argumentCount != null && !(count in argumentCount) {
          log.semanticErrorWrongArgumentCountRange(symbol.range, symbol.name, argumentCount)
        }

        # Enforce that the initializer constructor operators take lists of
        # values to avoid confusing error messages inside the code generated
        # for initializer expressions
        else if symbol.name == "{new}" || symbol.name == "[new]" {
          for argument in symbol.arguments {
            if argument.resolvedType != .DYNAMIC && !cache.isList(argument.resolvedType) {
              log.semanticErrorExpectedList(argument.range, argument.name, argument.resolvedType)
            }
          }
        }
      }

      # Link this symbol with the overridden symbol if there is one
      var hasOverrideError = false
      if overridden != null {
        var overloaded = overridden.asOverloadedFunctionSymbol
        initializeSymbol(overloaded)
        for overload in overloaded.symbols {
          if overload.argumentOnlyType == symbol.argumentOnlyType {
            symbol.overridden = overload.asFunctionSymbol
            if symbol.kind != .FUNCTION_CONSTRUCTOR && overload.kind != .FUNCTION_CONSTRUCTOR && symbol.overridden.resolvedType.returnType != returnType {
              log.semanticErrorBadOverrideReturnType(symbol.range, symbol.name, symbol.parent.asObjectSymbol.base.resolvedType, overload.range)
              hasOverrideError = true
            }
            break
          }
        }
      }

      symbol.resolvedType.returnType = returnType
      resolveAnnotations(symbol)

      # Validate use of "def" vs "over"
      if !hasOverrideError {
        if symbol.overridden != null && symbol.kind == .FUNCTION_INSTANCE {
          if !symbol.isOver {
            log.semanticErrorModifierMissingOverride(symbol.range, symbol.name, symbol.overridden.range)
          }
        } else {
          if symbol.isOver {
            log.semanticErrorModifierUnusedOverride(symbol.range, symbol.name)
          }
        }
      }
    }

    def automaticallyGenerateClassConstructor(symbol FunctionSymbol) {
      # Create the function body
      var block = Node.createBlock
      symbol.block = block

      # Mirror the base constructor's arguments
      if symbol.overridden != null {
        initializeSymbol(symbol.overridden)
        var arguments = symbol.overridden.arguments
        var base = Node.createSuper.withRange(symbol.overridden.range)
        if arguments.isEmpty {
          block.appendChild(Node.createExpression(base))
        } else {
          var call = Node.createCall(base)
          for variable in arguments {
            var argument = VariableSymbol.new(.VARIABLE_ARGUMENT, variable.name)
            argument.resolvedType = variable.resolvedType
            argument.state = .INITIALIZED
            symbol.arguments.append(argument)
            call.appendChild(Node.createSymbolReference(argument))
          }
          block.prependChild(Node.createExpression(call))
        }
      }

      # Add an argument for every uninitialized variable
      var parent = symbol.parent.asObjectSymbol
      initializeSymbol(parent)
      for variable in parent.variables {
        if variable.kind == .VARIABLE_INSTANCE {
          initializeSymbol(variable)
          if variable.value == null {
            var argument = VariableSymbol.new(.VARIABLE_ARGUMENT, variable.name)
            argument.resolvedType = variable.resolvedType
            argument.state = .INITIALIZED
            argument.range = variable.range
            symbol.arguments.append(argument)
            block.appendChild(Node.createExpression(Node.createBinary(.ASSIGN,
              Node.createMemberReference(Node.createSymbolReference(symbol.this), variable),
              Node.createSymbolReference(argument)).withRange(variable.range)))
          } else {
            block.appendChild(Node.createExpression(Node.createBinary(.ASSIGN,
              Node.createMemberReference(Node.createSymbolReference(symbol.this), variable),
              variable.value).withRange(variable.range)))
            variable.value = null
          }
        }
      }

      # Make constructors without arguments into getters
      if symbol.arguments.isEmpty {
        symbol.flags |= Symbol.IS_GETTER
      }
    }

    def automaticallyGenerateEnumToString(symbol FunctionSymbol) {
      var parent = symbol.parent.asObjectSymbol
      var names = Node.createList
      initializeSymbol(parent)

      for variable in parent.variables {
        if variable.kind == .VARIABLE_ENUM {
          assert(variable.enumValue == names.childCount)
          names.appendChild(Node.createString(variable.name))
        }
      }

      var strings = VariableSymbol.new(.VARIABLE_GLOBAL, parent.scope.generateName("_strings"))
      strings.value = names
      strings.flags |= Symbol.IS_PROTECTED | Symbol.IS_CONST
      strings.state = .INITIALIZED
      strings.parent = parent
      strings.scope = parent.scope
      strings.resolvedType = cache.createListType(cache.stringType)
      parent.variables.append(strings)
      resolveAsParameterizedExpressionWithConversion(strings.value, strings.scope, strings.resolvedType)

      symbol.returnType = Node.createType(cache.stringType)
      symbol.block = Node.createBlock.appendChild(Node.createReturn(Node.createIndex(Node.createSymbolReference(strings), Node.createName("self"))))
      symbol.flags |= Symbol.IS_GETTER
    }

    def resolveFunction(symbol FunctionSymbol) {
      initializeSymbol(symbol)

      var scope = LocalScope.new(symbol.scope, .NORMAL)
      if symbol.this != null {
        scope.define(symbol.this, log)
      }

      # Default values for argument variables aren't resolved with this local
      # scope since they are evaluated at the call site, not inside the
      # function body, and shouldn't have access to other arguments
      for argument in symbol.arguments {
        scope.define(argument, log)
      }

      # The function is considered abstract if the body is missing
      var block = symbol.block
      if block != null {
        # User-specified constructors have variable initializers automatically inserted
        if symbol.kind == .FUNCTION_CONSTRUCTOR && !symbol.isAutomaticallyGenerated {
          var first = block.firstChild
          for variable in symbol.parent.asObjectSymbol.variables {
            if variable.kind == .VARIABLE_INSTANCE {
              initializeSymbol(variable)

              # Attempt to create a default value if absent. Right now this
              # avoids the problem of initializing type parameters:
              #
              #   class Foo<T> {
              #     var foo T
              #     def new {}
              #     def use T { return foo }
              #   }
              #
              # This should be fixed at some point.
              if variable.value == null && !variable.resolvedType.isParameter {
                variable.value = createDefaultValueForType(variable.resolvedType, variable.range)
              }

              if variable.value != null {
                block.insertChildBefore(first, Node.createExpression(Node.createBinary(.ASSIGN,
                  Node.createMemberReference(Node.createSymbolReference(symbol.this), variable),
                  variable.value)))
                variable.value = null
              }
            }
          }
        }

        resolveNode(block, scope, null)

        # Missing a return statement is an error
        if symbol.kind != .FUNCTION_CONSTRUCTOR {
          var returnType = symbol.resolvedType.returnType
          if returnType != null && returnType != .DYNAMIC && block.hasControlFlowAtEnd {
            log.semanticErrorMissingReturn(symbol.range, symbol.name, returnType)
          }
        }
      }
    }

    def recordStatistic(symbol Symbol, statistic SymbolStatistic) {
      if symbol != null && symbol.kind == .VARIABLE_LOCAL {
        var info = localVariableStatistics.get(symbol.id, null)
        if info != null {
          switch statistic {
            case .READ { info.readCount++ }
            case .WRITE { info.writeCount++ }
          }
        }
      }
    }

    def initializeVariable(symbol VariableSymbol) {
      forbidOverriddenSymbol(symbol)

      # Normal variables may omit the initializer if the type is present
      if symbol.type != null {
        resolveAsParameterizedType(symbol.type, symbol.scope)
        symbol.resolvedType = symbol.type.resolvedType

        # Resolve the constant now so initialized constants always have a value
        if symbol.isConst && symbol.value != null {
          resolveAsParameterizedExpressionWithConversion(symbol.value, symbol.scope, symbol.resolvedType)
        }
      }

      # Enums take their type from their parent
      else if symbol.kind == .VARIABLE_ENUM {
        symbol.resolvedType = symbol.parent.resolvedType
      }

      # Implicitly-typed variables take their type from their initializer
      else if symbol.value != null {
        resolveAsParameterizedExpression(symbol.value, symbol.scope)
        var type = symbol.value.resolvedType
        symbol.resolvedType = type

        # Forbid certain types
        if !isValidVariableType(type) {
          log.semanticErrorBadImplicitVariableType(symbol.range, type)
          symbol.resolvedType = .DYNAMIC
        }
      }

      # Use a different error for constants which must have a type and lambda arguments which cannot have an initializer
      else if symbol.isConst || symbol.scope.kind == .FUNCTION && symbol.scope.asFunctionScope.symbol.kind == .FUNCTION_LOCAL {
        log.semanticErrorVarMissingType(symbol.range, symbol.name)
        symbol.resolvedType = .DYNAMIC
      }

      # Variables without a type are an error
      else {
        log.semanticErrorVarMissingValue(symbol.range, symbol.name)
        symbol.resolvedType = .DYNAMIC
      }

      resolveDefines(symbol)
      resolveAnnotations(symbol)

      # Run post-annotation checks
      if symbol.resolvedType != .DYNAMIC && symbol.isConst && !symbol.isImported && symbol.value == null && symbol.kind != .VARIABLE_ENUM && symbol.kind != .VARIABLE_INSTANCE {
        log.semanticErrorConstMissingValue(symbol.range, symbol.name)
      }
    }

    def resolveVariable(symbol VariableSymbol) {
      initializeSymbol(symbol)

      if symbol.value != null {
        resolveAsParameterizedExpressionWithConversion(symbol.value, symbol.scope, symbol.resolvedType)
      }

      # Default-initialize variables
      else if symbol.kind != .VARIABLE_ARGUMENT && symbol.kind != .VARIABLE_INSTANCE && symbol.kind != .VARIABLE_ENUM {
        symbol.value = createDefaultValueForType(symbol.resolvedType, symbol.range)
      }
    }

    def createDefaultValueForType(type Type, range Range) Node {
      var unwrapped = cache.unwrappedType(type)

      if unwrapped == cache.intType {
        return Node.createInt(0).withType(type)
      }

      if unwrapped == cache.doubleType {
        return Node.createDouble(0).withType(type)
      }

      if unwrapped == cache.boolType {
        return Node.createBool(false).withType(type)
      }

      if unwrapped.isEnum {
        return Node.createCast(Node.createInt(0).withType(cache.intType), Node.createType(type)).withType(type)
      }

      if unwrapped.isParameter {
        log.semanticErrorNoDefaultValue(range, type)
        return null
      }

      assert(unwrapped.isReference)
      return Node.createNull.withType(type)
    }

    def initializeOverloadedFunction(symbol OverloadedFunctionSymbol) {
      var symbols = symbol.symbols

      if symbol.resolvedType == null {
        symbol.resolvedType = Type.new(.SYMBOL, symbol)
      }

      # Ensure no two overloads have the same argument types
      var types List<Type> = []
      var i = 0
      while i < symbols.count {
        var function = symbols[i]
        initializeSymbol(function)
        symbol.flags |= function.flags & Symbol.IS_SETTER

        var index = types.indexOf(function.argumentOnlyType)
        if index != -1 {
          var other = symbols[index]

          # Allow duplicate function declarations with the same type to merge
          # as long as there is one declaration that provides an implementation.
          # Mark the obsolete function as obsolete instead of removing it so it
          # doesn't potentially mess up iteration in a parent call stack.
          if function.isMerged || other.isMerged || (function.block != null) == (other.block != null) || function.resolvedType.returnType != other.resolvedType.returnType {
            log.semanticErrorDuplicateOverload(function.range, symbol.name, other.range)
          } else if function.block != null {
            function.flags |= other.flags & ~Symbol.IS_IMPORTED | Symbol.IS_MERGED
            function.mergeAnnotationsAndCommentsFrom(other)
            other.flags |= Symbol.IS_OBSOLETE
            symbols[index] = function
          } else {
            other.flags |= function.flags & ~Symbol.IS_IMPORTED | Symbol.IS_MERGED
            other.mergeAnnotationsAndCommentsFrom(function)
            function.flags |= Symbol.IS_OBSOLETE
          }

          # Remove the symbol after the merge so "types" still matches "symbols"
          symbols.removeAt(i)
          continue
        }

        types.append(function.argumentOnlyType)
        i++
      }

      # Include non-overridden overloads from the base class
      var overridden = findOverriddenMember(symbol)
      if overridden != null && overridden.kind.isOverloadedFunction {
        symbol.overridden = overridden.asOverloadedFunctionSymbol
        for function in symbol.overridden.symbols {

          # Constructors are not inherited
          if function.kind != .FUNCTION_CONSTRUCTOR {
            initializeSymbol(function)
            var index = types.indexOf(function.argumentOnlyType)
            if index == -1 {
              symbols.append(function)
              types.append(function.argumentOnlyType)
            }
          }
        }
      }
    }

    def resolveNode(node Node, scope Scope, context Type) {
      if node.resolvedType != null {
        return # Only resolve once
      }

      node.resolvedType = .DYNAMIC
      switch node.kind {
        case .BLOCK { resolveBlock(node, scope) }
        case .PAIR { resolvePair(node, scope) }

        # Statements
        case .BREAK, .CONTINUE { resolveJump(node, scope) }
        case .EXPRESSION { resolveExpression(node, scope) }
        case .FOR { resolveFor(node, scope) }
        case .FOREACH { resolveForeach(node, scope) }
        case .IF { resolveIf(node, scope) }
        case .RETURN { resolveReturn(node, scope) }
        case .SWITCH { resolveSwitch(node, scope) }
        case .THROW { resolveThrow(node, scope) }
        case .TRY { resolveTry(node, scope) }
        case .VARIABLE { resolveVariable(node, scope) }
        case .VARIABLES { resolveVariables(node, scope) }
        case .WHILE { resolveWhile(node, scope) }

        # Expressions
        case .ASSIGN_INDEX { resolveOperatorOverload(node, scope) }
        case .CALL { resolveCall(node, scope) }
        case .CAST { resolveCast(node, scope, context) }
        case .COMPLEMENT, .DECREMENT, .INCREMENT, .NEGATIVE, .NOT, .POSITIVE { resolveOperatorOverload(node, scope) }
        case .CONSTANT { resolveConstant(node, scope) }
        case .DOT { resolveDot(node, scope, context) }
        case .HOOK { resolveHook(node, scope, context) }
        case .INDEX { resolveOperatorOverload(node, scope) }
        case .INITIALIZER_LIST, .INITIALIZER_MAP { resolveInitializer(node, scope, context) }
        case .LAMBDA { resolveLambda(node, scope, context) }
        case .LAMBDA_TYPE { resolveLambdaType(node, scope) }
        case .NAME { resolveName(node, scope) }
        case .NULL { node.resolvedType = .NULL }
        case .PARAMETERIZE { resolveParameterize(node, scope) }
        case .SEQUENCE { resolveSequence(node, scope, context) }
        case .SUPER { resolveSuper(node, scope) }
        case .TYPE {}
        case .TYPE_CHECK { resolveTypeCheck(node, scope) }

        default {
          if node.kind.isBinary { resolveBinary(node, scope) }
          else { assert(false) }
        }
      }

      assert(node.resolvedType != null)
    }

    def resolveAsParameterizedType(node Node, scope Scope) {
      assert(node.kind.isExpression)
      resolveNode(node, scope, null)
      checkIsType(node)
      checkIsParameterized(node)
    }

    def resolveAsParameterizedExpression(node Node, scope Scope) {
      assert(node.kind.isExpression)
      resolveNode(node, scope, null)
      checkIsInstance(node)
      checkIsParameterized(node)
    }

    def resolveAsParameterizedExpressionWithTypeContext(node Node, scope Scope, type Type) {
      assert(node.kind.isExpression)
      resolveNode(node, scope, type)
      checkIsInstance(node)
      checkIsParameterized(node)
    }

    def resolveAsParameterizedExpressionWithConversion(node Node, scope Scope, type Type) {
      resolveAsParameterizedExpressionWithTypeContext(node, scope, type)
      checkConversion(node, type, .IMPLICIT)
    }

    def resolveChildrenAsParameterizedExpressions(node Node, scope Scope) {
      for child = node.firstChild; child != null; child = child.nextSibling {
        resolveAsParameterizedExpression(child, scope)
      }
    }

    def checkUnusedExpression(node Node) {
      var kind = node.kind
      if kind == .HOOK {
        checkUnusedExpression(node.hookTrue)
        checkUnusedExpression(node.hookFalse)
      } else if node.range != null && node.resolvedType != .DYNAMIC && kind != .CALL && !kind.isBinaryAssign {
        log.semanticWarningUnusedExpression(node.range)
      }
    }

    def checkIsInstance(node Node) {
      if node.resolvedType != .DYNAMIC && node.isType {
        log.semanticErrorUnexpectedType(node.range, node.resolvedType)
        node.resolvedType = .DYNAMIC
      }
    }

    def checkIsType(node Node) {
      if node.resolvedType != .DYNAMIC && !node.isType {
        log.semanticErrorUnexpectedExpression(node.range, node.resolvedType)
        node.resolvedType = .DYNAMIC
      }
    }

    def checkIsParameterized(node Node) {
      if node.resolvedType.parameters != null && !node.resolvedType.isParameterized {
        log.semanticErrorUnparameterizedType(node.range, node.resolvedType)
        node.resolvedType = .DYNAMIC
      }
    }

    def checkStorage(node Node, scope Scope) {
      var symbol = node.symbol

      # Only allow storage to variables
      if node.kind != .NAME && node.kind != .DOT || symbol != null && !symbol.kind.isVariable {
        log.semanticErrorBadStorage(node.range)
      }

      # Forbid storage to constants
      else if symbol != null && symbol.isConst {
        var function = scope.findEnclosingFunction

        # Allow assignments to constants inside constructors
        if function == null || function.symbol.kind != .FUNCTION_CONSTRUCTOR || function.symbol.parent != symbol.parent || symbol.kind != .VARIABLE_INSTANCE {
          log.semanticErrorStorageToConstSymbol(node.internalRangeOrRange, symbol.name)
        }
      }
    }

    def checkAccess(node Node, range Range, scope Scope) {
      var symbol = node.symbol
      if symbol == null {
        return
      }

      # Check access control
      if symbol.isProtected {
        while scope != null {
          if scope.kind == .OBJECT {
            var object = scope.asObjectScope.symbol
            if object.isSameOrHasBaseClass(symbol.parent) {
              return
            }
          }
          scope = scope.parent
        }
        log.semanticErrorAccessViolation(range, symbol.name)
      }

      # Deprecation annotations optionally provide a warning message
      if symbol.isDeprecated {
        for annotation in symbol.annotations {
          if annotation.symbol != null && annotation.symbol.fullName == "@deprecated" {
            var value = annotation.annotationValue
            if value.kind == .CALL && value.hasTwoChildren {
              var last = value.lastChild
              if last.kind == .CONSTANT && last.content.kind == .STRING {
                log.warning(range, last.content.asString)
                return
              }
            }
          }
        }
        log.semanticWarningDeprecatedUsage(range, symbol.name)
      }
    }

    def checkConversion(node Node, to Type, kind ConversionKind) {
      var from = node.resolvedType
      assert(from != null)
      assert(to != null)

      # The "dynamic" type is a hole in the type system
      if from == .DYNAMIC || to == .DYNAMIC {
        return
      }

      # No conversion is needed for identical types
      if from == to {
        return
      }

      # The implicit conversion must be valid
      if kind == .IMPLICIT && !cache.canImplicitlyConvert(from, to) ||
          kind == .EXPLICIT && !cache.canExplicitlyConvert(from, to) {
        log.semanticErrorIncompatibleTypes(node.range, from, to, cache.canExplicitlyConvert(from, to))
        node.resolvedType = .DYNAMIC
        return
      }

      # Make the implicit conversion explicit for convenience later on
      if kind == .IMPLICIT {
        node.become(Node.createCast(node.cloneAndStealChildren, Node.createType(to)).withType(to).withRange(node.range))
      }
    }

    def resolveAnnotation(node Node, symbol Symbol) bool {
      var value = node.annotationValue
      var test = node.annotationTest

      resolveNode(value, symbol.scope, null)
      if test != null {
        resolveAsParameterizedExpressionWithConversion(test, symbol.scope, cache.boolType)
      }

      # Terminate early when there were errors
      if value.symbol == null {
        return false
      }

      # Make sure annotations have the arguments they need
      if value.kind != .CALL {
        log.semanticErrorArgumentCount(value.range, value.symbol.resolvedType.argumentTypes.count, 0, value.symbol.name, value.symbol.range)
        return false
      }

      # Ensure all arguments are constants
      var isValid = true
      for child = value.callValue.nextSibling; child != null; child = child.nextSibling {
        isValid = isValid && recursivelyResolveAsConstant(child)
      }
      if !isValid {
        return false
      }

      # Only store symbols for annotations with the correct arguments for ease of use
      node.symbol = value.symbol

      # Apply built-in annotation logic
      var flag = annotationSymbolFlags.get(value.symbol.fullName, 0)
      if flag != 0 {
        switch flag {
          case Symbol.IS_DEPRECATED {}
          case Symbol.IS_ENTRY_POINT { isValid = symbol.kind == .FUNCTION_GLOBAL }
          case Symbol.IS_EXPORTED { isValid = !symbol.isImported }
          case Symbol.IS_IMPORTED { isValid = !symbol.isExported && (!symbol.kind.isFunction || symbol.asFunctionSymbol.block == null) }
          case Symbol.IS_INLINING_DISABLED { isValid = symbol.kind.isFunction }
          case Symbol.IS_PREFERRED { isValid = symbol.kind.isFunction }
          case Symbol.IS_RENAMED {}
          case Symbol.IS_SKIPPED { isValid = symbol.kind.isFunction && symbol.resolvedType.returnType == null }
          case Symbol.SHOULD_SPREAD { isValid = symbol.kind == .FUNCTION_ANNOTATION }
        }
        if !isValid {
          log.semanticErrorInvalidAnnotation(value.range, value.symbol.name, symbol.name)
          return false
        }

        # Don't add an annotation when the test expression is false
        if test != null && recursivelyResolveAsConstant(test) && test.isFalse {
          return false
        }

        # Only warn about duplicate annotations after checking the test expression
        if (symbol.flags & flag) != 0 {
          log.semanticErrorDuplicateAnnotation(value.range, value.symbol.name, symbol.name)
        }

        symbol.flags |= flag

        # Store the new name for later
        if flag == Symbol.IS_RENAMED && value.hasTwoChildren {
          symbol.rename = value.lastChild.asString
        }
      }

      return true
    }

    def recursivelyResolveAsConstant(node Node) bool {
      constantFolder.foldConstants(node)

      if node.kind != .CONSTANT {
        log.semanticErrorExpectedConstant(node.range)
        return false
      }

      return true
    }

    def resolveBlock(node Node, scope Scope) {
      assert(node.kind == .BLOCK)
      controlFlow.pushBlock(node)

      for child = node.firstChild, next Node = null; child != null; child = next {
        next = child.nextSibling

        # There is a well-known ambiguity in languages like JavaScript where
        # a return statement followed by a newline and a value can either be
        # parsed as a single return statement with a value or as two
        # statements, a return statement without a value and an expression
        # statement. Luckily, we're better off than JavaScript since we know
        # the type of the function. Parse a single statement in a non-void
        # function but two statements in a void function.
        if child.kind == .RETURN && next != null && child.returnValue == null && next.kind == .EXPRESSION {
          var function = scope.findEnclosingFunctionOrLambda.symbol
          if function.kind != .FUNCTION_CONSTRUCTOR && function.resolvedType.returnType != null {
            child.appendChild(next.remove.expressionValue.remove)
            next = child.nextSibling
            assert(child.returnValue != null)
          }
        }

        resolveNode(child, scope, null)
        controlFlow.visitStatementInPostOrder(child)

        # The "@skip" annotation removes function calls after type checking
        if child.kind == .EXPRESSION {
          var value = child.expressionValue
          if value.kind == .CALL && value.symbol != null && value.symbol.isSkipped {
            child.remove
          }
        }
      }

      controlFlow.popBlock(node)
    }

    def resolvePair(node Node, scope Scope) {
      resolveAsParameterizedExpression(node.firstValue, scope)
      resolveAsParameterizedExpression(node.secondValue, scope)
    }

    def resolveJump(node Node, scope Scope) {
      if scope.findEnclosingLoop == null {
        log.semanticErrorBadJump(node.range, node.kind == .BREAK ? "break" : "continue")
      }
    }

    def resolveExpression(node Node, scope Scope) {
      var value = node.expressionValue
      resolveAsParameterizedExpression(value, scope)
      checkUnusedExpression(value)
    }

    def resolveFor(node Node, scope Scope) {
      var setup = node.forSetup
      var update = node.forUpdate
      scope = LocalScope.new(scope, .LOOP)
      if setup.kind == .VARIABLES {
        resolveNode(setup, scope, null)

        # All for loop variables must have the same type. This is a requirement
        # for one-to-one code emission in the languages we want to target.
        var type = setup.firstChild.symbol.resolvedType
        for child = setup.firstChild.nextSibling; child != null; child = child.nextSibling {
          var symbol = child.symbol
          if symbol.resolvedType != type {
            log.semanticErrorForLoopDifferentType(symbol.range, symbol.name, symbol.resolvedType, type)
            break
          }
        }
      } else {
        resolveAsParameterizedExpression(setup, scope)
      }
      resolveAsParameterizedExpressionWithConversion(node.forTest, scope, cache.boolType)
      resolveAsParameterizedExpression(update, scope)
      if update.kind == .SEQUENCE {
        for child = update.firstChild; child != null; child = child.nextSibling {
          checkUnusedExpression(child)
        }
      }
      resolveBlock(node.forBlock, scope)
    }

    def resolveForeach(node Node, scope Scope) {
      var type Type = .DYNAMIC
      scope = LocalScope.new(scope, .LOOP)

      var value = node.foreachValue
      resolveAsParameterizedExpression(value, scope)

      # Support "for i in 0..10"
      if value.kind == .PAIR {
        var first = value.firstValue
        var second = value.secondValue
        type = cache.intType
        checkConversion(first, cache.intType, .IMPLICIT)
        checkConversion(second, cache.intType, .IMPLICIT)

        # The ".." syntax only counts up, unlike CoffeeScript
        if first.isInt && second.isInt && first.asInt >= second.asInt {
          log.semanticWarningEmptyRange(value.range)
        }
      }

      # Support "for i in [1, 2, 3]"
      else if cache.isList(value.resolvedType) {
        type = value.resolvedType.substitutions[0]
      }

      # Anything else is an error
      else if value.resolvedType != .DYNAMIC {
        log.semanticErrorBadForValue(value.range, value.resolvedType)
      }

      # Special-case symbol initialization with the type
      var symbol = node.symbol.asVariableSymbol
      scope.asLocalScope.define(symbol, log)
      localVariableStatistics[symbol.id] = LocalVariableStatistics.new(symbol)
      symbol.resolvedType = type
      symbol.flags |= Symbol.IS_CONST | Symbol.IS_LOOP_VARIABLE
      symbol.state = .INITIALIZED

      resolveBlock(node.foreachBlock, scope)

      # Collect foreach loops and convert them in another pass
      foreachLoops.append(node)
    }

    def resolveIf(node Node, scope Scope) {
      var test = node.ifTest
      var ifFalse = node.ifFalse
      resolveAsParameterizedExpressionWithConversion(test, scope, cache.boolType)
      resolveBlock(node.ifTrue, LocalScope.new(scope, .NORMAL))
      if ifFalse != null {
        resolveBlock(ifFalse, LocalScope.new(scope, .NORMAL))
      }
    }

    def resolveReturn(node Node, scope Scope) {
      var value = node.returnValue
      var function = scope.findEnclosingFunctionOrLambda.symbol
      var returnType = function.kind != .FUNCTION_CONSTRUCTOR ? function.resolvedType.returnType : null

      # Check for a returned value
      if value == null {
        if returnType != null {
          log.semanticErrorExpectedReturnValue(node.range, returnType)
        }
        return
      }

      # Check the type of the returned value
      if returnType != null {
        resolveAsParameterizedExpressionWithConversion(value, scope, returnType)
        return
      }

      # If there's no return type, still check for other errors
      resolveAsParameterizedExpression(value, scope)

      # Lambdas without a return type or an explicit "return" statement get special treatment
      if !node.isImplicitReturn {
        log.semanticErrorUnexpectedReturnValue(value.range)
        return
      }

      # Check for a return value of type "void"
      if !function.shouldInferReturnType || value.kind == .CALL && value.symbol != null && value.symbol.resolvedType.returnType == null {
        checkUnusedExpression(value)
        node.kind = .EXPRESSION
        return
      }

      # Check for an invalid return type
      var type = value.resolvedType
      if !isValidVariableType(type) {
        log.semanticErrorBadReturnType(value.range, type)
        node.kind = .EXPRESSION
        return
      }

      # Mutate the return type to the type from the returned value
      function.returnType = Node.createType(type)
    }

    def resolveSwitch(node Node, scope Scope) {
      var duplicateCases IntMap<Range> = {}
      var mustEnsureConstantIntegers = options.target.requiresIntegerSwitchStatements
      var allValuesAreIntegers = true
      var value = node.switchValue
      resolveAsParameterizedExpression(value, scope)

      for child = value.nextSibling; child != null; child = child.nextSibling {
        var block = child.caseBlock

        # Resolve all case values
        for caseValue = child.firstChild; caseValue != block; caseValue = caseValue.nextSibling {
          resolveAsParameterizedExpressionWithConversion(caseValue, scope, value.resolvedType)

          var symbol = caseValue.symbol
          var integer = 0

          # Check for a constant variable, which may just be read-only with a
          # value determined at runtime
          if symbol != null && (mustEnsureConstantIntegers ? symbol.kind == .VARIABLE_ENUM : symbol.kind.isVariable && symbol.isConst) {
            var constant = constantFolder.constantForSymbol(symbol.asVariableSymbol)
            if constant == null || constant.kind != .INT {
              allValuesAreIntegers = false
              continue
            }
            integer = constant.asInt
          }

          # Fall back to the constant folder only as a last resort because it
          # mutates the syntax tree and harms readability
          else {
            constantFolder.foldConstants(caseValue)
            if !caseValue.isInt {
              allValuesAreIntegers = false
              continue
            }
            integer = caseValue.asInt
          }

          # Duplicate case detection
          var previous = duplicateCases.get(integer, null)
          if previous != null {
            log.semanticErrorDuplicateCase(caseValue.range, previous)
          } else {
            duplicateCases[integer] = caseValue.range
          }
        }

        # The default case must be last, makes changing into an if chain easier later
        if child.hasOneChild && child.nextSibling != null {
          log.semanticErrorDefaultCaseNotLast(child.range)
        }

        resolveBlock(block, LocalScope.new(scope, .NORMAL))
      }

      # Fall back to an if statement if the case values aren't compile-time
      # integer constants, which is requried by many language targets
      if !allValuesAreIntegers && mustEnsureConstantIntegers {
        convertSwitchToIfChain(node, scope)
      }
    }

    def resolveThrow(node Node, scope Scope) {
      var value = node.throwValue
      resolveAsParameterizedExpression(value, scope)
    }

    def resolveVariable(node Node, scope Scope) {
      var symbol = node.symbol.asVariableSymbol
      scope.asLocalScope.define(symbol, log)
      localVariableStatistics[symbol.id] = LocalVariableStatistics.new(symbol)
      resolveVariable(symbol)
    }

    def resolveVariables(node Node, scope Scope) {
      for child = node.firstChild; child != null; child = child.nextSibling {
        resolveVariable(child, scope)
      }
    }

    def resolveTry(node Node, scope Scope) {
      var tryBlock = node.tryBlock
      var finallyBlock = node.finallyBlock
      resolveBlock(tryBlock, LocalScope.new(scope, .NORMAL))

      # Bare try statements catch all thrown values
      if node.hasOneChild {
        node.appendChild(Node.createCatch(null, Node.createBlock))
      }

      # Check catch statements
      for child = tryBlock.nextSibling; child != finallyBlock; child = child.nextSibling {
        var childScope = LocalScope.new(scope, .NORMAL)
        if child.symbol != null {
          var symbol = child.symbol.asVariableSymbol
          childScope.define(symbol, log)
          resolveVariable(symbol)
        }
        resolveBlock(child.catchBlock, childScope)
      }

      # Check finally block
      if finallyBlock != null {
        resolveBlock(finallyBlock, LocalScope.new(scope, .NORMAL))
      }
    }

    def resolveWhile(node Node, scope Scope) {
      resolveAsParameterizedExpressionWithConversion(node.whileTest, scope, cache.boolType)
      resolveBlock(node.whileBlock, LocalScope.new(scope, .LOOP))
    }

    def resolveCall(node Node, scope Scope) {
      var value = node.callValue
      resolveAsParameterizedExpression(value, scope)
      var type = value.resolvedType

      switch type.kind {
        # Each function has its own type for simplicity
        case .SYMBOL {
          if resolveSymbolCall(node, scope, type) {
            return
          }
        }

        # Lambda types look like "fn(int, int) int"
        case .LAMBDA {
          if resolveFunctionCall(node, scope, type) {
            return
          }
        }

        # Can't call other types (the null type, for example)
        default {
          if type != .DYNAMIC {
            log.semanticErrorInvalidCall(node.internalRangeOrRange, value.resolvedType)
          }
        }
      }

      # If there was an error, resolve the arguments to check for further
      # errors but use a dynamic type context to avoid introducing errors
      for child = value.nextSibling; child != null; child = child.nextSibling {
        resolveAsParameterizedExpressionWithConversion(child, scope, .DYNAMIC)
      }
    }

    def resolveSymbolCall(node Node, scope Scope, type Type) bool {
      var symbol = type.symbol

      # Getters are called implicitly, so explicitly calling one is an error.
      # This error prevents a getter returning a lambda which is then called.
      # To overcome this, wrap the call in parentheses:
      #
      #   def foo fn()
      #
      #   def bar {
      #     foo()   # Error
      #     (foo)() # Correct
      #   }
      #
      if symbol.isGetter && isCallValue(node) && !node.callValue.isInsideParentheses {
        if symbol.resolvedType.returnType != null && symbol.resolvedType.returnType.kind == .LAMBDA {
          log.semanticErrorGetterRequiresWrap(node.range, symbol.name, symbol.range)
        } else {
          log.semanticErrorGetterCalledTwice(node.parent.internalRangeOrRange, symbol.name, symbol.range)
        }
        return false
      }

      # Check for calling a function directly
      if symbol.kind.isFunction {
        return resolveFunctionCall(node, scope, type)
      }

      # Check for calling a set of functions, must not be ambiguous
      if symbol.kind.isOverloadedFunction {
        return resolveOverloadedFunctionCall(node, scope, type)
      }

      # Can't call other symbols
      log.semanticErrorInvalidCall(node.internalRangeOrRange, node.callValue.resolvedType)
      return false
    }

    def resolveFunctionCall(node Node, scope Scope, type Type) bool {
      var function = type.symbol != null ? type.symbol.asFunctionSymbol : null
      var expected = type.argumentTypes.count
      var count = node.childCount - 1
      node.symbol = function

      # Use the return type even if there were errors
      if type.returnType != null {
        node.resolvedType = type.returnType
      }

      # There is no "void" type, so make sure this return value isn't used
      else if isVoidExpressionUsed(node) {
        if function != null {
          log.semanticErrorUseOfVoidFunction(node.range, function.name, function.range)
        } else {
          log.semanticErrorUseOfVoidLambda(node.range)
        }
      }

      # Check argument count
      if expected != count {
        log.semanticErrorArgumentCount(node.internalRangeOrRange, expected, count, function != null ? function.name : "", function != null ? function.range : null)
        return false
      }

      # Check argument types
      var value = node.firstChild
      var child = value.nextSibling
      for argumentType in type.argumentTypes {
        resolveAsParameterizedExpressionWithConversion(child, scope, argumentType)
        child = child.nextSibling
      }

      # Forbid constructing an abstract type
      if !options.target.allowAbstractConstruction && function != null && function.kind == .FUNCTION_CONSTRUCTOR &&
          isAbstractObject(function.parent.asObjectSymbol) && value.kind != .SUPER {
        var reason = function.parent.asObjectSymbol.isAbstractBecauseOf
        log.semanticErrorAbstractNew(node.internalRangeOrRange, function.parent.resolvedType, reason.range, reason.name)
      }

      # Replace overloaded symbols with the chosen overload
      if function != null && function.overloaded != null && value.symbol == function.overloaded {
        value.symbol = function
      }

      return true
    }

    def resolveOverloadedFunction(range Range, node Node, scope Scope, symbolType Type) Type {
      var overloaded = symbolType.symbol.asOverloadedFunctionSymbol
      var firstArgument = node.firstChild.nextSibling
      var count = node.childCount - 1
      var candidates List<Type> = []

      # Filter by argument length and substitute using the current type environment
      for symbol in overloaded.symbols {
        if symbol.arguments.count == count || overloaded.symbols.count == 1 {
          candidates.append(cache.substitute(symbol.resolvedType, symbolType.environment))
        }
      }

      # Check for matches
      if candidates.isEmpty {
        log.semanticErrorNoMatchingOverload(range, overloaded.name, count, null)
        return null
      }

      # Check for an unambiguous match
      if candidates.count == 1 {
        return candidates[0]
      }

      # First filter by syntactic structure impossibilities. This helps break
      # the chicken-and-egg problem of needing to resolve argument types to
      # get a match and needing a match to resolve argument types. For example,
      # a list literal needs type context to resolve correctly.
      var index = 0
      while index < candidates.count {
        var child = firstArgument
        for type in candidates[index].argumentTypes {
          var kind = child.kind
          if kind == .NULL && !type.isReference ||
              kind == .INITIALIZER_LIST && findMember(type, "[new]") == null && findMember(type, "[...]") == null ||
              kind == .INITIALIZER_MAP && findMember(type, "{new}") == null && findMember(type, "{...}") == null {
            candidates.removeAt(index)
            index--
            break
          }
          child = child.nextSibling
        }
        index++
      }

      # Check for an unambiguous match
      if candidates.count == 1 {
        return candidates[0]
      }

      # If that still didn't work, resolve the arguments without type context
      for child = firstArgument; child != null; child = child.nextSibling {
        resolveAsParameterizedExpression(child, scope)
      }

      # Try again, this time discarding all implicit conversion failures
      index = 0
      while index < candidates.count {
        var child = firstArgument
        for type in candidates[index].argumentTypes {
          if !cache.canImplicitlyConvert(child.resolvedType, type) {
            candidates.removeAt(index)
            index--
            break
          }
          child = child.nextSibling
        }
        index++
      }

      # Check for an unambiguous match
      if candidates.count == 1 {
        return candidates[0]
      }

      # Extract argument types for an error if there is one
      var childTypes List<Type> = []
      for child = firstArgument; child != null; child = child.nextSibling {
        childTypes.append(child.resolvedType)
      }

      # Give up without a match
      if candidates.isEmpty {
        log.semanticErrorNoMatchingOverload(range, overloaded.name, count, childTypes)
        return null
      }

      # If that still didn't work, try type equality
      for type in candidates {
        var isMatch = true
        for i in 0..count {
          if childTypes[i] != type.argumentTypes[i] {
            isMatch = false
            break
          }
        }
        if isMatch {
          return type
        }
      }

      # If that still didn't work, try picking the preferred overload
      var firstPreferred Type = null
      var secondPreferred Type = null
      for type in candidates {
        if type.symbol.isPreferred {
          secondPreferred = firstPreferred
          firstPreferred = type
        }
      }

      # Check for a single preferred overload
      if firstPreferred != null && secondPreferred == null {
        return firstPreferred
      }

      # Give up since the overload is ambiguous
      log.semanticErrorAmbiguousOverload(range, overloaded.name, count, childTypes)
      return null
    }

    def resolveOverloadedFunctionCall(node Node, scope Scope, type Type) bool {
      var match = resolveOverloadedFunction(node.callValue.range, node, scope, type)
      if match != null && resolveFunctionCall(node, scope, match) {
        checkAccess(node, node.callValue.internalRangeOrRange, scope)
        return true
      }
      return false
    }

    def resolveCast(node Node, scope Scope, context Type) {
      var value = node.castValue
      var type = node.castType
      resolveAsParameterizedType(type, scope)
      resolveAsParameterizedExpressionWithTypeContext(value, scope, type.resolvedType)
      checkConversion(value, type.resolvedType, .EXPLICIT)
      node.resolvedType = type.resolvedType

      # Warn about unnecessary casts
      if type.resolvedType != .DYNAMIC && (value.resolvedType == type.resolvedType ||
          context == type.resolvedType && cache.canImplicitlyConvert(value.resolvedType, type.resolvedType)) {
        log.semanticWarningExtraCast(Range.span(node.internalRangeOrRange, type.range), value.resolvedType, type.resolvedType)
      }
    }

    def resolveConstant(node Node, scope Scope) {
      switch node.content.kind {
        case .BOOL { node.resolvedType = cache.boolType }
        case .DOUBLE { node.resolvedType = cache.doubleType }
        case .INT { node.resolvedType = cache.intType }
        case .STRING { node.resolvedType = cache.stringType }
        default { assert(false) }
      }
    }

    def findOverriddenMember(symbol Symbol) Symbol {
      if symbol.parent != null && symbol.parent.kind == .OBJECT_CLASS {
        var object = symbol.parent.asObjectSymbol
        if object.baseClass != null {
          return findMember(object.baseClass.resolvedType, symbol.name)
        }
      }
      return null
    }

    def forbidOverriddenSymbol(symbol Symbol) {
      var overridden = findOverriddenMember(symbol)
      if overridden != null {
        log.semanticErrorBadOverride(symbol.range, symbol.name, symbol.parent.asObjectSymbol.base.resolvedType, overridden.range)
      }
    }

    def findMember(type Type, name string) Symbol {
      var check = type
      while check != null {
        if check.kind == .SYMBOL {
          var symbol = check.symbol
          if symbol.kind.isObject {
            var member = symbol.asObjectSymbol.members.get(name, null)
            if member != null {
              initializeSymbol(member)
              return member
            }
          }
        }
        check = check.baseClass
      }
      return null
    }

    def resolveDot(node Node, scope Scope, context Type) {
      var target = node.dotTarget
      var name = node.asString

      # Infer the target from the type context if it's omitted
      if target == null {
        if context == null {
          log.semanticErrorMissingDotContext(node.range, name)
          return
        }
        target = Node.createType(context)
        node.appendChild(target)
        assert(node.dotTarget == target)
      } else {
        resolveNode(target, scope, null)
      }

      # Search for a setter first, then search for a normal member
      var symbol Symbol = null
      if shouldCheckForSetter(node) {
        symbol = findMember(target.resolvedType, name + "=")
      }
      if symbol == null {
        symbol = findMember(target.resolvedType, name)
        if symbol == null {
          if target.resolvedType != .DYNAMIC {
            reportGuardMergingFailure(node)
            log.semanticErrorUnknownMemberSymbol(node.internalRangeOrRange, name, target.resolvedType)
          }
          if target.kind == .TYPE && target.resolvedType == .DYNAMIC {
            node.kind = .NAME
            node.removeChildren
          }
          return
        }
      }

      # Forbid referencing a base class global or constructor function from a derived class
      if isBaseGlobalReference(target.resolvedType.symbol, symbol) {
        log.semanticErrorUnknownMemberSymbol(node.internalRangeOrRange, name, target.resolvedType)
        return
      }

      var isType = target.isType
      var needsType = !symbol.kind.isOnInstances

      # Make sure the global/instance context matches the intended usage
      if isType {
        if !needsType {
          log.semanticErrorMemberUnexpectedInstance(node.internalRangeOrRange, symbol.name)
        } else if symbol.kind.isFunctionOrOverloadedFunction {
          checkIsParameterized(target)
        } else if target.resolvedType.isParameterized {
          log.semanticErrorParameterizedType(target.range, target.resolvedType)
        }
      } else if needsType {
        log.semanticErrorMemberUnexpectedGlobal(node.internalRangeOrRange, symbol.name)
      }

      # Always access referenced globals directly
      if symbol.kind.isGlobalReference {
        node.kind = .NAME
        node.removeChildren
      }

      node.symbol = symbol
      node.resolvedType = cache.substitute(symbol.resolvedType, target.resolvedType.environment)
      automaticallyCallGetter(node, scope)
    }

    def resolveHook(node Node, scope Scope, context Type) {
      resolveAsParameterizedExpressionWithConversion(node.hookTest, scope, cache.boolType)

      var trueValue = node.hookTrue
      var falseValue = node.hookFalse

      # Use the type context from the parent
      if context != null {
        resolveAsParameterizedExpressionWithConversion(trueValue, scope, context)
        resolveAsParameterizedExpressionWithConversion(falseValue, scope, context)
        node.resolvedType = context
      }

      # Find the common type from both branches
      else {
        resolveAsParameterizedExpression(trueValue, scope)
        resolveAsParameterizedExpression(falseValue, scope)
        var commonType = cache.commonImplicitType(trueValue.resolvedType, falseValue.resolvedType)

        # Insert casts if needed since some targets can't perform this type inference
        if commonType != null {
          checkConversion(trueValue, commonType, .IMPLICIT)
          checkConversion(falseValue, commonType, .IMPLICIT)
          node.resolvedType = commonType
        } else {
          log.semanticErrorNoCommonType(Range.span(trueValue.range, falseValue.range), trueValue.resolvedType, falseValue.resolvedType)
        }
      }
    }

    def resolveInitializer(node Node, scope Scope, context Type) {
      # Make sure to resolve the children even if the initializer is invalid
      if context != null {
        if context == .DYNAMIC || !resolveInitializerWithContext(node, scope, context) {
          resolveChildrenAsParameterizedExpressions(node, scope)
        }
        return
      }

      # First pass: only children with type context, second pass: all children
      for pass in 0..2 {
        switch node.kind {
          case .INITIALIZER_LIST {
            var type Type = null

            # Resolve all children for this pass
            for child = node.firstChild; child != null; child = child.nextSibling {
              if pass != 0 || !needsTypeContext(child) {
                resolveAsParameterizedExpression(child, scope)
                type = mergeCommonType(type, child)
              }
            }

            # Resolve remaining children using the type context if valid
            if type != null && isValidVariableType(type) {
              resolveInitializerWithContext(node, scope, cache.createListType(type))
              return
            }
          }

          case .INITIALIZER_MAP {
            var keyType Type = null
            var valueType Type = null

            # Resolve all children for this pass
            for child = node.firstChild; child != null; child = child.nextSibling {
              var key = child.firstValue
              var value = child.secondValue
              if pass != 0 || !needsTypeContext(key) {
                resolveAsParameterizedExpression(key, scope)
                keyType = mergeCommonType(keyType, key)
              }
              if pass != 0 || !needsTypeContext(value) {
                resolveAsParameterizedExpression(value, scope)
                valueType = mergeCommonType(valueType, value)
              }
            }

            # Resolve remaining children using the type context if valid
            if keyType != null && valueType != null && isValidVariableType(keyType) && isValidVariableType(valueType) {
              if keyType == cache.intType {
                resolveInitializerWithContext(node, scope, cache.createIntMapType(valueType))
                return
              }
              if keyType == cache.stringType {
                resolveInitializerWithContext(node, scope, cache.createStringMapType(valueType))
                return
              }
            }
          }
        }
      }

      log.semanticErrorInitializerTypeInferenceFailed(node.range)
    }

    def resolveInitializerWithContext(node Node, scope Scope, context Type) bool {
      var isList = node.kind == .INITIALIZER_LIST
      var create = findMember(context, isList ? "[new]" : "{new}")
      var add = findMember(context, isList ? "[...]" : "{...}")

      # Special-case imported literals to prevent an infinite loop for list literals
      if add != null && add.isImported {
        var function = add.asFunctionSymbol
        if function.arguments.count == (isList ? 1 : 2) {
          var functionType = cache.substitute(function.resolvedType, context.environment)
          for child = node.firstChild; child != null; child = child.nextSibling {
            if child.kind == .PAIR {
              resolveAsParameterizedExpressionWithConversion(child.firstValue, scope, functionType.argumentTypes[0])
              resolveAsParameterizedExpressionWithConversion(child.secondValue, scope, functionType.argumentTypes[1])
            } else {
              resolveAsParameterizedExpressionWithConversion(child, scope, functionType.argumentTypes[0])
            }
          }
          node.resolvedType = context
          return true
        }
      }

      # Use simple call chaining when there's an add operator present
      if add != null {
        var chain = Node.createDot(Node.createType(context).withRange(node.range), create != null ? create.name : "new").withRange(node.range)
        while node.hasChildren {
          var child = node.firstChild.remove
          var dot = Node.createDot(chain, add.name).withRange(child.range)
          chain = Node.createCall(dot).withRange(child.range)
          if child.kind == .PAIR {
            chain.appendChildrenFrom(child)
          } else {
            chain.appendChild(child)
          }
        }
        node.become(chain)
        resolveAsParameterizedExpressionWithConversion(node, scope, context)
        return true
      }

      # Make sure there's a constructor to call
      if create == null {
        log.semanticErrorInitializerTypeInferenceFailed(node.range)
        return false
      }

      var dot = Node.createDot(Node.createType(context).withRange(node.range), create.name).withRange(node.range)

      # Call the initializer constructor
      if node.kind == .INITIALIZER_MAP {
        var firstValues = Node.createList
        var secondValues = Node.createList
        for child = node.firstChild; child != null; child = child.nextSibling {
          var first = child.firstValue
          var second = child.secondValue
          firstValues.appendChild(first.remove)
          secondValues.appendChild(second.remove)
        }
        node.become(Node.createCall(dot).withRange(node.range).appendChild(firstValues).appendChild(secondValues))
      } else {
        node.become(Node.createCall(dot).withRange(node.range).appendChild(Node.createList.appendChildrenFrom(node)))
      }
      resolveAsParameterizedExpressionWithConversion(node, scope, context)
      return true
    }

    def mergeCommonType(commonType Type, child Node) Type {
      if commonType == null || child.resolvedType == .DYNAMIC {
        return child.resolvedType
      }

      var result = cache.commonImplicitType(commonType, child.resolvedType)
      if result != null {
        return result
      }

      log.semanticErrorNoCommonType(child.range, commonType, child.resolvedType)
      return .DYNAMIC
    }

    def resolveLambda(node Node, scope Scope, context Type) {
      var symbol = node.symbol.asFunctionSymbol
      symbol.scope = FunctionScope.new(scope, symbol)

      # Use type context to implicitly set missing types
      if context != null && context.kind == .LAMBDA {

        # Copy over the argument types if they line up
        if context.argumentTypes.count == symbol.arguments.count {
          for i in 0..symbol.arguments.count {
            var argument = symbol.arguments[i]
            if argument.type == null {
              argument.type = Node.createType(context.argumentTypes[i])
            }
          }
        }

        # Copy over the return type
        if symbol.returnType == null && context.returnType != null {
          symbol.returnType = Node.createType(context.returnType)
        }
      }

      else {
        # Only infer non-void return types if there's no type context
        if symbol.returnType == null {
          symbol.flags |= Symbol.SHOULD_INFER_RETURN_TYPE
        }

        # Take argument types from call argument values for immediately-invoked
        # function expressions:
        #
        #   var sum = ((a, b) => a + b)(1, 2)
        #
        if isCallValue(node) && node.parent.childCount == symbol.arguments.count + 1 {
          var child = node.nextSibling
          for i in 0..symbol.arguments.count {
            var argument = symbol.arguments[i]
            if argument.type == null {
              resolveAsParameterizedExpression(child, scope)
              argument.type = Node.createType(child.resolvedType)
            }
            child = child.nextSibling
          }
        }
      }

      resolveFunction(symbol)

      # Use a LambdaType instead of a SymbolType for the node
      var argumentTypes List<Type> = []
      var returnType = symbol.returnType
      for argument in symbol.arguments {
        argumentTypes.append(argument.resolvedType)
      }
      node.resolvedType = cache.createLambdaType(argumentTypes, returnType != null ? returnType.resolvedType : null)
    }

    def resolveLambdaType(node Node, scope Scope) {
      var lambdaReturnType = node.lambdaReturnType
      var argumentTypes List<Type> = []
      var returnType Type = null

      for child = node.firstChild; child != lambdaReturnType; child = child.nextSibling {
        resolveAsParameterizedType(child, scope)
        argumentTypes.append(child.resolvedType)
      }

      # An empty return type is signaled by the type "null"
      if lambdaReturnType.kind != .TYPE || lambdaReturnType.resolvedType != null {
        resolveAsParameterizedType(lambdaReturnType, scope)
        returnType = lambdaReturnType.resolvedType
      }

      node.resolvedType = cache.createLambdaType(argumentTypes, returnType)
    }

    def resolveName(node Node, scope Scope) {
      var enclosingFunction = scope.findEnclosingFunction
      var name = node.asString
      var symbol Symbol = null

      # Search for a setter first, then search for a normal symbol
      if shouldCheckForSetter(node) {
        symbol = scope.find(name + "=")
      }

      # If a setter wasn't found, search for a normal symbol
      if symbol == null {
        symbol = scope.find(name)
        if symbol == null {
          reportGuardMergingFailure(node)
          log.semanticErrorUndeclaredSymbol(node.range, name)
          return
        }
      }

      initializeSymbol(symbol)

      # Track reads and writes of local variables for later use
      recordStatistic(symbol, node.isAssignTarget ? .WRITE : .READ)

      # Forbid referencing a base class global or constructor function from a derived class
      if enclosingFunction != null && isBaseGlobalReference(enclosingFunction.symbol.parent, symbol) {
        log.semanticErrorUndeclaredSymbol(node.range, name)
        return
      }

      # Automatically insert "self." before instance symbols
      if symbol.kind.isOnInstances {
        var variable = enclosingFunction != null ? enclosingFunction.symbol.this : null
        if variable != null && enclosingFunction.symbol.parent.asObjectSymbol.isSameOrHasBaseClass(symbol.parent) {
          node.become(Node.createDot(Node.createSymbolReference(variable), name).withRange(node.range))
        } else {
          log.semanticErrorMemberUnexpectedInstance(node.range, symbol.name)
        }
      }

      # Type parameters for objects may only be used in certain circumstances
      else if symbol.kind == .PARAMETER_OBJECT {
        var parent = scope
        var isValid = false

        while parent != null {
          switch parent.kind {
            case .OBJECT {
              isValid = parent.asObjectScope.symbol == symbol.parent
              break
            }

            case .FUNCTION {
              var function = parent.asFunctionScope.symbol
              if function.kind != .FUNCTION_LOCAL {
                isValid = function.parent == symbol.parent
                break
              }
            }

            case .VARIABLE {
              var variable = parent.asVariableScope.symbol
              isValid = variable.kind == .VARIABLE_INSTANCE && variable.parent == symbol.parent
              break
            }
          }

          parent = parent.parent
        }

        if !isValid {
          log.semanticErrorMemberUnexpectedTypeParameter(node.range, symbol.name)
        }
      }

      node.symbol = symbol
      node.resolvedType = symbol.resolvedType
      automaticallyCallGetter(node, scope)
    }

    def resolveParameterize(node Node, scope Scope) {
      var value = node.parameterizeValue
      resolveNode(value, scope, null)

      # Resolve parameter types
      var substitutions List<Type> = []
      var count = 0
      for child = value.nextSibling; child != null; child = child.nextSibling {
        resolveAsParameterizedType(child, scope)
        substitutions.append(child.resolvedType)
        count++
      }

      # Check for type parameters
      var type = value.resolvedType
      var parameters = type.parameters
      if parameters == null || type.isParameterized {
        if type != .DYNAMIC {
          log.semanticErrorCannotParameterize(node.range, type)
        }
        value.resolvedType = .DYNAMIC
        return
      }

      # Check parameter count
      var expected = parameters.count
      if count != expected {
        log.semanticErrorParameterCount(node.internalRangeOrRange, expected, count)
        value.resolvedType = .DYNAMIC
        return
      }

      # Make sure all parameters have types
      for parameter in parameters {
        initializeSymbol(parameter)
      }

      # Include the symbol for use with Node.isType
      node.resolvedType = cache.substitute(type, cache.mergeEnvironments(type.environment, cache.createEnvironment(parameters, substitutions), null))
      node.symbol = value.symbol
    }

    def resolveSequence(node Node, scope Scope, context Type) {
      for child = node.firstChild; child != null; child = child.nextSibling {
        resolveAsParameterizedExpressionWithTypeContext(child, scope, child.nextSibling == null ? context : null)
      }
    }

    def resolveSuper(node Node, scope Scope) {
      var function = scope.findEnclosingFunction
      var symbol = function == null ? null : function.symbol
      var overridden = symbol == null ? null : symbol.overloaded != null ? symbol.overloaded.overridden : symbol.overridden

      if overridden == null {
        log.semanticErrorBadSuper(node.range)
        return
      }

      # Calling a static method doesn't need special handling
      if overridden.kind == .FUNCTION_GLOBAL {
        node.kind = .NAME
      }

      node.resolvedType = overridden.resolvedType
      node.symbol = overridden
      automaticallyCallGetter(node, scope)
    }

    def resolveTypeCheck(node Node, scope Scope) {
      var value = node.typeCheckValue
      var type = node.typeCheckType

      resolveAsParameterizedExpression(value, scope)
      resolveAsParameterizedType(type, scope)
      checkConversion(value, type.resolvedType, .EXPLICIT)
      node.resolvedType = cache.boolType

      # Warn about unnecessary type checks
      if value.resolvedType != .DYNAMIC && cache.canImplicitlyConvert(value.resolvedType, type.resolvedType) {
        log.semanticWarningExtraTypeCheck(Range.span(node.internalRangeOrRange, type.range), value.resolvedType, type.resolvedType)
      }
    }

    def resolveBinary(node Node, scope Scope) {
      var kind = node.kind
      var left = node.binaryLeft
      var right = node.binaryRight

      # Special-case the equality operators
      if kind == .EQUAL || kind == .NOT_EQUAL {
        if needsTypeContext(left) {
          resolveAsParameterizedExpression(right, scope)
          resolveAsParameterizedExpressionWithTypeContext(left, scope, right.resolvedType)
        } else if needsTypeContext(right) {
          resolveAsParameterizedExpression(left, scope)
          resolveAsParameterizedExpressionWithTypeContext(right, scope, left.resolvedType)
        } else {
          resolveAsParameterizedExpression(left, scope)
          resolveAsParameterizedExpression(right, scope)
        }

        # The two types must be compatible
        var commonType = cache.commonImplicitType(left.resolvedType, right.resolvedType)
        if commonType == null {
          log.semanticErrorNoCommonType(node.range, left.resolvedType, right.resolvedType)
        } else {
          node.resolvedType = cache.boolType
        }

        return
      }

      # Special-case assignment since it's not overridable
      if kind == .ASSIGN {
        resolveAsParameterizedExpression(left, scope)

        # Automatically call setters
        if left.symbol != null && left.symbol.isSetter {
          node.become(Node.createCall(left.remove).withRange(node.range).withInternalRange(right.range).appendChild(right.remove))
          resolveAsParameterizedExpression(node, scope)
        }

        # Resolve the right side using type context from the left side
        else {
          resolveAsParameterizedExpressionWithConversion(right, scope, left.resolvedType)
          node.resolvedType = left.resolvedType
          checkStorage(left, scope)
        }

        return
      }

      # Special-case short-circuit logical operators since they aren't overridable
      if kind == .LOGICAL_AND || kind == .LOGICAL_OR {
        resolveAsParameterizedExpressionWithConversion(left, scope, cache.boolType)
        resolveAsParameterizedExpressionWithConversion(right, scope, cache.boolType)
        node.resolvedType = cache.boolType
        return
      }

      resolveOperatorOverload(node, scope)
    }

    def resolveOperatorOverload(node Node, scope Scope) {
      # The order of operands are reversed for the "in" operator
      var kind = node.kind
      var reverseBinaryOrder = kind == .IN
      var first = node.firstChild
      var second = first.nextSibling
      var target = reverseBinaryOrder ? second : first
      var other = kind.isBinary ? reverseBinaryOrder ? first : second : null

      # Allow "foo in [.FOO, .BAR]"
      if kind == .IN && target.kind == .INITIALIZER_LIST && !needsTypeContext(other) {
        resolveAsParameterizedExpression(other, scope)
        resolveAsParameterizedExpressionWithTypeContext(target, scope, other.resolvedType != .DYNAMIC ? cache.createListType(other.resolvedType) : null)
      }

      # Resolve just the target since the other arguments may need type context from overload resolution
      else {
        resolveAsParameterizedExpression(target, scope)
      }

      # Can't do overload resolution on the dynamic type
      var type = target.resolvedType
      if type == .DYNAMIC {
        if kind.isAssign {
          checkStorage(target, scope)
        }
        resolveChildrenAsParameterizedExpressions(node, scope)
        return
      }

      # Check if the operator can be overridden at all
      var info = operatorInfo[kind]
      if info.kind != .OVERRIDABLE {
        log.semanticErrorUnknownMemberSymbol(node.internalRangeOrRange, info.text, type)
        resolveChildrenAsParameterizedExpressions(node, scope)
        return
      }

      # Auto-convert int to double when it appears as the target
      if other != null && type == cache.intType {
        resolveAsParameterizedExpression(other, scope)
        if other.resolvedType == cache.doubleType {
          checkConversion(target, cache.doubleType, .IMPLICIT)
          type = cache.doubleType
        }
      }

      # Find the operator method
      var isComparison = kind.isBinaryComparison
      var name = isComparison ? "<=>" : info.text
      var symbol = findMember(type, name)
      if symbol == null {
        log.semanticErrorUnknownMemberSymbol(node.internalRangeOrRange, name, type)
        resolveChildrenAsParameterizedExpressions(node, scope)
        return
      }
      var symbolType = cache.substitute(symbol.resolvedType, type.environment)

      # Resolve the overload now so the symbol's properties can be inspected
      if symbol.kind.isOverloadedFunction {
        if reverseBinaryOrder {
          first.swapWith(second)
        }
        symbolType = resolveOverloadedFunction(node.internalRangeOrRange, node, scope, symbolType)
        if reverseBinaryOrder {
          first.swapWith(second)
        }
        if symbolType == null {
          resolveChildrenAsParameterizedExpressions(node, scope)
          return
        }
        symbol = symbolType.symbol
      }

      var isRawImport = symbol.isImported && !symbol.isRenamed
      node.symbol = symbol
      checkAccess(node, node.internalRangeOrRange, scope)

      # Check for a valid storage location for imported operators
      if kind.isAssign && symbol.isImported {
        checkStorage(target, scope)
      }

      # "<", ">", "<=", or ">="
      if isComparison && (isRawImport || type == cache.doubleType) {
        resolveChildrenAsParameterizedExpressions(node, scope)
        node.resolvedType = cache.boolType
        node.symbol = null
        return
      }

      # "<=>"
      if kind == .COMPARE && isRawImport {
        resolveChildrenAsParameterizedExpressions(node, scope)
        node.kind = .SUBTRACT
        node.resolvedType = cache.intType
        node.symbol = null
        return
      }

      # Don't replace the operator with a call if it's just used for type checking
      if isRawImport {
        if reverseBinaryOrder {
          first.swapWith(second)
        }
        if !resolveFunctionCall(node, scope, symbolType) {
          resolveChildrenAsParameterizedExpressions(node, scope)
        }
        if reverseBinaryOrder {
          first.swapWith(second)
        }
        return
      }

      # Resolve the method call
      if reverseBinaryOrder {
        first.swapWith(second)
      }
      target = Node.createDot(target.remove, name).withSymbol(symbol).withRange(node.internalRangeOrRange)
      node.prependChild(target)

      # Implement the logic for the "<=>" operator
      if isComparison {
        var call = Node.new(.CALL).appendChildrenFrom(node).withRange(node.range)
        node.appendChild(call)
        node.appendChild(Node.createInt(0).withType(cache.intType))
        node.resolvedType = cache.boolType
        resolveFunctionCall(call, scope, symbolType)
        return
      }

      # All other operators are just normal method calls
      node.kind = .CALL
      resolveFunctionCall(node, scope, symbolType)
    }

    def automaticallyCallGetter(node Node, scope Scope) bool {
      var symbol = node.symbol
      if symbol == null {
        return false
      }
      var kind = symbol.kind
      var parent = node.parent

      # The check for getters is complicated by overloaded functions
      if !symbol.isGetter && kind.isOverloadedFunction && (!isCallValue(node) || parent.hasOneChild) {
        var overloaded = symbol.asOverloadedFunctionSymbol
        for getter in overloaded.symbols {

          # Just return the first getter assuming errors for duplicate getters
          # were already logged when the overloaded symbol was initialized
          if getter.isGetter {
            node.resolvedType = cache.substitute(getter.resolvedType, node.resolvedType.environment)
            node.symbol = getter
            symbol = getter
            break
          }
        }
      }

      checkAccess(node, node.internalRangeOrRange, scope)

      # Automatically wrap the getter in a call expression
      if symbol.isGetter {
        node.become(Node.createCall(node.cloneAndStealChildren).withRange(node.range))
        resolveAsParameterizedExpression(node, scope)
        return true
      }

      # Forbid bare function references
      if !symbol.isSetter && node.resolvedType != .DYNAMIC && kind.isFunctionOrOverloadedFunction && kind != .FUNCTION_ANNOTATION &&
          !isCallValue(node) && (parent == null || parent.kind != .PARAMETERIZE || !isCallValue(parent)) {
        log.semanticErrorMustCallFunction(node.internalRangeOrRange, symbol.name)
        node.resolvedType = .DYNAMIC
      }

      return false
    }

    def convertSwitchToIfChain(node Node, scope Scope) {
      var variable = VariableSymbol.new(.VARIABLE_LOCAL, scope.generateName("value"))
      var value = node.switchValue.remove
      var block Node = null

      # Stash the variable being switched over so it's only evaluated once
      variable.resolvedType = value.resolvedType
      variable.value = value
      variable.state = .INITIALIZED
      node.parent.insertChildBefore(node, Node.createVariables.appendChild(Node.createVariable(variable)))

      # Build the chain in reverse starting with the last case
      for child = node.lastChild; child != null; child = child.previousSibling {
        var caseBlock = child.caseBlock.remove
        var test Node = null

        # Combine adjacent cases in a "||" chain
        while child.hasChildren {
          var caseValue = Node.createBinary(.EQUAL, Node.createSymbolReference(variable), child.firstChild.remove).withType(cache.boolType)
          test = test != null ? Node.createBinary(.LOGICAL_OR, test, caseValue).withType(cache.boolType) : caseValue
        }

        # Chain if-else statements together
        block = test != null ? Node.createBlock.appendChild(Node.createIf(test, caseBlock, block)) : caseBlock
      }

      # Replace the switch statement with the if chain
      if block != null {
        node.replaceWithChildrenFrom(block)
      } else {
        node.remove
      }
    }
  }

  namespace Resolver {
    const annotationSymbolFlags = {
      "@deprecated": Symbol.IS_DEPRECATED,
      "@entry": Symbol.IS_ENTRY_POINT,
      "@export": Symbol.IS_EXPORTED,
      "@import": Symbol.IS_IMPORTED,
      "@noinline": Symbol.IS_INLINING_DISABLED,
      "@prefer": Symbol.IS_PREFERRED,
      "@rename": Symbol.IS_RENAMED,
      "@skip": Symbol.IS_SKIPPED,
      "@spreads": Symbol.SHOULD_SPREAD,
    }

    def shouldCheckForSetter(node Node) bool {
      return node.parent != null && node.parent.kind == .ASSIGN && node == node.parent.binaryLeft
    }

    def isVoidExpressionUsed(node Node) bool {
      # Check for a null parent to handle variable initializers
      var parent = node.parent
      return parent == null || parent.kind != .EXPRESSION && !parent.isImplicitReturn &&
        (parent.kind != .ANNOTATION || node != parent.annotationValue) &&
        (parent.kind != .FOR || node != parent.forUpdate) &&
        parent.kind != .SEQUENCE
    }

    def isValidVariableType(type Type) bool {
      return type != .NULL && (type.kind != .SYMBOL || !type.symbol.kind.isFunctionOrOverloadedFunction)
    }

    def isBaseGlobalReference(parent Symbol, member Symbol) bool {
      return parent != null && parent.kind == .OBJECT_CLASS && member.kind.isGlobalReference && member.parent != parent &&
        member.parent.kind == .OBJECT_CLASS && parent.asObjectSymbol.hasBaseClass(member.parent)
    }

    def isCallValue(node Node) bool {
      var parent = node.parent
      return parent != null && parent.kind == .CALL && node == parent.callValue
    }

    def needsTypeContext(node Node) bool {
      return
        node.kind == .DOT && node.dotTarget == null ||
        node.kind == .HOOK && needsTypeContext(node.hookTrue) && needsTypeContext(node.hookFalse) ||
        node.kind.isInitializer
    }

    def ensureFunctionIsOverloaded(symbol FunctionSymbol) {
      if symbol.overloaded == null {
        var overloaded = OverloadedFunctionSymbol.new(Merging.overloadedKind(symbol.kind), symbol.name, [symbol])
        overloaded.parent = symbol.parent
        overloaded.scope = overloaded.parent.scope
        symbol.overloaded = overloaded
        overloaded.scope.asObjectScope.symbol.members[symbol.name] = overloaded
      }
    }
  }
}
