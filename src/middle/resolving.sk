namespace astral {
  using astral.resolving

  void resolvingPass(Log log, TypeSymbol global) {
    var cache = TypeCache()
    cache.loadGlobals(log, global)
    if (!log.hasErrors()) {
      Resolver(cache, log).resolveType(global)
    }
  }
}

namespace astral.resolving {
  class ResolveContext {
    TypeCache cache
    Log log
  }

  class Resolver {
    TypeCache cache
    Log log

    void initializeSymbol(Symbol symbol) {
      // The scope should have been set by the merging pass (or by this pass for local variables)
      assert symbol.scope != null

      // Only initialize the symbol once
      if (symbol.state == .UNINITIALIZED) {
        symbol.state = .INITIALIZING

        switch (symbol.kind) {
          case .TYPE_CLASS, .TYPE_GLOBAL, .TYPE_INTERFACE, .TYPE_NAMESPACE {
            initializeType(symbol.asType())
          }

          case .FUNCTION_CONSTRUCTOR, .FUNCTION_GLOBAL, .FUNCTION_INSTANCE, .FUNCTION_LOCAL {
            initializeFunction(symbol.asFunction())
          }

          case .VARIABLE_GLOBAL, .VARIABLE_INSTANCE, .VARIABLE_LOCAL {
            initializeVariable(symbol.asVariable())
          }

          case .PARAMETER {
            initializeParameter(symbol.asParameter())
          }

          case .OVERLOADED_CONSTRUCTOR, .OVERLOADED_GLOBAL, .OVERLOADED_INSTANCE {
            initializeOverloadedFunction(symbol.asOverloadedFunction())
          }

          default {
            assert false
          }
        }

        assert symbol.resolvedType != null
        symbol.state = .INITIALIZED
      }

      // Detect cyclic symbol references such as "foo foo;"
      else if (symbol.state == .INITIALIZING) {
        log.semanticErrorCyclicDeclaration(symbol.range, symbol.name)
        symbol.resolvedType = .DYNAMIC
      }
    }

    void resolveParameters(List<ParameterSymbol> parameters) {
      if (parameters != null) {
        for (var i = 0; i < parameters.size(); i++) {
          resolveParameter(parameters[i])
        }
      }
    }

    void initializeParameter(ParameterSymbol symbol) {
      if (symbol.resolvedType == null) {
        symbol.resolvedType = SymbolType(symbol)
      }
    }

    void resolveParameter(ParameterSymbol symbol) {
      initializeSymbol(symbol)
    }

    void initializeType(TypeSymbol symbol) {
      if (symbol.resolvedType == null) {
        symbol.resolvedType = SymbolType(symbol)
      }

      if (symbol.base != null) {
        resolveNode(symbol.base, symbol.scope)
      }
    }

    void resolveType(TypeSymbol symbol) {
      initializeSymbol(symbol)
      resolveParameters(symbol.parameters)

      for (var i = 0; i < symbol.types.size(); i++) {
        resolveType(symbol.types[i])
      }

      for (var i = 0; i < symbol.functions.size(); i++) {
        resolveFunction(symbol.functions[i])
      }

      for (var i = 0; i < symbol.variables.size(); i++) {
        resolveVariable(symbol.variables[i])
      }
    }

    void initializeFunction(FunctionSymbol symbol) {
      if (symbol.resolvedType == null) {
        symbol.resolvedType = SymbolType(symbol)
      }

      resolveParameters(symbol.parameters)

      for (var i = 0; i < symbol.arguments.size(); i++) {
        var argument = symbol.arguments[i]
        argument.scope = symbol.scope
        resolveVariable(argument)
      }

      if (symbol.returnType != null) {
        if (symbol.kind == .FUNCTION_CONSTRUCTOR) {
          log.semanticErrorConstructorReturnType(symbol.returnType.range)
          symbol.returnType = null
        }

        else {
          resolveNode(symbol.returnType, symbol.scope)
        }
      }
    }

    void resolveFunction(FunctionSymbol symbol) {
      initializeSymbol(symbol)

      var scope = LocalScope(symbol.scope)

      if (symbol.kind == .FUNCTION_INSTANCE || symbol.kind == .FUNCTION_CONSTRUCTOR) {
        symbol.self = VariableSymbol(.VARIABLE_LOCAL, "self")
        symbol.self.resolvedType = symbol.parent.resolvedType
        symbol.self.state = .INITIALIZED
        scope.define(symbol.self, log)
      }

      // Default values for argument variables aren't resolved with this local
      // scope since they are evaluated at the call site, not inside the
      // function body, and shouldn't have access to other arguments
      for (var i = 0; i < symbol.arguments.size(); i++) {
        scope.define(symbol.arguments[i], log)
      }

      if (symbol.block != null) {
        resolveNode(symbol.block, scope)
      }
    }

    void initializeVariable(VariableSymbol symbol) {
      if (symbol.type != null) {
        resolveNode(symbol.type, symbol.scope)
        symbol.resolvedType = symbol.type.resolvedType
      }

      // Implicitly-typed variables take their type from their initializer
      else if (symbol.value != null) {
        resolveNode(symbol.value, symbol.scope)
        symbol.resolvedType = symbol.value.resolvedType
      }

      else {
        log.semanticErrorVarMissingValue(symbol.range)
        symbol.resolvedType = .DYNAMIC
      }
    }

    void resolveVariable(VariableSymbol symbol) {
      initializeSymbol(symbol)

      if (symbol.value != null) {
        resolveNode(symbol.value, symbol.scope)
      }

      // Default-initialize varliables that aren't explicitly initialized
      else if (symbol.kind != .VARIABLE_LOCAL) {
        symbol.value = defaultValueForType(symbol.resolvedType)
      }
    }

    void initializeOverloadedFunction(OverloadedFunctionSymbol symbol) {
      var symbols = symbol.symbols

      if (symbol.resolvedType == null) {
        symbol.resolvedType = SymbolType(symbol)
      }

      for (var i = 0; i < symbols.size(); i++) {
        initializeSymbol(symbols[i])
      }
    }

    void resolveNode(Node node, Scope scope) {
      if (node.resolvedType != null) {
        return // Only resolve once
      }

      node.resolvedType = .DYNAMIC
      switch (node.kind) {
        case .BLOCK { resolveBlock(node, scope) }

        // Statements
        case .BREAK {}
        case .CONTINUE {}
        case .EXPRESSION { resolveExpression(node, scope) }
        case .IF { resolveIf(node, scope) }
        case .RETURN { resolveReturn(node, scope) }
        case .VAR { resolveVar(node, scope) }
        case .WHILE { resolveWhile(node, scope) }

        // Expressions
        case .CALL { resolveCall(node, scope) }
        case .CAST { resolveCast(node, scope) }
        case .CONSTANT { resolveConstant(node, scope) }
        case .DOT { resolveDot(node, scope) }
        case .DYNAMIC {}
        case .HOOK { resolveHook(node, scope) }
        case .LAMBDA { resolveLambda(node, scope) }
        case .LAMBDA_TYPE { resolveLambdaType(node, scope) }
        case .NAME { resolveName(node, scope) }
        case .NULL { node.resolvedType = .NULL }
        case .PARAMETERIZE { resolveParameterize(node, scope) }

        default {
          if (node.kind.isUnary()) { resolveUnary(node, scope) }
          else if (node.kind.isBinary()) { resolveBinary(node, scope) }
          else { assert false }
        }
      }

      assert node.resolvedType != null
    }

    void resolveBlock(Node node, Scope scope) {
      if (node.parent != null) {
        scope = LocalScope(scope)
      }

      for (var i = 0; i < node.children.size(); i++) {
        resolveNode(node.children[i], scope)
      }
    }

    void resolveExpression(Node node, Scope scope) {
      resolveNode(node.expressionValue(), scope)
    }

    void resolveIf(Node node, Scope scope) {
      var ifFalse = node.ifFalse()
      resolveNode(node.ifTest(), scope)
      resolveNode(node.ifTrue(), scope)
      if (ifFalse != null) {
        resolveNode(ifFalse, scope)
      }
    }

    void resolveReturn(Node node, Scope scope) {
      var value = node.returnValue()
      if (value != null) {
        resolveNode(value, scope)
      }
    }

    void resolveVar(Node node, Scope scope) {
      var symbol = node.symbol.asVariable()
      scope.asLocal().define(symbol, log)
      resolveVariable(symbol)
    }

    void resolveWhile(Node node, Scope scope) {
      resolveNode(node.whileTest(), scope)
      resolveNode(node.whileBlock(), scope)
    }

    void resolveCall(Node node, Scope scope) {
      var value = node.callValue()
      resolveNode(value, scope)
      var type = value.resolvedType

      if (type.kind() == .SYMBOL) {
        var symbol = type.asSymbolType().symbol

        if (symbol.kind.isFunction()) {
          var function = symbol.asFunction()
          var expected = function.arguments.size()
          var found = node.children.size() - 1

          // Check argument count
          if (expected != found) {
            log.semanticErrorArgumentCount(node.internalRange, expected, found)
          }

          // Use the return type even if there were errors
          if (function.returnType != null) {
            node.resolvedType = function.returnType.resolvedType
          }

          // Constructors have an implicit return type
          else if (function.kind == .FUNCTION_CONSTRUCTOR) {
            node.resolvedType = function.parent.resolvedType
          }

          // There is no "void" type, so make sure this return value isn't used
          else if (node.parent.kind != .EXPRESSION) {
            log.semanticErrorUseOfVoid(node.range, function.name)
          }
        }

        else {
          log.semanticErrorInvalidCall(value.range, value.resolvedType)
        }
      }

      else if (type != .DYNAMIC) {
        log.semanticErrorInvalidCall(value.range, value.resolvedType)
      }

      for (var i = 1; i < node.children.size(); i++) {
        resolveNode(node.children[i], scope)
      }
    }

    void resolveCast(Node node, Scope scope) {
      resolveNode(node.castValue(), scope)
      resolveNode(node.castType(), scope)
    }

    void resolveConstant(Node node, Scope scope) {
      switch (node.content.kind()) {
        case .BOOL { node.resolvedType = cache.boolType }
        case .DOUBLE { node.resolvedType = cache.doubleType }
        case .INT { node.resolvedType = cache.intType }
        case .STRING { node.resolvedType = cache.stringType }
      }
    }

    void resolveDot(Node node, Scope scope) {
      var target = node.dotTarget()
      var name = node.asString()
      resolveNode(target, scope)

      if (target.resolvedType == .DYNAMIC) {
        return
      }

      // Search for the member in the target type
      Symbol member = null
      if (target.resolvedType.kind() == .SYMBOL) {
        var symbol = target.resolvedType.asSymbolType().symbol
        if (symbol.kind.isType()) {
          member = symbol.asType().members.getOrDefault(name, null)
        }
      }

      if (member == null) {
        log.semanticErrorUnknownMemberSymbol(node.internalRange, name, target.resolvedType)
        return
      }

      initializeSymbol(member)

      var isType = target.symbol != null && target.symbol.kind.isType()
      var needsType = member.kind != .FUNCTION_INSTANCE && member.kind != .VARIABLE_INSTANCE

      // Make sure the global/instance context matches the intended usage
      if (isType && !needsType) {
        log.semanticErrorMemberUnexpectedInstance(node.internalRange, member.name)
      } else if (!isType && needsType) {
        log.semanticErrorMemberUnexpectedGlobal(node.internalRange, member.name)
      }

      node.resolvedType = member.resolvedType
    }

    void resolveHook(Node node, Scope scope) {
      resolveNode(node.hookTest(), scope)
      resolveNode(node.hookTrue(), scope)
      resolveNode(node.hookFalse(), scope)
    }

    void resolveLambda(Node node, Scope scope) {
      var symbol = node.symbol.asFunction()
      symbol.scope = scope
      resolveFunction(symbol)
    }

    void resolveLambdaType(Node node, Scope scope) {
      var children = node.children
      List<Type> types = []

      for (var i = 0; i < children.size(); i++) {
        var child = children[i]
        if (child != null) {
          resolveNode(child, scope)
          types.push(child.resolvedType)
        } else {
          types.push(null)
        }
      }

      var returnType = types.pop()
      node.resolvedType = LambdaType(types, returnType)
    }

    void resolveName(Node node, Scope scope) {
      var name = node.asString()
      var symbol = scope.find(name)

      if (symbol == null) {
        log.semanticErrorUndeclaredSymbol(node.range, name)
        return
      }

      initializeSymbol(symbol)
      node.symbol = symbol
      node.resolvedType = symbol.resolvedType
    }

    void resolveParameterize(Node node, Scope scope) {
      for (var i = 0; i < node.children.size(); i++) {
        resolveNode(node.children[i], scope)
      }
    }

    void resolveUnary(Node node, Scope scope) {
      var value = node.unaryValue()
      resolveNode(value, scope)
    }

    void resolveBinary(Node node, Scope scope) {
      var left = node.binaryLeft()
      var right = node.binaryRight()
      resolveNode(left, scope)
      resolveNode(right, scope)
    }

    Node defaultValueForType(Type type) {
      return
        type == cache.boolType ? Node.createBool(false) :
        type == cache.doubleType ? Node.createDouble(0.0) :
        type == cache.intType ? Node.createInt(0) :
        type == cache.stringType ? Node.createString("") :
        Node.createNull()
    }
  }
}
