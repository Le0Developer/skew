
namespace Skew {
  var targets = [JavaScriptTarget.new, CSharpTarget.new, CPlusPlusTarget.new]

  var compileTime = document.getElementById("compileTime")
  var input = document.getElementById("input")
  var optionArea = document.getElementById("optionArea")
  var outputCode = document.getElementById("outputCode")
  var outputLog = document.getElementById("outputLog")
  var outputTree = document.getElementById("outputTree")
  var targetArea = document.getElementById("targetArea")

  def update {
    var log = Log.new
    var source = Source.new("<stdin>", input.value)
    var options = CompilerOptions.new
    options.target = targets[getTargetIndex()]
    options.outputFile = "compiled." + options.target.extension
    if Config.get(.CONSTANT_FOLDING) { options.foldAllConstants = true }
    if Config.get(.FUNCTION_INLINING) { options.inlineAllFunctions = true }
    if Config.get(.GLOBALIZE) { options.globalizeAllFunctions = true }
    if Config.get(.MANGLE) { options.jsMangle = true }
    if Config.get(.MINIFY) { options.jsMinify = true }
    if Config.get(.SOURCE_MAP) { options.jsSourceMap = true }
    var result = compile(log, options, [source])
    outputLog.value = log.toString
    outputTree.value = Config.get(.SHOW_SYNTAX_TREE) ? LispTreeEmitter.dump(result.global) : ""
    outputCode.value = log.hasErrors ? "" : result.outputs.count == 1 ? result.outputs.first.contents :
      "\n".join(result.outputs.map<string>(source => "[" + source.name + "]\n" + source.contents))
    compileTime.textContent = result.totalTimer.elapsedMilliseconds
  }

  def createSelect<T>(names List<string>, values List<T>, get fn() int, set fn(int)) dynamic {
    assert(names.count == values.count)
    var element = document.createElement("select")
    for i in 0..names.count {
      var option = document.createElement("option")
      option.textContent = names[i]
      element.appendChild(option)
    }
    element.selectedIndex = get()
    element.onchange = => {
      set(element.selectedIndex)
      update
    }
    return element
  }

  def createCheckbox(label string, config Config) dynamic {
    var element = document.createElement("label")
    var checkbox = document.createElement("input")
    checkbox.type = "checkbox"
    checkbox.checked = Config.get(config)
    checkbox.onchange = => {
      Config.set(config, checkbox.checked)
      update
    }
    element.appendChild(checkbox)
    element.appendChild(document.createTextNode(" " + label))
    return element
  }

  const getTargetIndex = => dynamic.localStorage["targetIndex"] as int
  const setTargetIndex = (index int) => { dynamic.localStorage["targetIndex"] = index }

  @entry
  def main {
    targetArea.appendChild(createSelect<CompilerTarget>(targets.map<string>(target => target.name), targets, getTargetIndex, setTargetIndex))
    optionArea.appendChild(createCheckbox("Constant folding", .CONSTANT_FOLDING))
    optionArea.appendChild(createCheckbox("Inlining", .FUNCTION_INLINING))
    optionArea.appendChild(createCheckbox("Mangle", .MANGLE))
    optionArea.appendChild(createCheckbox("Minify", .MINIFY))
    optionArea.appendChild(createCheckbox("Globalize", .GLOBALIZE))
    optionArea.appendChild(createCheckbox("Syntax tree", .SHOW_SYNTAX_TREE))
    optionArea.appendChild(createCheckbox("Source map", .SOURCE_MAP))
    input.oninput = => update
    update
  }

  enum Config {
    CONSTANT_FOLDING
    FUNCTION_INLINING
    GLOBALIZE
    MANGLE
    MINIFY
    SHOW_SYNTAX_TREE
    SOURCE_MAP
  }

  namespace Config {
    def get(config Config) bool {
      return dynamic.localStorage[config.toString] == "true"
    }

    def set(config Config, value bool) {
      dynamic.localStorage[config.toString] = value
    }
  }
}

@import
var document dynamic
