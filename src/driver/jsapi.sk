namespace Skew {
  @entry
  def main {
    var api dynamic = null
    if dynamic.typeof(dynamic.exports) != "undefined" {
      api = dynamic.exports
    } else {
      api = {}
      (=> dynamic.this)().Skew = api
    }

    var parseOptions = (args dynamic, inputs List<Source>) CompilerOptions => {
      if !(args.inputs is List<dynamic>) {
        throw dynamic.Error.new("Missing the required 'inputs' array")
      }

      var options = CompilerOptions.new
      var release = !!args.release
      options.foldAllConstants = !!args.foldAllConstants || release
      options.globalizeAllFunctions = !!args.globalizeAllFunctions || release
      options.inlineAllFunctions = !!args.inlineAllFunctions || release
      options.jsMangle = !!args.jsMangle || release
      options.jsMinify = !!args.jsMinify || release
      options.jsSourceMap = !!args.jsSourceMap
      options.outputDirectory = args.outputDirectory ? args.outputDirectory + "" : null
      options.outputFile = args.outputFile ? args.outputFile + "" : null
      options.stopAfterResolve = !!args.stopAfterResolve

      if args.defines {
        var defines = args.defines
        for key in dynamic.Object.keys(defines) as List<string> {
          options.define(key, defines[key] + "")
        }
      }

      if release {
        options.define("RELEASE", "true")
      }

      switch args.target {
        case "c#" { options.target = CSharpTarget.new }
        case "c++" { options.target = CPlusPlusTarget.new }
        case "js" { options.target = JavaScriptTarget.new }
        case "lisp-tree" { options.target = LispTreeTarget.new }
        default { throw dynamic.Error.new("Invalid target '" + args.target + "'") }
      }

      for i in 0..args.inputs.length {
        var input = args.inputs[i]
        inputs.append(Source.new(input.name + "", input.contents + ""))
      }

      return options
    }

    var diagnosticsToJSON = (diagnostics List<Diagnostic>) dynamic => {
      return diagnostics.map<dynamic>(diagnostic => {
        var range = diagnostic.range
        var convertedRange dynamic = null

        if range != null {
          var source = range.source
          var start = source.indexToLineColumn(range.start)
          var end = source.indexToLineColumn(range.end)

          convertedRange = {
            "source": source.name,
            "start": {
              "line": start.line,
              "column": start.column,
            },
            "end": {
              "line": end.line,
              "column": end.column,
            },
          }
        }

        return {
          "kind": diagnostic.kind.toString.toLowerCase,
          "range": convertedRange,
          "text": diagnostic.text,
        }
      })
    }

    var sourcesToJSON = (sources List<Source>) dynamic => {
      return sources.map<dynamic>(source => {
        return {
          "name": source.name,
          "contents": source.contents,
        }
      })
    }

    # JavaScript API
    api.compile = (args dynamic) dynamic => {
      if dynamic.arguments.length != 1 {
        throw dynamic.Error.new("Expected a single argument")
      }

      var log = Log.new
      var inputs List<Source> = []
      var options = parseOptions(args, inputs)
      var result = compile(log, options, inputs)

      return {
        "outputs": sourcesToJSON(result.outputs),
        "log": {
          "text": log.toString,
          "diagnostics": diagnosticsToJSON(log.diagnostics),
        },
      }
    }

    # Web Worker API
    if dynamic.typeof(dynamic.WorkerGlobalScope) != "undefined" && dynamic.self is dynamic.WorkerGlobalScope {
      dynamic.onmessage = (event dynamic) => {
        var data = event.data

        switch data.type {
          case "compile" {
            var log = Log.new
            var inputs List<Source> = []
            var options = parseOptions(data, inputs)
            var result = compile(log, options, inputs)

            dynamic.postMessage({
              "id": data.id | 0,
              "outputs": sourcesToJSON(result.outputs),
              "log": {
                "text": log.toString,
                "diagnostics": diagnosticsToJSON(log.diagnostics),
              },
            })
          }

          default {
            throw dynamic.Error.new("Unexpected message type '" + data.type + "'")
          }
        }
      }
    }
  }
}
