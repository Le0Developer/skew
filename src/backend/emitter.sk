namespace skew {
  class Emitter {
    var cache TypeCache

    def sources List<Source> {
      return _sources
    }

    def visit(global ObjectSymbol)

    @protected {
      var indent = ""

      def increaseIndent {
        indent += "  "
      }

      def decreaseIndent {
        indent = indent.slice(2, indent.count)
      }

      def emit(text string) {
        _code += text
      }

      def createSource(name string) {
        _sources.append(Source.new(name, _code))
        _code = ""
      }

      def sortedObjects(global ObjectSymbol) List<ObjectSymbol> {
        var objects List<ObjectSymbol> = []
        findObjects(objects, global)

        # Sort by inheritance and containment
        for i in 0..objects.count {
          var j = i

          # Select an object that comes before all other types
          while j < objects.count {
            var object = objects[j]
            var k = i

            # Check to see if this comes before all other types
            while k < objects.count {
              if j != k && objectComesBefore(objects[k], object) {
                break
              }
              k += 1
            }
            if k == objects.count {
              break
            }
            j += 1
          }

          # Swap the object into the correct order
          if j < objects.count {
            objects.swap(i, j)
          }
        }

        return objects
      }
    }

    @private {
      def findObjects(objects List<ObjectSymbol>, object ObjectSymbol) {
        objects.append(object)
        for o in object.objects {
          findObjects(objects, o)
        }
      }

      var _sources List<Source> = []
      var _code = ""
    }
  }

  namespace Emitter {
    @private {
      def isContainedBy(inner ObjectSymbol, outer ObjectSymbol) bool {
        if inner.parent == null {
          return false
        }
        if inner.parent == outer {
          return true
        }
        return isContainedBy(inner.parent.asObjectSymbol, outer)
      }

      def objectComesBefore(before ObjectSymbol, after ObjectSymbol) bool {
        if after.hasBaseClass(before) {
          return true
        }
        if isContainedBy(after, before) {
          return true
        }
        return false
      }
    }
  }

  const HEX = "0123456789ABCDEF"

  def quoteString(text string, quote int) string {
    var builder = StringBuilder.new
    var quoteString = string.fromCodeUnit(quote)
    var escaped = ""
    var start = 0 # Append long runs of unescaped characters using a single slice for speed
    builder.append(quoteString)
    for i in 0..text.count {
      var c = text[i]
      if c == quote { escaped = "\\" + quoteString }
      else if c == '\n' { escaped = "\\n" }
      else if c == '\r' { escaped = "\\r" }
      else if c == '\t' { escaped = "\\t" }
      else if c == '\0' { escaped = "\\0" }
      else if c == '\\' { escaped = "\\\\" }
      else if c < ' ' { escaped = "\\x" + HEX.get(c >> 4) + HEX.get(c & 15) }
      else { continue }
      builder.append(text.slice(start, i))
      builder.append(escaped)
      start = i + 1
    }
    builder.append(text.slice(start, text.count))
    builder.append(quoteString)
    return builder.toString
  }

  enum Associativity {
    NONE
    LEFT
    RIGHT
  }

  enum Precedence {
    def incrementIfLeftAssociative(associativity Associativity) Precedence {
      return ((self as int) + ((associativity == .LEFT) as int)) as Precedence
    }

    def incrementIfRightAssociative(associativity Associativity) Precedence {
      return ((self as int) + ((associativity == .RIGHT) as int)) as Precedence
    }
  }
}
