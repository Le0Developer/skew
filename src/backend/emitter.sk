namespace astral {
  class Emitter {
    List<Source> sources() {
      return _sources
    }

    virtual void visit(TypeSymbol global)

    protected {
      var indent = ""

      void increaseIndent() {
        indent += "  "
      }

      void decreaseIndent() {
        indent = indent.slice(2, indent.size())
      }

      void emit(string text) {
        _code += text
      }

      void createSource(string name) {
        _sources.push(Source(name, _code))
        _code = ""
      }

      List<TypeSymbol> sortedTypes(TypeSymbol global) {
        List<TypeSymbol> types = []
        findTypes(types, global)
        // TODO: Sort types by inheritance and containment
        return types
      }
    }

    private {
      void findTypes(List<TypeSymbol> types, TypeSymbol type) {
        types.push(type)
        for (var i = 0; i < type.types.size(); i++) {
          findTypes(types, type.types[i])
        }
      }

      List<Source> _sources = []
      var _code = ""
    }
  }

  final string HEX = "0123456789ABCDEF"

  string quoteString(string text, int quote) {
    var builder = StringBuilder()
    var quoteString = string.fromCodeUnit(quote)
    var escaped = ""
    var start = 0 // Append long runs of unescaped characters using a single slice() for speed
    int i
    builder.append(quoteString)
    for (i = 0; i < text.size(); i++) {
      var c = text[i]
      if (c == quote) escaped = "\\" + quoteString
      else if (c == '\n') escaped = "\\n"
      else if (c == '\r') escaped = "\\r"
      else if (c == '\t') escaped = "\\t"
      else if (c == '\0') escaped = "\\0"
      else if (c == '\\') escaped = "\\\\"
      else if (c < ' ') escaped = "\\x" + HEX.sliceCodeUnit(c >> 4) + HEX.sliceCodeUnit(c & 15)
      else continue
      builder.append(text.slice(start, i))
      builder.append(escaped)
      start = i + 1
    }
    builder.append(text.slice(start, i))
    builder.append(quoteString)
    return builder.toString()
  }

  enum Associativity {
    NONE
    LEFT
    RIGHT
  }

  in Precedence {
    Precedence incrementIfLeftAssociative(Associativity associativity) {
      return (Precedence)(this + (int)(associativity == .LEFT))
    }

    Precedence incrementIfRightAssociative(Associativity associativity) {
      return (Precedence)(this + (int)(associativity == .RIGHT))
    }
  }

  class OperatorInfo {
    final string text
    final Precedence precedence
    final Associativity associativity
    final OperatorKind kind
  }

  enum OperatorKind {
    FIXED
    OVERRIDABLE
  }

  IntMap<OperatorInfo> operatorInfo = {
    NodeKind.COMPLEMENT:            OperatorInfo("~", .UNARY_PREFIX, .NONE, .OVERRIDABLE),
    NodeKind.NEGATIVE:              OperatorInfo("-", .UNARY_PREFIX, .NONE, .OVERRIDABLE),
    NodeKind.NOT:                   OperatorInfo("not", .UNARY_PREFIX, .NONE, .OVERRIDABLE),
    NodeKind.POSITIVE:              OperatorInfo("+", .UNARY_PREFIX, .NONE, .OVERRIDABLE),

    NodeKind.ADD:                   OperatorInfo("+", .ADD, .LEFT, .OVERRIDABLE),
    NodeKind.BITWISE_AND:           OperatorInfo("&", .BITWISE_AND, .LEFT, .OVERRIDABLE),
    NodeKind.BITWISE_OR:            OperatorInfo("|", .BITWISE_OR, .LEFT, .OVERRIDABLE),
    NodeKind.BITWISE_XOR:           OperatorInfo("^", .BITWISE_XOR, .LEFT, .OVERRIDABLE),
    NodeKind.DIVIDE:                OperatorInfo("/", .MULTIPLY, .LEFT, .OVERRIDABLE),
    NodeKind.EQUAL:                 OperatorInfo("==", .EQUAL, .LEFT, .FIXED),
    NodeKind.GREATER_THAN:          OperatorInfo(">", .COMPARE, .LEFT, .FIXED),
    NodeKind.GREATER_THAN_OR_EQUAL: OperatorInfo(">=", .COMPARE, .LEFT, .FIXED),
    NodeKind.IN:                    OperatorInfo("in", .COMPARE, .LEFT, .OVERRIDABLE),
    NodeKind.LESS_THAN:             OperatorInfo("<", .COMPARE, .LEFT, .FIXED),
    NodeKind.LESS_THAN_OR_EQUAL:    OperatorInfo("<=", .COMPARE, .LEFT, .FIXED),
    NodeKind.LOGICAL_AND:           OperatorInfo("and", .LOGICAL_AND, .LEFT, .FIXED),
    NodeKind.LOGICAL_OR:            OperatorInfo("or", .LOGICAL_OR, .LEFT, .FIXED),
    NodeKind.MULTIPLY:              OperatorInfo("*", .MULTIPLY, .LEFT, .OVERRIDABLE),
    NodeKind.NOT_EQUAL:             OperatorInfo("!=", .EQUAL, .LEFT, .FIXED),
    NodeKind.POWER:                 OperatorInfo("**", .UNARY_PREFIX, .RIGHT, .OVERRIDABLE),
    NodeKind.REMAINDER:             OperatorInfo("%", .MULTIPLY, .LEFT, .OVERRIDABLE),
    NodeKind.SHIFT_LEFT:            OperatorInfo("<<", .SHIFT, .LEFT, .OVERRIDABLE),
    NodeKind.SHIFT_RIGHT:           OperatorInfo(">>", .SHIFT, .LEFT, .OVERRIDABLE),
    NodeKind.SUBTRACT:              OperatorInfo("-", .ADD, .LEFT, .OVERRIDABLE),

    NodeKind.ASSIGN:                OperatorInfo("=", .ASSIGN, .RIGHT, .FIXED),
    NodeKind.ASSIGN_ADD:            OperatorInfo("+=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_BITWISE_AND:    OperatorInfo("&=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_BITWISE_OR:     OperatorInfo("|=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_BITWISE_XOR:    OperatorInfo("^=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_DIVIDE:         OperatorInfo("/=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_MULTIPLY:       OperatorInfo("*=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_POWER:          OperatorInfo("**=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_REMAINDER:      OperatorInfo("%=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_SHIFT_LEFT:     OperatorInfo("<<=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_SHIFT_RIGHT:    OperatorInfo(">>=", .ASSIGN, .RIGHT, .OVERRIDABLE),
    NodeKind.ASSIGN_SUBTRACT:       OperatorInfo("-=", .ASSIGN, .RIGHT, .OVERRIDABLE),

    NodeKind.ASSIGN_INDEX:          OperatorInfo("[]=", .MEMBER, .NONE, .OVERRIDABLE),
    NodeKind.INDEX:                 OperatorInfo("[]", .MEMBER, .NONE, .OVERRIDABLE),
  }
}
