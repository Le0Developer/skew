namespace Skew {
  class Emitter {
    def sources List<Source> {
      return _sources
    }

    def visit(global ObjectSymbol)

    @protected {
      var indentAmount = "  "
      var indent = ""

      def increaseIndent {
        indent += indentAmount
      }

      def decreaseIndent {
        indent = indent.slice(indentAmount.count)
      }

      def emit(text string) {
        _code.append(text)
      }

      def emitPrefix(text string) {
        _prefix.append(text)
      }

      def createSource(name string) {
        _prefix.append(_code.toString)
        _sources.append(Source.new(name, _prefix.toString))
        _prefix = StringBuilder.new
        _code = StringBuilder.new
      }

      def sortedObjects(global ObjectSymbol) List<ObjectSymbol> {
        var objects List<ObjectSymbol> = []
        findObjects(objects, global)

        # Sort by inheritance and containment
        for i in 0..objects.count {
          var j = i

          # Select an object that comes before all other types
          while j < objects.count {
            var object = objects[j]
            var k = i

            # Check to see if this comes before all other types
            while k < objects.count {
              if j != k && objectComesBefore(objects[k], object) {
                break
              }
              k++
            }
            if k == objects.count {
              break
            }
            j++
          }

          # Swap the object into the correct order
          if j < objects.count {
            objects.swap(i, j)
          }
        }

        return objects
      }

      def markVirtualFunctions(symbol ObjectSymbol) {
        for object in symbol.objects {
          markVirtualFunctions(object)
        }

        for function in symbol.functions {
          if function.overridden != null {
            function.overridden.flags |= Symbol.IS_VIRTUAL
            function.flags |= Symbol.IS_VIRTUAL
          }
        }
      }
    }

    @private {
      def findObjects(objects List<ObjectSymbol>, object ObjectSymbol) {
        objects.append(object)
        for o in object.objects {
          findObjects(objects, o)
        }
      }

      var _sources List<Source> = []
      var _prefix = StringBuilder.new
      var _code = StringBuilder.new
    }
  }

  namespace Emitter {
    @private {
      def isContainedBy(inner ObjectSymbol, outer ObjectSymbol) bool {
        if inner.parent == null {
          return false
        }
        if inner.parent == outer {
          return true
        }
        return isContainedBy(inner.parent.asObjectSymbol, outer)
      }

      def objectComesBefore(before ObjectSymbol, after ObjectSymbol) bool {
        if after.hasBaseClass(before) {
          return true
        }
        if isContainedBy(after, before) {
          return true
        }
        return false
      }
    }
  }

  const HEX = "0123456789ABCDEF"

  def quoteString(text string, quote int) string {
    var builder = StringBuilder.new
    var quoteString = string.fromCodeUnit(quote)
    var escaped = ""
    var start = 0 # Append long runs of unescaped characters using a single slice for speed
    builder.append(quoteString)
    for i in 0..text.count {
      var c = text[i]
      if c == quote { escaped = "\\" + quoteString }
      else if c == '\n' { escaped = "\\n" }
      else if c == '\r' { escaped = "\\r" }
      else if c == '\t' { escaped = "\\t" }
      else if c == '\0' { escaped = "\\0" }
      else if c == '\\' { escaped = "\\\\" }
      else if c < ' ' { escaped = "\\x" + HEX.get(c >> 4) + HEX.get(c & 15) }
      else { continue }
      builder.append(text.slice(start, i))
      builder.append(escaped)
      start = i + 1
    }
    builder.append(text.slice(start, text.count))
    builder.append(quoteString)
    return builder.toString
  }

  enum Associativity {
    NONE
    LEFT
    RIGHT
  }

  enum Precedence {
    def incrementIfLeftAssociative(associativity Associativity) Precedence {
      return ((self as int) + ((associativity == .LEFT) as int)) as Precedence
    }

    def incrementIfRightAssociative(associativity Associativity) Precedence {
      return ((self as int) + ((associativity == .RIGHT) as int)) as Precedence
    }
  }
}
