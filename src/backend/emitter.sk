namespace skew {
  class Emitter {
    List<Source> sources() {
      return _sources
    }

    virtual void visit(ObjectSymbol global)

    protected {
      var indent = ""

      void increaseIndent() {
        indent += "  "
      }

      void decreaseIndent() {
        indent = indent.slice(2, indent.size())
      }

      void emit(string text) {
        _code += text
      }

      void createSource(string name) {
        _sources.push(Source(name, _code))
        _code = ""
      }

      List<ObjectSymbol> sortedObjects(ObjectSymbol global) {
        List<ObjectSymbol> objects = []
        findObjects(objects, global)
        // TODO: Sort objects by inheritance and containment
        return objects
      }
    }

    private {
      void findObjects(List<ObjectSymbol> objects, ObjectSymbol object) {
        objects.push(object)
        for (var i = 0; i < object.objects.size(); i++) {
          findObjects(objects, object.objects[i])
        }
      }

      List<Source> _sources = []
      var _code = ""
    }
  }

  final string HEX = "0123456789ABCDEF"

  string quoteString(string text, int quote) {
    var builder = StringBuilder()
    var quoteString = string.fromCodeUnit(quote)
    var escaped = ""
    var start = 0 // Append long runs of unescaped characters using a single slice() for speed
    int i
    builder.append(quoteString)
    for (i = 0; i < text.size(); i++) {
      var c = text[i]
      if (c == quote) escaped = "\\" + quoteString
      else if (c == '\n') escaped = "\\n"
      else if (c == '\r') escaped = "\\r"
      else if (c == '\t') escaped = "\\t"
      else if (c == '\0') escaped = "\\0"
      else if (c == '\\') escaped = "\\\\"
      else if (c < ' ') escaped = "\\x" + HEX.sliceCodeUnit(c >> 4) + HEX.sliceCodeUnit(c & 15)
      else continue
      builder.append(text.slice(start, i))
      builder.append(escaped)
      start = i + 1
    }
    builder.append(text.slice(start, i))
    builder.append(quoteString)
    return builder.toString()
  }

  enum Associativity {
    NONE
    LEFT
    RIGHT
  }

  in Precedence {
    Precedence incrementIfLeftAssociative(Associativity associativity) {
      return (Precedence)(this + (int)(associativity == .LEFT))
    }

    Precedence incrementIfRightAssociative(Associativity associativity) {
      return (Precedence)(this + (int)(associativity == .RIGHT))
    }
  }
}
