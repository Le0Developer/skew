namespace skew {
  class Emitter {
    List<Source> sources() {
      return _sources
    }

    virtual void visit(ObjectSymbol global)

    protected {
      var indent = ""

      void increaseIndent() {
        indent += "  "
      }

      void decreaseIndent() {
        indent = indent.slice(2, indent.size())
      }

      void emit(string text) {
        _code += text
      }

      void createSource(string name) {
        _sources.push(Source(name, _code))
        _code = ""
      }

      List<ObjectSymbol> sortedObjects(ObjectSymbol global) {
        List<ObjectSymbol> objects = []
        findObjects(objects, global)

        // Sort by inheritance and containment
        for (var i = 0; i < objects.size(); i++) {
          var j = i

          // Select an object that comes before all other types
          for (; j < objects.size(); j++) {
            var object = objects[j]
            var k = i

            // Check to see if this comes before all other types
            for (; k < objects.size(); k++) {
              if (j == k) {
                continue
              }
              if (objectComesBefore(objects[k], object)) {
                break
              }
            }
            if (k == objects.size()) {
              break
            }
          }

          // Swap the object into the correct order
          if (j < objects.size()) {
            objects.swap(i, j)
          }
        }

        return objects
      }
    }

    private {
      void findObjects(List<ObjectSymbol> objects, ObjectSymbol object) {
        objects.push(object)
        for (var i = 0; i < object.objects.size(); i++) {
          findObjects(objects, object.objects[i])
        }
      }

      static bool isContainedBy(ObjectSymbol inner, ObjectSymbol outer) {
        if (inner.parent == null) return false
        if (inner.parent == outer) return true
        return isContainedBy(inner.parent.asObjectSymbol(), outer)
      }

      static bool objectComesBefore(ObjectSymbol before, ObjectSymbol after) {
        if (after.hasBaseClass(before)) return true
        if (isContainedBy(after, before)) return true
        return false
      }

      List<Source> _sources = []
      var _code = ""
    }
  }

  final string HEX = "0123456789ABCDEF"

  string quoteString(string text, int quote) {
    var builder = StringBuilder()
    var quoteString = string.fromCodeUnit(quote)
    var escaped = ""
    var start = 0 // Append long runs of unescaped characters using a single slice() for speed
    int i
    builder.append(quoteString)
    for (i = 0; i < text.size(); i++) {
      var c = text[i]
      if (c == quote) escaped = "\\" + quoteString
      else if (c == '\n') escaped = "\\n"
      else if (c == '\r') escaped = "\\r"
      else if (c == '\t') escaped = "\\t"
      else if (c == '\0') escaped = "\\0"
      else if (c == '\\') escaped = "\\\\"
      else if (c < ' ') escaped = "\\x" + HEX.sliceCodeUnit(c >> 4) + HEX.sliceCodeUnit(c & 15)
      else continue
      builder.append(text.slice(start, i))
      builder.append(escaped)
      start = i + 1
    }
    builder.append(text.slice(start, i))
    builder.append(quoteString)
    return builder.toString()
  }

  enum Associativity {
    NONE
    LEFT
    RIGHT
  }

  in Precedence {
    Precedence incrementIfLeftAssociative(Associativity associativity) {
      return (Precedence)(this + (int)(associativity == .LEFT))
    }

    Precedence incrementIfRightAssociative(Associativity associativity) {
      return (Precedence)(this + (int)(associativity == .RIGHT))
    }
  }
}
