namespace Skew {
  enum BooleanSwap {
    SWAP
    NO_SWAP
  }

  enum ExtractGroupsMode {
    ALL_SYMBOLS
    ONLY_LOCAL_VARIABLES
    ONLY_INSTANCE_VARIABLES
  }

  class SymbolGroup {
    const symbols List<Symbol>
    const count int
  }

  class JavaScriptEmitter : Emitter {
    over visit(global ObjectSymbol) {
      mangle = options.jsMangle
      minify = options.jsMinify
      sourceMap = options.jsSourceMap

      if minify {
        indentAmount = ""
        newline = ""
        space = ""
      }

      # Preprocess the code
      prepareGlobal(global)
      shakingPass(global, cache.entryPointSymbol, .IGNORE_TYPES)
      convertLambdasToFunctions(global)
      var objects = sortedObjects(global)

      # The entire body of code is wrapped in a closure for safety
      emit(indent + "(function()" + space + "{" + newline)
      increaseIndent

      # Emit special-cased variables that must come first
      if needsExtends(objects) { emitFunction(convertLambdaToFunction(extends)) }
      if needsMultiply { emitVariable(multiply) }

      # Emit objects and functions
      for object in objects {
        emitObject(object)
      }

      # Emit variables
      for object in objects {
        var o = object
        prefix = ""
        while o.kind != .OBJECT_GLOBAL {
          prefix = mangleName(o) + "." + prefix
          o = o.parent.asObjectSymbol
        }
        for variable in object.variables {
          if variable != extends && variable != multiply {
            emitVariable(variable)
          }
        }
      }

      # Emit entry point
      var entryPointSymbol = cache.entryPointSymbol
      if entryPointSymbol != null {
        var type = entryPointSymbol.resolvedType
        var callText = fullName(entryPointSymbol) + (type.argumentTypes.isEmpty ? "()" : "(process.argv.slice(2))")
        emitSemicolonIfNeeded
        emit(newline + indent + (type.returnType == cache.intType ? "process.exit(" + callText + ")" : callText))
        emitSemicolonAfterStatement
      }

      # End the closure wrapping everything
      decreaseIndent
      emit(indent + "})();\n")

      var codeName = options.outputDirectory != "" ? options.outputDirectory + "/compiled.js" : options.outputFile
      var mapName = codeName + ".map"

      # Obfuscate the sourceMappingURL so it's not incorrectly picked up as the
      # sourceMappingURL for the compiled JavaScript compiler file
      if sourceMap {
        emit("/")
        emit("/# sourceMappingURL=" + splitPath(mapName).entry + "\n")
      }

      createSource(codeName, .ALWAYS_EMIT)

      # Create the source map
      if sourceMap {
        emit(generator.toString)
        createSource(mapName, .ALWAYS_EMIT)
      }
    }

    @protected
    over emit(text string) {
      if minify || sourceMap {
        for i in 0..text.count {
          var c = text[i]
          if c == '\n' {
            currentColumn = 0
            currentLine++
          } else {
            currentColumn++
          }
        }
      }
      super(text)
    }

    @private {
      enum AfterToken {
        AFTER_KEYWORD
        AFTER_PARENTHESIS
      }

      enum BracesMode {
        MUST_KEEP_BRACES
        CAN_OMIT_BRACES
      }

      const options CompilerOptions
      const cache TypeCache
      var needsMultiply = false
      var prefix = ""
      var previousNode Node = null
      var previousSymbol Symbol = null
      var enclosingFunction FunctionSymbol = null # This includes lambdas during patching but not during emission
      var extends VariableSymbol = null
      var multiply VariableSymbol = null

      # Source map support
      var sourceMap = false
      var generator = SourceMapGenerator.new
      var currentLine = 0
      var currentColumn = 0
      var previousStart = 0
      var previousSource Source = null

      # A union-find data structure is used to quickly merge symbols into
      # groups. All local variables inside a function are merged with that
      # function. The map create a quick way of getting from a symbol to its
      # union/find index.
      var allSymbols List<Symbol> = []
      var localVariableUnionFind UnionFind = UnionFind.new
      var namingGroupIndexForSymbol IntMap<int> = {}
      var nextSymbolName = 0
      var symbolCounts IntMap<int> = {}

      # For minification
      var mangle = false
      var minify = false
      var needsSemicolon = false
      var newline = "\n"
      var space = " "

      # For tracking "this" vs "self"
      var currentSelf VariableSymbol = null
      var needsSelf = false

      def prepareGlobal(global ObjectSymbol) {
        var globalObjects List<ObjectSymbol> = []
        var globalFunctions List<FunctionSymbol> = []
        var globalVariables List<VariableSymbol> = []

        # Load special-cased variables
        for variable in global.variables {
          if variable.name == "__extends" {
            extends = variable
            if multiply != null { break }
          } else if variable.name == "__imul" {
            multiply = variable
            if extends != null { break }
          }
        }
        assert(extends != null)
        assert(multiply != null)

        # Lower certain stuff into JavaScript (for example, "x as bool" becomes "!!x")
        patchObject(global, globalObjects, globalFunctions, globalVariables)

        # Skip everything below if we aren't mangling
        if !mangle {
          return
        }

        # Move internal global symbols up to the global namespace
        for object in globalObjects { object.parent = global }
        for function in globalFunctions { function.parent = global }
        for variable in globalVariables { variable.parent = global }
        global.objects.append(globalObjects)
        global.functions.append(globalFunctions)
        global.variables.append(globalVariables)

        # Rename symbols based on frequency for better compression
        renameSymbols
      }

      def convertLambdaToFunction(variable VariableSymbol) FunctionSymbol {
        var function = variable.value.symbol.asFunctionSymbol
        function.kind = .FUNCTION_GLOBAL
        function.parent = variable.parent
        function.name = variable.name
        return function
      }

      def convertLambdasToFunctions(symbol ObjectSymbol) {
        for object in symbol.objects {
          convertLambdasToFunctions(object)
        }

        symbol.variables.removeIf(variable => {
          if variable.kind == .VARIABLE_GLOBAL && variable.isConst && !variable.isExported && variable.value != null && variable.value.kind == .LAMBDA {
            symbol.functions.append(convertLambdaToFunction(variable))
            return true
          }
          return false
        })
      }

      def allocateNamingGroupIndex(symbol Symbol) {
        if mangle && !(symbol.id in namingGroupIndexForSymbol) {
          var index = localVariableUnionFind.allocate
          namingGroupIndexForSymbol[symbol.id] = index
          allSymbols.append(symbol)

          # Explicitly add function arguments since they won't be reached by
          # normal tree traversal
          if symbol.kind.isFunction {
            var context = symbol.asFunctionSymbol.self
            if context != null {
              allocateNamingGroupIndex(context)
            }
            for argument in symbol.asFunctionSymbol.arguments {
              allocateNamingGroupIndex(argument)
            }
          }
        }
      }

      def renameSymbols {
        # This holds the groups used for naming. Unioning two labels using
        # this object will cause both groups of symbols to have the same name.
        var namingGroupsUnionFind = UnionFind.new.allocate(allSymbols.count)

        # These are optional and only reduce the number of generated names
        var order List<int> = []
        aliasLocalVariables(namingGroupsUnionFind, order)
        aliasUnrelatedProperties(namingGroupsUnionFind, order)

        # Ensure all overridden symbols have the same generated name. This is
        # manditory for correctness, otherwise virtual functions break.
        for symbol in allSymbols {
          if symbol.kind.isFunction && symbol.asFunctionSymbol.overridden != null {
            assert(symbol.id in namingGroupIndexForSymbol)
            assert(symbol.asFunctionSymbol.overridden.id in namingGroupIndexForSymbol)
            namingGroupsUnionFind.union(namingGroupIndexForSymbol[symbol.id], namingGroupIndexForSymbol[symbol.asFunctionSymbol.overridden.id])
          }
        }

        # Collect all reserved names together into one big set for querying
        var reservedNames StringMap<int> = {}
        for symbol in allSymbols {
          if !shouldRenameSymbol(symbol) {
            reservedNames[symbol.name] = 0
          }
        }

        # Everything that should have the same name is now grouped together.
        # Generate and assign names to all internal symbols, but use shorter
        # names for more frequently used symbols.
        var sortedGroups List<SymbolGroup> = []
        for group in extractGroups(namingGroupsUnionFind, .ALL_SYMBOLS) {
          var count = 0
          for symbol in group {
            if shouldRenameSymbol(symbol) {
              count += symbolCounts.get(symbol.id, 0)
            }
          }
          sortedGroups.append(SymbolGroup.new(group, count))
        }
        sortedGroups.sort((a, b) => b.count - a.count)
        for group in sortedGroups {
          var name = ""
          for symbol in group.symbols {
            if shouldRenameSymbol(symbol) {
              if name == "" {
                name = generateSymbolName(reservedNames)
              }
              symbol.name = name
            }
          }
        }
      }

      # Merge local variables from different functions together in the order
      # they were declared. This will cause every argument list to use the same
      # variables in the same order, which should offer better gzip:
      #
      #   function d(a, b) {}
      #   function e(a, b, c) {}
      #
      def aliasLocalVariables(unionFind UnionFind, order List<int>) {
        zipTogetherInOrder(unionFind, order, extractGroups(localVariableUnionFind, .ONLY_LOCAL_VARIABLES))
      }

      # Merge all related types together into naming groups. This ensures names
      # will be unique within a subclass hierarchy allowing names to be
      # duplicated in separate subclass hierarchies.
      def aliasUnrelatedProperties(unionFind UnionFind, order List<int>) {
        var relatedTypesUnionFind = UnionFind.new.allocate(allSymbols.count)
        for i in 0..allSymbols.count {
          var symbol = allSymbols[i]
          if symbol.kind == .OBJECT_CLASS {
            var baseClass = symbol.asObjectSymbol.baseClass
            if baseClass != null {
              relatedTypesUnionFind.union(i, namingGroupIndexForSymbol[baseClass.id])
            }
            for variable in symbol.asObjectSymbol.variables {
              relatedTypesUnionFind.union(i, namingGroupIndexForSymbol[variable.id])
            }
          }
        }
        zipTogetherInOrder(unionFind, order, extractGroups(relatedTypesUnionFind, .ONLY_INSTANCE_VARIABLES))
      }

      def zipTogetherInOrder(unionFind UnionFind, order List<int>, groups List<List<Symbol>>) {
        for group in groups {
          for i in 0..group.count {
            var symbol = group[i]
            var index = namingGroupIndexForSymbol[symbol.id]
            if i >= order.count {
              order.append(index)
            } else {
              unionFind.union(index, order[i])
            }
          }
        }
      }

      def numberToName(number int) string {
        const WRAP = 26 * 2
        var name = ""
        if number >= WRAP {
          name = numberToName(number / WRAP - 1)
          number = number % WRAP
        }
        name += string.fromCodeUnit(number + (number < 26 ? 'a' : 'A' - 26))
        return name
      }

      def generateSymbolName(reservedNames StringMap<int>) string {
        while true {
          var name = numberToName(nextSymbolName)
          nextSymbolName++
          if !(name in reservedNames) {
            return name
          }
        }
      }

      def extractGroups(unionFind UnionFind, mode ExtractGroupsMode) List<List<Symbol>> {
        var labelToGroup IntMap<List<Symbol>> = {}
        for symbol in allSymbols {
          if mode == .ONLY_LOCAL_VARIABLES && !symbol.kind.isLocalOrArgumentVariable ||
              mode == .ONLY_INSTANCE_VARIABLES && symbol.kind != .VARIABLE_INSTANCE {
            continue
          }
          assert(symbol.id in namingGroupIndexForSymbol)
          var label = unionFind.find(namingGroupIndexForSymbol[symbol.id])
          var group = labelToGroup.get(label, null)
          if group == null {
            group = []
            labelToGroup[label] = group
          }
          group.append(symbol)
        }
        return labelToGroup.values
      }

      def addMapping(range Range) {
        if sourceMap && range != null {
          var source = range.source
          var start = range.start

          if previousSource != source || previousStart != start {
            var location = source.indexToLineColumn(start)
            generator.addMapping(source, location.line, location.column, currentLine, currentColumn)
            previousStart = start
            previousSource = source
          }
        }
      }

      def emitSemicolonAfterStatement {
        if !minify {
          emit(";\n")
        } else {
          needsSemicolon = true
        }
      }

      def emitSemicolonIfNeeded {
        if needsSemicolon {
          emit(";")
          needsSemicolon = false
        }
        maybeEmitMinifedNewline
      }

      # Lots of text editors choke up on long lines, so add a newline every now
      # and then for usability's sake
      def maybeEmitMinifedNewline {
        if minify && currentColumn > 1024 {
          emit("\n")
        }
      }

      def emitNewlineBeforeSymbol(symbol Symbol) {
        emitSemicolonIfNeeded
        if !minify && previousSymbol != null &&
            (!previousSymbol.kind.isObject || !symbol.kind.isObject || symbol.comments != null || previousSymbol.kind == .OBJECT_ENUM || symbol.kind == .OBJECT_ENUM) &&
            (!previousSymbol.kind.isVariable || !symbol.kind.isVariable || symbol.comments != null) {
          emit("\n")
        }
        previousSymbol = null
      }

      def emitNewlineAfterSymbol(symbol Symbol) {
        previousSymbol = symbol
      }

      def emitNewlineBeforeStatement(node Node) {
        if !minify && previousNode != null && (node.comments != null || !isCompactNodeKind(previousNode.kind) || !isCompactNodeKind(node.kind)) {
          emit("\n")
        } else {
          maybeEmitMinifedNewline
        }
        previousNode = null
      }

      def emitNewlineAfterStatement(node Node) {
        previousNode = node
      }

      def emitComments(comments List<string>) {
        if comments != null && !minify {
          for comment in comments {
            emit(indent + "//" + comment)
          }
        }
      }

      def emitObject(symbol ObjectSymbol) {
        if symbol.isImported {
          return
        }

        prefix = symbol.parent != null ? computePrefix(symbol.parent.asObjectSymbol) : ""

        switch symbol.kind {
          case .OBJECT_NAMESPACE, .OBJECT_INTERFACE {
            addMapping(symbol.range)
            emitNewlineBeforeSymbol(symbol)
            emitComments(symbol.comments)
            emit(indent + (prefix == "" && !symbol.isExported ? "var " : prefix) + mangleName(symbol) + space + "=" + space + "{}")
            emitSemicolonAfterStatement
            emitNewlineAfterSymbol(symbol)
          }

          case .OBJECT_ENUM {
            addMapping(symbol.range)
            emitNewlineBeforeSymbol(symbol)
            emitComments(symbol.comments)
            emit(indent + (prefix == "" && !symbol.isExported ? "var " : prefix) + mangleName(symbol) + space + "=" + space + "{")
            increaseIndent
            var isFirst = true
            for variable in symbol.variables {
              if variable.kind == .VARIABLE_ENUM {
                if isFirst {
                  isFirst = false
                } else {
                  emit(",")
                }
                emit(newline)
                addMapping(variable.range)
                emitNewlineBeforeSymbol(variable)
                emitComments(variable.comments)
                emit(indent + mangleName(variable) + ":" + space)
                emitContent(variable.value.content)
                emitNewlineAfterSymbol(variable)
              }
            }
            decreaseIndent
            if !isFirst && !minify {
              emit("\n" + indent)
            }
            emit("}")
            emitSemicolonAfterStatement
            emitNewlineAfterSymbol(symbol)
          }

          case .OBJECT_CLASS {
            var foundPrimaryConstructor = false
            for function in symbol.functions {
              if function.isPrimaryConstructor {
                if function.comments == null && symbol.comments != null {
                  function.comments = symbol.comments
                }
                emitFunction(function)
                if symbol.baseClass != null {
                  if !minify {
                    emit("\n" + indent)
                  }
                  emitSemicolonIfNeeded
                  addMapping(extends.range)
                  emit(mangleName(extends) + "(" + fullName(symbol) + "," + space + fullName(symbol.baseClass) + ")")
                  emitSemicolonAfterStatement
                }
                foundPrimaryConstructor = true
                break
              }
            }

            # Ignore this entire class if it's never constructed
            if !foundPrimaryConstructor {
              return
            }
          }
        }

        if symbol.kind != .OBJECT_GLOBAL {
          prefix += mangleName(symbol) + "."
        }

        for function in symbol.functions {
          if !function.isPrimaryConstructor {
            emitFunction(function)
          }
        }
      }

      def emitArgumentList(arguments List<VariableSymbol>) {
        for argument in arguments {
          if argument != arguments.first {
            emit("," + space)
          }
          addMapping(argument.range)
          emit(mangleName(argument))
        }
      }

      def emitFunction(symbol FunctionSymbol) {
        if symbol.block == null {
          return
        }

        addMapping(symbol.range)
        emitNewlineBeforeSymbol(symbol)
        emitComments(symbol.comments)

        var isExpression = prefix != "" || symbol.isExported
        var name = mangleName(symbol.isPrimaryConstructor ? symbol.parent : symbol)

        if isExpression {
          emit(indent + prefix + (symbol.kind == .FUNCTION_INSTANCE ? "prototype." : "") + name + space + "=" + space + "function(")
        } else {
          emit(indent + "function " + name + "(")
        }

        emitArgumentList(symbol.arguments)
        emit(")" + space + "{" + newline)
        increaseIndent
        enclosingFunction = symbol
        emitStatements(symbol.block.children)
        enclosingFunction = null
        decreaseIndent
        emit(indent + "}")
        if isExpression {
          emitSemicolonAfterStatement
        } else {
          needsSemicolon = false
          emit(newline)
        }
        emitNewlineAfterSymbol(symbol)

        if symbol.kind == .FUNCTION_CONSTRUCTOR && !symbol.isPrimaryConstructor {
          emitSemicolonIfNeeded
          emit(newline + indent + fullName(symbol) + ".prototype" + space + "=" + space + fullName(symbol.parent) + ".prototype")
          emitSemicolonAfterStatement
        }
      }

      def emitVariable(symbol VariableSymbol) {
        if symbol.isImported {
          return
        }

        if symbol.kind != .VARIABLE_INSTANCE && symbol.kind != .VARIABLE_ENUM && (symbol.value != null || prefix == "" || symbol.kind.isLocalOrArgumentVariable) {
          addMapping(symbol.range)
          emitNewlineBeforeSymbol(symbol)
          emitComments(symbol.comments)
          emit(indent + (prefix == "" && !symbol.isExported || symbol.kind.isLocalOrArgumentVariable ? "var " : prefix) + mangleName(symbol))

          if symbol.value != null {
            emit(space + "=" + space)
            emitExpression(symbol.value, .COMMA)
          }

          emitSemicolonAfterStatement
          emitNewlineAfterSymbol(symbol)
        }
      }

      def emitStatements(statements List<Node>) {
        previousNode = null

        for statement in statements {
          emitSemicolonIfNeeded
          emitNewlineBeforeStatement(statement)
          addMapping(statement.range)
          emitComments(statement.comments)
          emitStatement(statement)
          emitNewlineAfterStatement(statement)
        }

        previousNode = null
      }

      def emitBlock(node Node, after AfterToken, mode BracesMode) {
        var shouldMinify = mode == .CAN_OMIT_BRACES && minify
        addMapping(node.range)
        if shouldMinify && !node.hasChildren {
          emit(";")
        } else if shouldMinify && node.children.count == 1 {
          if after == .AFTER_KEYWORD {
            emit(" ")
          }
          emitStatement(node.children.first)
        } else {
          emit(space + "{" + newline)
          if node.hasChildren {
            increaseIndent
            emitStatements(node.children)
            decreaseIndent
          }
          emit(indent + "}")
          needsSemicolon = false
        }
      }

      def emitStatement(node Node) {
        switch node.kind {
          case .VAR {
            emitVariable(node.symbol.asVariableSymbol)
          }

          case .EXPRESSION {
            emit(indent)
            emitExpression(node.expressionValue, .LOWEST)
            emitSemicolonAfterStatement
          }

          case .BREAK {
            emit(indent + "break")
            emitSemicolonAfterStatement
          }

          case .CONTINUE {
            emit(indent + "continue")
            emitSemicolonAfterStatement
          }

          case .RETURN {
            emit(indent + "return")
            var value = node.returnValue
            if value != null {
              emit(" ")
              emitExpression(value, .LOWEST)
            }
            emitSemicolonAfterStatement
          }

          case .THROW {
            emit(indent + "throw ")
            emitExpression(node.throwValue, .LOWEST)
            emitSemicolonAfterStatement
          }

          case .FOR {
            var test = node.forTest
            var update = node.forUpdate
            var children = node.children
            var count = children.count
            emit(indent + "for" + space + "(")
            if count > 3 {
              for i in 3..count {
                var child = children[i]
                assert(child.kind == .VAR)
                if i != 3 {
                  emit("," + space)
                }
                var symbol = child.symbol.asVariableSymbol
                if i == 3 {
                  emit("var ")
                }
                emit(mangleName(symbol) + space + "=" + space)
                emitExpression(symbol.value, .COMMA)
              }
            }
            emit(";" + space)
            if test != null {
              emitExpression(test, .LOWEST)
            }
            emit(";" + space)
            if update != null {
              emitExpression(update, .LOWEST)
            }
            emit(")")
            emitBlock(node.forBlock, .AFTER_PARENTHESIS, .MUST_KEEP_BRACES)
            emit(newline)
          }

          case .FOREACH {
            emit(indent + "for" + space + "(var " + mangleName(node.symbol) + " in ")
            emitExpression(node.foreachValue, .LOWEST)
            emit(")")
            emitBlock(node.foreachBlock, .AFTER_PARENTHESIS, .MUST_KEEP_BRACES)
            emit(newline)
          }

          case .IF {
            emit(indent)
            emitIf(node)
            emit(newline)
          }

          case .SWITCH {
            var cases = node.children
            emit(indent + "switch" + space + "(")
            emitExpression(node.switchValue, .LOWEST)
            emit(")" + space + "{" + newline)
            increaseIndent
            for i in 1..cases.count {
              var child = cases[i]
              var values = child.children
              var block = child.caseBlock
              emitSemicolonIfNeeded
              if i != 1 {
                emit(newline)
              }
              if values.count == 1 {
                emit(indent + "default:")
              } else {
                for j in 1..values.count {
                  if j != 1 {
                    emit(newline)
                  }
                  emit(indent + "case ")
                  emitExpression(values[j], .LOWEST)
                  emit(":")
                }
              }
              if !minify {
                emit(" {\n")
                increaseIndent
              }
              emitStatements(block.children)
              if !block.blockAlwaysEndsWithReturn {
                emitSemicolonIfNeeded
                emit(indent + "break")
                emitSemicolonAfterStatement
              }
              if !minify {
                decreaseIndent
                emit(indent + "}\n")
              }
            }
            decreaseIndent
            emit(indent + "}" + newline)
            needsSemicolon = false
          }

          case .TRY {
            var children = node.children
            var finallyBlock = node.finallyBlock
            emit(indent + "try")
            emitBlock(node.tryBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
            emit(newline)
            for i in 1..children.count - 1 {
              var child = children[i]
              emit(newline)
              emitComments(child.comments)
              emit(indent + "catch" + space + "(" + mangleName(child.symbol) + ")")
              emitBlock(child.catchBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
              emit(newline)
            }
            if finallyBlock != null {
              emit(newline)
              emitComments(finallyBlock.comments)
              emit(indent + "finally")
              emitBlock(finallyBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
              emit(newline)
            }
          }

          case .WHILE {
            emit(indent + "while" + space + "(")
            emitExpression(node.whileTest, .LOWEST)
            emit(")")
            emitBlock(node.whileBlock, .AFTER_PARENTHESIS, .CAN_OMIT_BRACES)
            emit(newline)
          }

          default {
            assert(false)
          }
        }
      }

      def emitIf(node Node) {
        var trueBlock = node.ifTrue
        var falseBlock = node.ifFalse
        emit("if" + space + "(")
        emitExpression(node.ifTest, .LOWEST)
        emit(")")

        # Make sure to always keep braces to avoid the dangling "else" case
        var trueStatement = trueBlock.blockStatement
        emitBlock(node.ifTrue, .AFTER_PARENTHESIS, falseBlock != null && trueStatement != null && trueStatement.kind == .IF ? .MUST_KEEP_BRACES : .CAN_OMIT_BRACES)

        if falseBlock != null {
          var falseStatement = falseBlock.blockStatement
          var singleIf = falseStatement != null && falseStatement.kind == .IF ? falseStatement : null
          emitSemicolonIfNeeded
          emit(newline + newline)
          emitComments(falseBlock.comments)
          if singleIf != null {
            emitComments(singleIf.comments)
          }
          emit(indent + "else")

          if singleIf != null {
            emit(" ")
            emitIf(singleIf)
          } else {
            emitBlock(falseBlock, .AFTER_KEYWORD, .CAN_OMIT_BRACES)
          }
        }
      }

      def emitContent(content Content) {
        switch content.kind {
          case .BOOL { emit(mangle ? content.asBool ? "!0" : "!1" : content.asBool.toString) }
          case .INT { emit(content.asInt.toString) }
          case .DOUBLE { emit(content.asDouble.toString) }
          case .STRING { emit(quoteString(content.asString, '"')) }
        }
      }

      def emitExpression(node Node, precedence Precedence) {
        var kind = node.kind
        addMapping(node.range)

        switch kind {
          case .TYPE {
            emit(fullName(node.resolvedType.symbol))
          }

          case .NULL {
            emit("null")
          }

          case .NAME {
            var symbol = node.symbol
            emit(symbol != null ? fullName(symbol) : node.asString)
          }

          case .DOT {
            emitExpression(node.dotTarget, .MEMBER)
            emit("." + (node.symbol != null ? mangleName(node.symbol) : node.asString))
          }

          case .CONSTANT {
            emitContent(node.content)
          }

          case .CALL {
            var value = node.callValue
            var call = value.kind == .SUPER
            var wrap = value.kind == .LAMBDA && node.parent != null && node.parent.kind == .EXPRESSION

            if wrap {
              emit("(")
            }

            if !call && node.symbol != null && node.symbol.kind == .FUNCTION_CONSTRUCTOR {
              emit("new " + fullName(node.symbol))
            } else if !call && value.kind == .DOT && value.asString == "new" {
              emit("new ")
              emitExpression(value.dotTarget, .MEMBER)
            } else {
              emitExpression(value, .UNARY_POSTFIX)
              if call {
                emit(".call")
              }
            }

            if wrap {
              emit(")")
            }

            emit("(")

            if call {
              emit(mangleName(enclosingFunction.self))
            }

            for i in 1..node.children.count {
              if call || i > 1 {
                emit("," + space)
              }
              emitExpression(node.children[i], .COMMA)
            }

            emit(")")
          }

          case .INITIALIZER_LIST, .INITIALIZER_MAP, .INITIALIZER_SET {
            var children = node.children
            var useBraces = kind == .INITIALIZER_MAP || kind == .INITIALIZER_SET && children.isEmpty
            var isIndented = !minify && !children.all(child => child.comments == null)

            emit(useBraces ? "{" : "[")
            if isIndented {
              increaseIndent
            }

            for child in children {
              if child != children.first {
                emit("," + (isIndented ? "" : space))
              }
              if isIndented {
                emit("\n")
                emitComments(child.comments)
                emit(indent)
              }
              emitExpression(child, .COMMA)
            }

            if isIndented {
              decreaseIndent
              emit("\n" + indent)
            }
            emit(useBraces ? "}" : "]")
          }

          case .PAIR {
            emitExpression(node.firstValue, .LOWEST)
            emit(":" + space)
            emitExpression(node.secondValue, .LOWEST)
          }

          case .INDEX {
            assert(node.children.count == 2)
            emitExpression(node.children[0], .UNARY_POSTFIX)
            emit("[")
            emitExpression(node.children[1], .LOWEST)
            emit("]")
          }

          case .ASSIGN_INDEX {
            if Precedence.ASSIGN as int < precedence as int {
              emit("(")
            }

            assert(node.children.count == 3)
            emitExpression(node.children[0], .UNARY_POSTFIX)
            emit("[")
            emitExpression(node.children[1], .LOWEST)
            emit("]" + space + "=" + space + "")
            emitExpression(node.children[2], .ASSIGN)

            if Precedence.ASSIGN as int < precedence as int {
              emit(")")
            }
          }

          case .CAST {
            emitExpression(node.castValue, precedence)
          }

          case .PARAMETERIZE {
            emitExpression(node.parameterizeValue, precedence)
          }

          case .SEQUENCE {
            if Precedence.COMMA as int <= precedence as int {
              emit("(")
            }
            for i in 0..node.children.count {
              if i != 0 {
                emit("," + space)
              }
              emitExpression(node.children[i], .COMMA)
            }
            if Precedence.COMMA as int <= precedence as int {
              emit(")")
            }
          }

          case .SUPER {
            emit(fullName(node.symbol))
          }

          case .HOOK {
            if Precedence.ASSIGN as int < precedence as int {
              emit("(")
            }
            emitExpression(node.hookTest, .LOGICAL_OR)
            emit(space + "?" + space)
            emitExpression(node.hookTrue, .ASSIGN)
            emit(space + ":" + space)
            emitExpression(node.hookFalse, .ASSIGN)
            if Precedence.ASSIGN as int < precedence as int {
              emit(")")
            }
          }

          case .LAMBDA {
            var symbol = node.symbol.asFunctionSymbol
            emit("function(")
            emitArgumentList(symbol.arguments)
            emit(")")
            emitBlock(symbol.block, .AFTER_PARENTHESIS, .MUST_KEEP_BRACES)
          }

          default {
            if kind.isUnary {
              var value = node.unaryValue
              var info = operatorInfo[kind]
              if info.precedence as int < precedence as int {
                emit("(")
              }
              emit(info.text)
              emitExpression(value, info.precedence)
              if info.precedence as int < precedence as int {
                emit(")")
              }
            }

            else if kind.isBinary {
              var info = operatorInfo[kind]
              var right = node.binaryRight

              if info.precedence as int < precedence as int {
                emit("(")
              }
              emitExpression(node.binaryLeft, info.precedence.incrementIfRightAssociative(info.associativity))

              # Always emit spaces around keyword operators, even when minifying
              emit(kind == .IN ? " in " : kind == .IS ? " instanceof " : space + (kind == .EQUAL ? "===" : kind == .NOT_EQUAL ? "!==" : info.text) + space)

              # Prevent "x - -1" from becoming "x--1"
              if minify && (
                  kind == .ADD && (right.kind == .POSITIVE || right.kind == .INCREMENT) ||
                  kind == .SUBTRACT && (right.kind == .NEGATIVE || right.kind == .DECREMENT || right.isNumberLessThanZero)) {
                emit(" ")
              }

              emitExpression(right, info.precedence.incrementIfLeftAssociative(info.associativity))
              if info.precedence as int < precedence as int {
                emit(")")
              }
            }

            else {
              assert(false)
            }
          }
        }
      }

      def patchObject(symbol ObjectSymbol, globalObjects List<ObjectSymbol>, globalFunctions List<FunctionSymbol>, globalVariables List<VariableSymbol>) {
        var shouldLiftGlobals = mangle && symbol.parent != null
        allocateNamingGroupIndex(symbol)

        # Scan over child objects
        symbol.objects.removeIf(object => {
          patchObject(object, globalObjects, globalFunctions, globalVariables)

          # When mangling, filter out all internal objects and move them to the global namespace
          if shouldLiftGlobals && !object.isImportedOrExported {
            globalObjects.append(object)
            return true
          }

          return false
        })

        # Scan over child functions
        var isPrimaryConstructor = true
        symbol.functions.removeIf(function => {
          allocateNamingGroupIndex(function)

          # Check to see if we need an explicit "self" parameter while patching the block
          needsSelf = false
          currentSelf = function.self
          enclosingFunction = function
          patchNode(function.block)
          enclosingFunction = null

          # Only insert the "self" variable if required to handle capture inside lambdas
          if needsSelf {
            unionVariableWithFunction(function.self, function)
            if function.block != null {
              function.self.value = Node.createName("this")
              function.block.children.prepend(Node.createVar(function.self))
            }
          } else if function.self != null {
            function.self.name = "this"
            function.self.flags |= Symbol.IS_EXPORTED
          }

          for argument in function.arguments {
            allocateNamingGroupIndex(argument)
            unionVariableWithFunction(argument, function)
          }

          # When mangling, filter out all internal global functions and move them to the global namespace
          if shouldLiftGlobals && function.kind == .FUNCTION_GLOBAL && !function.isImportedOrExported {
            globalFunctions.append(function)
            return true
          }

          # Rename extra constructors overloads so they don't conflict
          if function.kind == .FUNCTION_CONSTRUCTOR {
            if isPrimaryConstructor {
              function.flags |= Symbol.IS_PRIMARY_CONSTRUCTOR
              isPrimaryConstructor = false
            }
          }

          return false
        })

        # Scan over child variables
        symbol.variables.removeIf(variable => {
          allocateNamingGroupIndex(variable)
          patchNode(variable.value)

          # When mangling, filter out all internal global variables and move them to the global namespace
          if shouldLiftGlobals && variable.kind == .VARIABLE_GLOBAL && !variable.isImportedOrExported {
            globalVariables.append(variable)
            return true
          }

          return false
        })
      }

      def createIntBinary(kind NodeKind, left Node, right Node) Node {
        if kind == .MULTIPLY {
          needsMultiply = true
          return Node.createCall(Node.createName(multiply.name).withSymbol(multiply), [left, right]).withType(cache.intType)
        }
        return wrapWithIntCast(Node.createBinary(kind, left, right).withType(cache.intType))
      }

      def wrapWithNot(node Node) Node {
        return Node.createUnary(.NOT, node).withType(cache.boolType).withRange(node.range)
      }

      def wrapWithIntCast(node Node) Node {
        return Node.createBinary(.BITWISE_OR, node, Node.createInt(0).withType(cache.intType)).withType(cache.intType).withRange(node.range)
      }

      def wrapWithTypeIndex(node Node, index Type, type Type) Node {
        return Node.createIndex(Node.createType(index), [node]).withType(type).withRange(node.range)
      }

      def patchBinaryArithmetic(node Node) {
        # Make sure arithmetic integer operators don't emit doubles outside the
        # integer range. Allowing this causes JIT slowdowns due to extra checks
        # during compilation and potential deoptimizations during execution.
        if node.resolvedType == cache.intType && !alwaysConvertsOperandsToInt(node.parent) {
          var left = node.binaryLeft
          var right = node.binaryRight
          if left.resolvedType == cache.intType && right.resolvedType == cache.intType {
            node.become(createIntBinary(node.kind, left.replaceWithNull, right.replaceWithNull).withRange(node.range))
          }
        }
      }

      # Group each variable inside the function with the function itself so that
      # they can be renamed together and won't cause any collisions inside the
      # function
      def unionVariableWithFunction(symbol Symbol, function Symbol) {
        if mangle && function != null {
          assert(symbol.id in namingGroupIndexForSymbol)
          assert(function.id in namingGroupIndexForSymbol)
          localVariableUnionFind.union(
            namingGroupIndexForSymbol[symbol.id],
            namingGroupIndexForSymbol[function.id])
        }
      }

      def patchNode(node Node) {
        if node == null {
          return
        }

        var oldEnclosingFunction = enclosingFunction
        var children = node.children
        var symbol = node.symbol
        var kind = node.kind

        if mangle && symbol != null {
          allocateNamingGroupIndex(symbol)
          if node.kind != .TYPE {
            symbolCounts[symbol.id] = symbolCounts.get(symbol.id, 0) + 1
          }
        }

        if children != null {
          if kind == .LAMBDA {
            enclosingFunction = symbol.asFunctionSymbol
          }

          for child in children {
            patchNode(child)
          }

          if kind == .LAMBDA {
            enclosingFunction = oldEnclosingFunction
          }
        }

        switch kind {
          case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE, .REMAINDER {
            patchBinaryArithmetic(node)
          }

          case .BLOCK {
            if mangle {
              peepholeMangleBlock(node)
            }
          }

          case .CAST {
            patchCast(node)
          }

          case .FOREACH {
            unionVariableWithFunction(symbol, enclosingFunction)
          }

          case .IF {
            if mangle {
              peepholeMangleIf(node)
            }
          }

          case .HOOK {
            if mangle {
              peepholeMangleHook(node)
            }
          }

          case .LAMBDA {
            var function = symbol.asFunctionSymbol
            for argument in function.arguments {
              allocateNamingGroupIndex(argument)
              unionVariableWithFunction(argument, function)
            }
            unionVariableWithFunction(function, enclosingFunction)
          }

          case .NAME {
            if symbol != null && symbol == currentSelf && enclosingFunction != null && enclosingFunction.kind == .FUNCTION_LOCAL {
              needsSelf = true
            }
          }

          case .TRY {
            patchTry(node)
          }

          case .VAR {
            unionVariableWithFunction(symbol, enclosingFunction)
          }
        }
      }

      def patchTry(node Node) {
        if node.children.count > 2 {
          var children = node.removeChildren
          var tryNode = children.first
          var finallyNode = children.last
          var variable = VariableSymbol.new(.VARIABLE_LOCAL, children.count == 3 && children[1].symbol != null ? children[1].symbol.name : enclosingFunction.scope.generateName("e"))
          var block Node = Node.createBlock([Node.createThrow(Node.createSymbolReference(variable))])

          for i in 1..children.count - 1 {
            var child = children[children.count - i - 1]
            var catchBlock = child.catchBlock.replaceWithNull

            # Just rename all catch symbols to the same name instead of substituting the variable
            if child.symbol != null {
              child.symbol.name = variable.name
            }

            # Build up the chain of tests in reverse
            if child.symbol != null && child.symbol.resolvedType != .DYNAMIC {
              var test = Node.createBinary(.IS, Node.createSymbolReference(variable), Node.createType(child.symbol.resolvedType))
              block = Node.createBlock([catchBlock.children.isEmpty
                ? Node.createIf(Node.createUnary(.NOT, test), block, null)
                : Node.createIf(test, catchBlock, block)])
            } else {
              block = catchBlock
            }
          }

          node.withChildren([tryNode, Node.createCatch(variable, block), finallyNode])
        }
      }

      def assignSourceIfNoSideEffects(node Node) Node {
        if node.kind == .ASSIGN {
          var right = node.binaryRight
          return node.binaryLeft.hasNoSideEffects && right.hasNoSideEffects ? right : null
        }

        if node.kind == .ASSIGN_INDEX {
          var children = node.children
          return children.count == 3 && children[0].hasNoSideEffects && children[1].hasNoSideEffects && children[2].hasNoSideEffects ? children[2] : null
        }

        return null
      }

      def peepholeMangleSequence(node Node) {
        assert(node.kind == .SEQUENCE)

        # "a = 0, b[c] = 0, d = 0;" => "a = b[c] = d = 0;"
        var i = node.children.count - 1
        while i > 0 {
          var current = node.children[i]
          var currentRight = assignSourceIfNoSideEffects(current)
          if currentRight != null {
            while i != 0 {
              var previous = node.children[i - 1]
              var previousRight = assignSourceIfNoSideEffects(previous)
              if previousRight == null || !looksTheSame(previousRight, currentRight) {
                break
              }
              previousRight.replaceWith(current.remove)
              current = previous
              i--
            }
          }
          i--
        }
      }

      def joinExpressions(left Node, right Node) Node {
        var sequence = Node.createSequence(left.kind == .SEQUENCE ? left.removeChildren : [left])
        sequence.appendChildren(right.kind == .SEQUENCE ? right.removeChildren : [right])
        return sequence
      }

      def looksTheSame(left Node, right Node) bool {
        if left.kind == right.kind {
          switch left.kind {
            case .NULL { return true }
            case .CONSTANT {
              switch left.content.kind {
                case .INT { return right.isInt && left.asInt == right.asInt }
                case .BOOL { return right.isBool && left.asBool == right.asBool }
                case .DOUBLE { return right.isDouble && left.asDouble == right.asDouble }
                case .STRING { return right.isString && left.asString == right.asString }
              }
            }
            case .NAME { return left.symbol != null && left.symbol == right.symbol || left.symbol == null && right.symbol == null && left.asString == right.asString }
            case .DOT { return left.symbol == right.symbol && looksTheSame(left.dotTarget, right.dotTarget) }
          }
        }

        # Null literals are always implicitly casted, so unwrap implicit casts
        if left.kind == .CAST { return looksTheSame(left.castValue, right) }
        if right.kind == .CAST { return looksTheSame(left, right.castValue) }
        return false
      }

      # Simplifies the node assuming it's used in a boolean context
      def peepholeMangleBoolean(node Node, canSwap BooleanSwap) BooleanSwap {
        var kind = node.kind

        if kind == .EQUAL || kind == .NOT_EQUAL {
          var left = node.binaryLeft
          var right = node.binaryRight
          var replacement = isFalsy(right) ? left : isFalsy(left) ? right : null

          # "if (a != 0) b;" => "if (a) b;"
          if replacement != null {

            # This minification is not valid for floating-point values because
            # of NaN, since NaN != 0 but NaN is falsy in JavaScript
            if left.resolvedType != null && left.resolvedType != cache.doubleType && right.resolvedType != null && right.resolvedType != cache.doubleType {
              replacement.replaceWithNull
              node.become(kind == .EQUAL ? Node.createUnary(.NOT, replacement) : replacement)
            }
          }

          else if cache.isInteger(left.resolvedType) && cache.isInteger(right.resolvedType) && (kind == .NOT_EQUAL || kind == .EQUAL && canSwap == .SWAP) {

            # "if (a != -1) c;" => "if (~a) c;"
            # "if (a == -1) c; else d;" => "if (~a) d; else c;"
            if right.isInt && right.asInt == -1 {
              node.become(Node.createUnary(.COMPLEMENT, left.replaceWithNull))
            }

            # "if (-1 != b) c;" => "if (~b) c;"
            # "if (-1 == b) c; else d;" => "if (~b) d; else c;"
            else if left.isInt && left.asInt == -1 {
              node.become(Node.createUnary(.COMPLEMENT, right.replaceWithNull))
            }

            # "if (a != b) c;" => "if (a ^ b) c;"
            # "if (a == b) c; else d;" => "if (a ^ b) d; else c;"
            else {
              node.kind = .BITWISE_XOR
            }

            return kind == .EQUAL ? .SWAP : .NO_SWAP
          }
        }

        # "if (a != 0 || b != 0) c;" => "if (a || b) c;"
        else if kind == .LOGICAL_AND || kind == .LOGICAL_OR {
          peepholeMangleBoolean(node.binaryLeft, .NO_SWAP)
          peepholeMangleBoolean(node.binaryRight, .NO_SWAP)
        }

        # "if (!a) b; else c;" => "if (a) c; else b;"
        # "a == 0 ? b : c;" => "a ? c : b;"
        # This is not an "else if" check since EQUAL may be turned into NOT above
        if node.kind == .NOT && canSwap == .SWAP {
          node.become(node.unaryValue.replaceWithNull)
          return .SWAP
        }

        return .NO_SWAP
      }

      def peepholeMangleIf(node Node) {
        var test = node.ifTest
        var trueBlock = node.ifTrue
        var falseBlock = node.ifFalse
        var trueStatement = trueBlock.blockStatement
        var swapped = peepholeMangleBoolean(test, falseBlock != null || trueStatement != null && trueStatement.kind == .EXPRESSION ? .SWAP : .NO_SWAP)

        if falseBlock != null {
          var falseStatement = falseBlock.blockStatement

          # "if (!a) b; else c;" => "if (a) c; else b;"
          if swapped == .SWAP {
            var block = trueBlock
            trueBlock = falseBlock
            falseBlock = block
            var statement = trueStatement
            trueStatement = falseStatement
            falseStatement = statement
            trueBlock.swapWith(falseBlock)
          }

          if trueStatement != null && falseStatement != null {

            # "if (a) b; else c;" => "a ? b : c;"
            if trueStatement.kind == .EXPRESSION && falseStatement.kind == .EXPRESSION {
              var hook = Node.createHook(test.replaceWithNull, trueStatement.expressionValue.replaceWithNull, falseStatement.expressionValue.replaceWithNull)
              peepholeMangleHook(hook)
              node.become(Node.createExpression(hook))
            }

            # "if (a) return b; else return c;" => "return a ? b : c;"
            else if trueStatement.kind == .RETURN && falseStatement.kind == .RETURN {
              var trueValue = trueStatement.returnValue
              var falseValue = falseStatement.returnValue
              if trueValue != null && falseValue != null {
                var hook = Node.createHook(test.replaceWithNull, trueValue.replaceWithNull, falseValue.replaceWithNull)
                peepholeMangleHook(hook)
                node.become(Node.createReturn(hook))
              }
            }
          }
        }

        # "if (a) b;" => "a && b;"
        # "if (!a) b;" => "a || b;"
        else if trueStatement != null && trueStatement.kind == .EXPRESSION {
          var value = trueStatement.expressionValue.replaceWithNull
          node.become(Node.createExpression(Node.createBinary(swapped == .SWAP ? .LOGICAL_OR : .LOGICAL_AND, test.replaceWithNull, value)))
        }
      }

      def peepholeMangleHook(node Node) {
        var test = node.hookTest
        var trueValue = node.hookTrue
        var falseValue = node.hookFalse
        var swapped = peepholeMangleBoolean(test, .SWAP)

        # "!a ? b : c;" => "a ? c : b;"
        if swapped == .SWAP {
          var temp = trueValue
          trueValue = falseValue
          falseValue = temp
          trueValue.swapWith(falseValue)
        }

        # "a ? a : b" => "a || b"
        if looksTheSame(test, trueValue) && test.hasNoSideEffects {
          node.become(Node.createBinary(.LOGICAL_OR, test.replaceWithNull, falseValue.replaceWithNull))
          return
        }

        # "a ? b : a" => "a && b"
        if looksTheSame(test, falseValue) && test.hasNoSideEffects {
          node.become(Node.createBinary(.LOGICAL_AND, test.replaceWithNull, trueValue.replaceWithNull))
          return
        }

        # "a ? b : b" => "a, b"
        if looksTheSame(trueValue, falseValue) {
          node.become(test.hasNoSideEffects ? trueValue.replaceWithNull : Node.createSequence([test.replaceWithNull, trueValue.replaceWithNull]))
          return
        }

        # Collapse partially-identical hook expressions
        if falseValue.kind == .HOOK {
          var falseTest = falseValue.hookTest
          var falseTrueValue = falseValue.hookTrue
          var falseFalseValue = falseValue.hookFalse

          # "a ? b : c ? b : d" => "a || c ? b : d"
          if looksTheSame(trueValue, falseTrueValue) {
            var or = Node.createBinary(.LOGICAL_OR, Node.createNull, falseTest.replaceWithNull)
            or.binaryLeft.replaceWith(test.replaceWith(or))
            falseValue.replaceWith(falseFalseValue.replaceWithNull)
            peepholeMangleHook(node)
            return
          }
        }

        # Collapse partially-identical binary expressions
        if trueValue.kind == falseValue.kind && trueValue.kind.isBinary {
          var trueLeft = trueValue.binaryLeft
          var trueRight = trueValue.binaryRight
          var falseLeft = falseValue.binaryLeft
          var falseRight = falseValue.binaryRight

          # "a ? b = c : b = d;" => "b = a ? c : d;"
          if looksTheSame(trueLeft, falseLeft) {
            var hook = Node.createHook(test.replaceWithNull, trueRight.replaceWithNull, falseRight.replaceWithNull)
            peepholeMangleHook(hook)
            node.become(Node.createBinary(trueValue.kind, trueLeft.replaceWithNull, hook))
          }

          # "a ? b + 100 : c + 100;" => "(a ? b + c) + 100;"
          else if looksTheSame(trueRight, falseRight) && !trueValue.kind.isBinaryAssign {
            var hook = Node.createHook(test.replaceWithNull, trueLeft.replaceWithNull, falseLeft.replaceWithNull)
            peepholeMangleHook(hook)
            node.become(Node.createBinary(trueValue.kind, hook, trueRight.replaceWithNull))
          }
        }
      }

      def peepholeMangleBlock(node Node) {
        var children = node.children
        var i = 0

        while i < children.count {
          var child = children[i]
          var kind = child.kind

          # "a; b; c;" => "a, b, c;"
          if kind == .EXPRESSION {
            while i + 1 < children.count {
              var next = children[i + 1]
              if next.kind != .EXPRESSION {
                break
              }
              var combined = Node.createExpression(joinExpressions(child.expressionValue.replaceWithNull, next.remove.expressionValue.replaceWithNull))
              child.replaceWith(combined)
              child = combined
            }
            var value = child.expressionValue
            if value.kind == .SEQUENCE {
              peepholeMangleSequence(value)
            }
          }

          else if kind == .RETURN && child.returnValue != null {
            while i != 0 {
              var previous = children[i - 1]

              # "if (a) return b; if (c) return d; return e;" => "return a ? b : c ? d : e;"
              if previous.kind == .IF && previous.ifFalse == null {
                var statement = previous.ifTrue.blockStatement
                if statement != null && statement.kind == .RETURN && statement.returnValue != null {
                  var hook = Node.createHook(previous.ifTest.replaceWithNull, statement.returnValue.replaceWithNull, child.returnValue.replaceWithNull)
                  peepholeMangleHook(hook)
                  child.remove
                  child = Node.createReturn(hook)
                  previous.replaceWith(child)
                } else {
                  break
                }
              }

              else {
                break
              }

              i--
            }
          }

          i++
        }
      }

      def patchCast(node Node) {
        var value = node.castValue
        var type = node.resolvedType
        var valueType = value.resolvedType

        # Cast to bool
        if type == cache.boolType {
          if valueType != cache.boolType {
            node.become(wrapWithNot(wrapWithNot(value.replaceWithNull)))
          }
        }

        # Cast to int
        else if cache.isInteger(type) {
          if !cache.isInteger(valueType) && !alwaysConvertsOperandsToInt(node.parent) {
            node.become(wrapWithIntCast(value.replaceWithNull))
          }
        }

        # Cast to double
        else if type == cache.doubleType {
          if !cache.isNumeric(valueType) {
            node.become(Node.createUnary(.POSITIVE, value.replaceWithNull).withRange(node.range).withType(cache.doubleType))
          }
        }

        # Cast to string
        else if type == cache.stringType {
          if valueType != cache.stringType {
            node.become(Node.createBinary(.ADD, value.replaceWithNull, Node.createString("").withType(cache.stringType)).withType(cache.stringType).withRange(node.range))
          }
        }
      }
    }
  }

  namespace JavaScriptEmitter {
    @private {
      def isCompactNodeKind(kind NodeKind) bool {
        return kind == .EXPRESSION || kind == .VAR || kind.isJump
      }

      def isFalsy(node Node) bool {
        switch node.kind {
          case .NULL { return true }
          case .CAST { return isFalsy(node.castValue) }
          case .CONSTANT {
            var content = node.content
            switch content.kind {
              case .INT { return content.asInt == 0 }
              case .DOUBLE { return content.asDouble == 0 || content.asDouble.isNAN }
              case .STRING { return content.asString == "" }
            }
          }
        }
        return false
      }

      def fullName(symbol Symbol) string {
        var parent = symbol.parent
        if parent != null && parent.kind != .OBJECT_GLOBAL {
          var enclosingName = fullName(parent)
          if symbol.isPrimaryConstructor {
            return enclosingName
          }
          if symbol.kind == .FUNCTION_INSTANCE {
            enclosingName += ".prototype"
          }
          return enclosingName + "." + mangleName(symbol)
        }
        return mangleName(symbol)
      }

      def shouldRenameSymbol(symbol Symbol) bool {
        # Don't rename annotations since "@rename" is used for renaming and is identified by name
        return !symbol.isImportedOrExported && symbol.kind != .FUNCTION_ANNOTATION
      }

      def mangleName(symbol Symbol) string {
        if symbol.isPrimaryConstructor {
          symbol = symbol.parent
        }
        if !symbol.isImportedOrExported && (symbol.name in isKeyword ||
          symbol.parent != null && symbol.parent.kind == .OBJECT_CLASS && !symbol.kind.isOnInstances && symbol.name in isFunctionProperty) {
          return "$" + symbol.name
        }
        return symbol.nameWithRenaming
      }

      const isFunctionProperty = {
        "apply": 0,
        "call": 0,
        "length": 0,
        "name": 0,
      }

      const isKeyword = {
        "arguments": 0,
        "Boolean": 0,
        "break": 0,
        "case": 0,
        "catch": 0,
        "class": 0,
        "const": 0,
        "constructor": 0,
        "continue": 0,
        "Date": 0,
        "debugger": 0,
        "default": 0,
        "delete": 0,
        "do": 0,
        "double": 0,
        "else": 0,
        "export": 0,
        "extends": 0,
        "false": 0,
        "finally": 0,
        "float": 0,
        "for": 0,
        "Function": 0,
        "function": 0,
        "if": 0,
        "import": 0,
        "in": 0,
        "instanceof": 0,
        "int": 0,
        "let": 0,
        "new": 0,
        "null": 0,
        "Number": 0,
        "Object": 0,
        "return": 0,
        "String": 0,
        "super": 0,
        "this": 0,
        "throw": 0,
        "true": 0,
        "try": 0,
        "var": 0,
      }

      def needsExtends(objects List<ObjectSymbol>) bool {
        for object in objects {
          if !object.isImported && object.baseClass != null {
            return true
          }
        }
        return false
      }

      def computePrefix(symbol ObjectSymbol) string {
        assert(symbol.kind.isObject)
        return symbol.kind == .OBJECT_GLOBAL ? "" : computePrefix(symbol.parent.asObjectSymbol) + mangleName(symbol) + "."
      }

      def alwaysConvertsOperandsToInt(node Node) bool {
        if node != null {
          switch node.kind {
            case
              .ASSIGN_BITWISE_AND, .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_XOR,
              .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT, .BITWISE_AND, .BITWISE_OR,
              .BITWISE_XOR, .COMPLEMENT, .SHIFT_LEFT, .SHIFT_RIGHT {
              return true
            }
          }
        }
        return false
      }
    }
  }
}
