namespace Skew {
  class JavaScriptTarget : CompilerTarget {
    over name string { return "JavaScript" }
    over extension string { return "js" }
    over runPostResolvePasses bool { return true }
    over supportsNestedTypes bool { return true }
    over editOptions(options CompilerOptions) { options.define("TARGET", "JAVASCRIPT") }
    over includeSources(sources List<Source>) { sources.prepend(Source.new("<native-js>", NATIVE_LIBRARY_JS)) }
    over createEmitter(options CompilerOptions, cache TypeCache) Emitter { return JavaScriptEmitter.new(options, cache) }
  }

  class JavaScriptEmitter : Emitter {
    enum BooleanSwap {
      SWAP
      NO_SWAP
    }

    enum ExtractGroupsMode {
      ALL_SYMBOLS
      ONLY_LOCAL_VARIABLES
      ONLY_INSTANCE_VARIABLES
    }

    class SymbolGroup {
      const symbols List<Symbol>
      const count int
    }

    enum AfterToken {
      AFTER_KEYWORD
      AFTER_PARENTHESIS
    }

    enum BracesMode {
      MUST_KEEP_BRACES
      CAN_OMIT_BRACES
    }

    const _options CompilerOptions
    const _cache TypeCache
    var _needsMultiply = false
    var _namespacePrefix = ""
    var _previousNode Node = null
    var _previousSymbol Symbol = null
    var _enclosingFunction FunctionSymbol = null # This includes lambdas during patching but not during emission
    var _extends VariableSymbol = null
    var _multiply VariableSymbol = null

    # Source map support
    var _sourceMap = false
    var _generator = SourceMapGenerator.new
    var _currentLine = 0
    var _currentColumn = 0
    var _previousStart = 0
    var _previousSource Source = null

    # A union-find data structure is used to quickly merge symbols into
    # groups. All local variables inside a function are merged with that
    # function. The map create a quick way of getting from a symbol to its
    # union/find index.
    var _allSymbols List<Symbol> = []
    var _localVariableUnionFind = UnionFind.new
    var _namingGroupIndexForSymbol IntMap<int> = {}
    var _nextSymbolName = 0
    var _symbolCounts IntMap<int> = {}

    # For minification
    var _mangle = false
    var _minify = false
    var _needsSemicolon = false
    var _newline = "\n"
    var _space = " "

    # For tracking "this" vs "self"
    var _currentSelf VariableSymbol = null
    var _needsSelf = false

    over visit(global ObjectSymbol) {
      _mangle = _options.jsMangle
      _minify = _options.jsMinify
      _sourceMap = _options.jsSourceMap

      if _minify {
        _indentAmount = ""
        _newline = ""
        _space = ""
      }

      # Preprocess the code
      _prepareGlobal(global)
      shakingPass(global, _cache.entryPointSymbol, .IGNORE_TYPES)
      _convertLambdasToFunctions(global)
      var objects = _sortedObjects(global)

      # The entire body of code is wrapped in a closure for safety
      _emit(_indent + "(function()" + _space + "{" + _newline)
      _increaseIndent

      # Emit special-cased variables that must come first
      if _needsExtends(objects) { _emitFunction(_convertLambdaToFunction(_extends)) }
      if _needsMultiply { _emitVariable(_multiply) }

      # Emit objects and functions
      for object in objects {
        _emitObject(object)
      }

      # Emit variables
      for object in objects {
        var o = object
        _namespacePrefix = ""
        while o.kind != .OBJECT_GLOBAL {
          _namespacePrefix = _mangleName(o) + "." + _namespacePrefix
          o = o.parent.asObjectSymbol
        }
        for variable in object.variables {
          if variable != _extends && variable != _multiply {
            _emitVariable(variable)
          }
        }
      }

      # Emit entry point
      var entryPointSymbol = _cache.entryPointSymbol
      if entryPointSymbol != null {
        var type = entryPointSymbol.resolvedType
        var callText = _fullName(entryPointSymbol) + (type.argumentTypes.isEmpty ? "()" : "(process.argv.slice(2))")
        _emitSemicolonIfNeeded
        _emit(_newline + _indent + (type.returnType == _cache.intType ? "process.exit(" + callText + ")" : callText))
        _emitSemicolonAfterStatement
      }

      # End the closure wrapping everything
      _decreaseIndent
      _emit(_indent + "})();\n")

      var codeName = _options.outputDirectory != "" ? _options.outputDirectory + "/compiled.js" : _options.outputFile
      var mapName = codeName + ".map"

      # Obfuscate the sourceMappingURL so it's not incorrectly picked up as the
      # sourceMappingURL for the compiled JavaScript compiler file
      if _sourceMap {
        _emit("/")
        _emit("/# sourceMappingURL=" + splitPath(mapName).entry + "\n")
      }

      _createSource(codeName, .ALWAYS_EMIT)

      # Create the source map
      if _sourceMap {
        _emit(_generator.toString)
        _createSource(mapName, .ALWAYS_EMIT)
      }
    }

    over _emit(text string) {
      if _minify || _sourceMap {
        for i in 0..text.count {
          var c = text[i]
          if c == '\n' {
            _currentColumn = 0
            _currentLine++
          } else {
            _currentColumn++
          }
        }
      }
      super(text)
    }

    def _prepareGlobal(global ObjectSymbol) {
      var globalObjects List<ObjectSymbol> = []
      var globalFunctions List<FunctionSymbol> = []
      var globalVariables List<VariableSymbol> = []

      # Load special-cased variables
      for variable in global.variables {
        if variable.name == "__extends" {
          _extends = variable
          if _multiply != null { break }
        } else if variable.name == "__imul" {
          _multiply = variable
          if _extends != null { break }
        }
      }
      assert(_extends != null)
      assert(_multiply != null)

      # Lower certain stuff into JavaScript (for example, "x as bool" becomes "!!x")
      _patchObject(global, globalObjects, globalFunctions, globalVariables)

      # Skip everything below if we aren't mangling
      if !_mangle {
        return
      }

      # Move internal global symbols up to the global namespace
      for object in globalObjects { object.parent = global }
      for function in globalFunctions { function.parent = global }
      for variable in globalVariables { variable.parent = global }
      global.objects.append(globalObjects)
      global.functions.append(globalFunctions)
      global.variables.append(globalVariables)

      # Rename symbols based on frequency for better compression
      _renameSymbols
    }

    def _convertLambdaToFunction(variable VariableSymbol) FunctionSymbol {
      var function = variable.value.symbol.asFunctionSymbol
      function.kind = .FUNCTION_GLOBAL
      function.parent = variable.parent
      function.name = variable.name
      return function
    }

    def _convertLambdasToFunctions(symbol ObjectSymbol) {
      for object in symbol.objects {
        _convertLambdasToFunctions(object)
      }

      symbol.variables.removeIf(variable => {
        if variable.kind == .VARIABLE_GLOBAL && variable.isConst && !variable.isExported && variable.value != null && variable.value.kind == .LAMBDA {
          symbol.functions.append(_convertLambdaToFunction(variable))
          return true
        }
        return false
      })
    }

    def _allocateNamingGroupIndex(symbol Symbol) {
      if _mangle && !(symbol.id in _namingGroupIndexForSymbol) {
        var index = _localVariableUnionFind.allocate
        _namingGroupIndexForSymbol[symbol.id] = index
        _allSymbols.append(symbol)

        # Explicitly add function arguments since they won't be reached by
        # normal tree traversal
        if symbol.kind.isFunction {
          var this = symbol.asFunctionSymbol.this
          if this != null {
            _allocateNamingGroupIndex(this)
          }
          for argument in symbol.asFunctionSymbol.arguments {
            _allocateNamingGroupIndex(argument)
          }
        }
      }
    }

    def _renameSymbols {
      # This holds the groups used for naming. Unioning two labels using
      # this object will cause both groups of symbols to have the same name.
      var namingGroupsUnionFind = UnionFind.new.allocate(_allSymbols.count)

      # These are optional and only reduce the number of generated names
      var order List<int> = []
      _aliasLocalVariables(namingGroupsUnionFind, order)
      _aliasUnrelatedProperties(namingGroupsUnionFind, order)

      # Ensure all overridden symbols have the same generated name. This is
      # manditory for correctness, otherwise virtual functions break.
      for symbol in _allSymbols {
        if symbol.kind.isFunction && symbol.asFunctionSymbol.overridden != null {
          assert(symbol.id in _namingGroupIndexForSymbol)
          assert(symbol.asFunctionSymbol.overridden.id in _namingGroupIndexForSymbol)
          namingGroupsUnionFind.union(_namingGroupIndexForSymbol[symbol.id], _namingGroupIndexForSymbol[symbol.asFunctionSymbol.overridden.id])
        }
      }

      # Collect all reserved names together into one big set for querying
      var reservedNames StringMap<int> = _isKeyword.clone
      for symbol in _allSymbols {
        if !_shouldRenameSymbol(symbol) {
          reservedNames[symbol.name] = 0
        }
      }

      # Everything that should have the same name is now grouped together.
      # Generate and assign names to all internal symbols, but use shorter
      # names for more frequently used symbols.
      var sortedGroups List<SymbolGroup> = []
      for group in _extractGroups(namingGroupsUnionFind, .ALL_SYMBOLS) {
        var count = 0
        for symbol in group {
          if _shouldRenameSymbol(symbol) {
            count += _symbolCounts.get(symbol.id, 0)
          }
        }
        sortedGroups.append(SymbolGroup.new(group, count))
      }
      sortedGroups.sort((a, b) => b.count - a.count)
      for group in sortedGroups {
        var name = ""
        for symbol in group.symbols {
          if _shouldRenameSymbol(symbol) {
            if name == "" {
              name = _generateSymbolName(reservedNames)
            }
            symbol.name = name
          }
        }
      }
    }

    # Merge local variables from different functions together in the order
    # they were declared. This will cause every argument list to use the same
    # variables in the same order, which should offer better gzip:
    #
    #   function d(a, b) {}
    #   function e(a, b, c) {}
    #
    def _aliasLocalVariables(unionFind UnionFind, order List<int>) {
      _zipTogetherInOrder(unionFind, order, _extractGroups(_localVariableUnionFind, .ONLY_LOCAL_VARIABLES))
    }

    # Merge all related types together into naming groups. This ensures names
    # will be unique within a subclass hierarchy allowing names to be
    # duplicated in separate subclass hierarchies.
    def _aliasUnrelatedProperties(unionFind UnionFind, order List<int>) {
      var relatedTypesUnionFind = UnionFind.new.allocate(_allSymbols.count)
      for i in 0.._allSymbols.count {
        var symbol = _allSymbols[i]
        if symbol.kind == .OBJECT_CLASS {
          var baseClass = symbol.asObjectSymbol.baseClass
          if baseClass != null {
            relatedTypesUnionFind.union(i, _namingGroupIndexForSymbol[baseClass.id])
          }
          for variable in symbol.asObjectSymbol.variables {
            relatedTypesUnionFind.union(i, _namingGroupIndexForSymbol[variable.id])
          }
        }
      }
      _zipTogetherInOrder(unionFind, order, _extractGroups(relatedTypesUnionFind, .ONLY_INSTANCE_VARIABLES))
    }

    def _zipTogetherInOrder(unionFind UnionFind, order List<int>, groups List<List<Symbol>>) {
      for group in groups {
        for i in 0..group.count {
          var symbol = group[i]
          var index = _namingGroupIndexForSymbol[symbol.id]
          if i >= order.count {
            order.append(index)
          } else {
            unionFind.union(index, order[i])
          }
        }
      }
    }

    def _generateSymbolName(reservedNames StringMap<int>) string {
      while true {
        var name = _numberToName(_nextSymbolName)
        _nextSymbolName++
        if !(name in reservedNames) {
          return name
        }
      }
    }

    def _extractGroups(unionFind UnionFind, mode ExtractGroupsMode) List<List<Symbol>> {
      var labelToGroup IntMap<List<Symbol>> = {}
      for symbol in _allSymbols {
        if mode == .ONLY_LOCAL_VARIABLES && !symbol.kind.isLocalOrArgumentVariable ||
            mode == .ONLY_INSTANCE_VARIABLES && symbol.kind != .VARIABLE_INSTANCE {
          continue
        }
        assert(symbol.id in _namingGroupIndexForSymbol)
        var label = unionFind.find(_namingGroupIndexForSymbol[symbol.id])
        var group = labelToGroup.get(label, null)
        if group == null {
          group = []
          labelToGroup[label] = group
        }
        group.append(symbol)
      }
      return labelToGroup.values
    }

    def _addMapping(range Range) {
      if _sourceMap && range != null {
        var source = range.source
        var start = range.start

        if _previousSource != source || _previousStart != start {
          var location = source.indexToLineColumn(start)
          _generator.addMapping(source, location.line, location.column, _currentLine, _currentColumn)
          _previousStart = start
          _previousSource = source
        }
      }
    }

    def _emitSemicolonAfterStatement {
      if !_minify {
        _emit(";\n")
      } else {
        _needsSemicolon = true
      }
    }

    def _emitSemicolonIfNeeded {
      if _needsSemicolon {
        _emit(";")
        _needsSemicolon = false
      }
      _maybeEmitMinifedNewline
    }

    # Lots of text editors choke up on long lines, so add a newline every now
    # and then for usability's sake
    def _maybeEmitMinifedNewline {
      if _minify && _currentColumn > 1024 {
        _emit("\n")
      }
    }

    def _emitNewlineBeforeSymbol(symbol Symbol) {
      _emitSemicolonIfNeeded
      if !_minify && _previousSymbol != null &&
          (!_previousSymbol.kind.isObject || !symbol.kind.isObject || symbol.comments != null || _previousSymbol.kind == .OBJECT_ENUM || symbol.kind == .OBJECT_ENUM) &&
          (!_previousSymbol.kind.isVariable || !symbol.kind.isVariable || symbol.comments != null) {
        _emit("\n")
      }
      _previousSymbol = null
    }

    def _emitNewlineAfterSymbol(symbol Symbol) {
      _previousSymbol = symbol
    }

    def _emitNewlineBeforeStatement(node Node) {
      if !_minify && _previousNode != null && (node.comments != null || !_isCompactNodeKind(_previousNode.kind) || !_isCompactNodeKind(node.kind)) {
        _emit("\n")
      } else {
        _maybeEmitMinifedNewline
      }
      _previousNode = null
    }

    def _emitNewlineAfterStatement(node Node) {
      _previousNode = node
    }

    def _emitComments(comments List<string>) {
      if comments != null && !_minify {
        for comment in comments {
          _emit(_indent + "//" + comment)
        }
      }
    }

    def _emitObject(symbol ObjectSymbol) {
      if symbol.isImported {
        return
      }

      _namespacePrefix = symbol.parent != null ? _computeNamespacePrefix(symbol.parent.asObjectSymbol) : ""

      switch symbol.kind {
        case .OBJECT_NAMESPACE, .OBJECT_INTERFACE {
          _addMapping(symbol.range)
          _emitNewlineBeforeSymbol(symbol)
          _emitComments(symbol.comments)
          _emit(_indent + (_namespacePrefix == "" && !symbol.isExported ? "var " : _namespacePrefix) + _mangleName(symbol) + _space + "=" + _space + "{}")
          _emitSemicolonAfterStatement
          _emitNewlineAfterSymbol(symbol)
        }

        case .OBJECT_ENUM {
          _addMapping(symbol.range)
          _emitNewlineBeforeSymbol(symbol)
          _emitComments(symbol.comments)
          _emit(_indent + (_namespacePrefix == "" && !symbol.isExported ? "var " : _namespacePrefix) + _mangleName(symbol) + _space + "=" + _space + "{")
          _increaseIndent
          var isFirst = true
          for variable in symbol.variables {
            if variable.kind == .VARIABLE_ENUM {
              if isFirst {
                isFirst = false
              } else {
                _emit(",")
              }
              _emit(_newline)
              _addMapping(variable.range)
              _emitNewlineBeforeSymbol(variable)
              _emitComments(variable.comments)
              _emit(_indent + _mangleName(variable) + ":" + _space)
              _emitContent(variable.value.content)
              _emitNewlineAfterSymbol(variable)
            }
          }
          _decreaseIndent
          if !isFirst && !_minify {
            _emit("\n" + _indent)
          }
          _emit("}")
          _emitSemicolonAfterStatement
          _emitNewlineAfterSymbol(symbol)
        }

        case .OBJECT_CLASS {
          var foundPrimaryConstructor = false
          for function in symbol.functions {
            if function.isPrimaryConstructor {
              if function.comments == null && symbol.comments != null {
                function.comments = symbol.comments
              }
              _emitFunction(function)
              if symbol.baseClass != null {
                if !_minify {
                  _emit("\n" + _indent)
                }
                _emitSemicolonIfNeeded
                _addMapping(_extends.range)
                _emit(_mangleName(_extends) + "(" + _fullName(symbol) + "," + _space + _fullName(symbol.baseClass) + ")")
                _emitSemicolonAfterStatement
              }
              foundPrimaryConstructor = true
              break
            }
          }

          # Ignore this entire class if it's never constructed
          if !foundPrimaryConstructor {
            return
          }
        }
      }

      if symbol.kind != .OBJECT_GLOBAL {
        _namespacePrefix += _mangleName(symbol) + "."
      }

      for function in symbol.functions {
        if !function.isPrimaryConstructor {
          _emitFunction(function)
        }
      }
    }

    def _emitArgumentList(arguments List<VariableSymbol>) {
      for argument in arguments {
        if argument != arguments.first {
          _emit("," + _space)
        }
        _addMapping(argument.range)
        _emit(_mangleName(argument))
      }
    }

    def _emitFunction(symbol FunctionSymbol) {
      if symbol.block == null {
        return
      }

      _addMapping(symbol.range)
      _emitNewlineBeforeSymbol(symbol)
      _emitComments(symbol.comments)

      var isExpression = _namespacePrefix != "" || symbol.isExported
      var name = _mangleName(symbol.isPrimaryConstructor ? symbol.parent : symbol)

      if isExpression {
        _emit(_indent + _namespacePrefix + (symbol.kind == .FUNCTION_INSTANCE ? "prototype." : "") + name + _space + "=" + _space + "function(")
      } else {
        _emit(_indent + "function " + name + "(")
      }

      _emitArgumentList(symbol.arguments)
      _emit(")" + _space + "{" + _newline)
      _increaseIndent
      _enclosingFunction = symbol
      _emitStatements(symbol.block)
      _enclosingFunction = null
      _decreaseIndent
      _emit(_indent + "}")
      if isExpression {
        _emitSemicolonAfterStatement
      } else {
        _needsSemicolon = false
        _emit(_newline)
      }
      _emitNewlineAfterSymbol(symbol)

      if symbol.kind == .FUNCTION_CONSTRUCTOR && !symbol.isPrimaryConstructor {
        _emitSemicolonIfNeeded
        _emit(_newline + _indent + _fullName(symbol) + ".prototype" + _space + "=" + _space + _fullName(symbol.parent) + ".prototype")
        _emitSemicolonAfterStatement
      }
    }

    def _emitVariable(symbol VariableSymbol) {
      if symbol.isImported {
        return
      }

      if symbol.kind != .VARIABLE_INSTANCE && symbol.kind != .VARIABLE_ENUM && (symbol.value != null || _namespacePrefix == "" || symbol.kind.isLocalOrArgumentVariable) {
        _addMapping(symbol.range)
        _emitNewlineBeforeSymbol(symbol)
        _emitComments(symbol.comments)
        _emit(_indent + (_namespacePrefix == "" && !symbol.isExported || symbol.kind.isLocalOrArgumentVariable ? "var " : _namespacePrefix) + _mangleName(symbol))

        if symbol.value != null {
          _emit(_space + "=" + _space)
          _emitExpression(symbol.value, .COMMA)
        }

        _emitSemicolonAfterStatement
        _emitNewlineAfterSymbol(symbol)
      }
    }

    def _emitStatements(node Node) {
      _previousNode = null

      for child = node.firstChild; child != null; child = child.nextSibling {
        _emitSemicolonIfNeeded
        _emitNewlineBeforeStatement(child)
        _addMapping(child.range)
        _emitComments(child.comments)
        _emitStatement(child)
        _emitNewlineAfterStatement(child)
      }

      _previousNode = null
    }

    def _emitBlock(node Node, after AfterToken, mode BracesMode) {
      var shouldMinify = mode == .CAN_OMIT_BRACES && _minify
      _addMapping(node.range)
      if shouldMinify && !node.hasChildren {
        _emit(";")
      } else if shouldMinify && node.hasOneChild {
        if after == .AFTER_KEYWORD {
          _emit(" ")
        }
        _emitStatement(node.firstChild)
      } else {
        _emit(_space + "{" + _newline)
        if node.hasChildren {
          _increaseIndent
          _emitStatements(node)
          _decreaseIndent
        }
        _emit(_indent + "}")
        _needsSemicolon = false
      }
    }

    def _emitVariables(node Node) {
      _emit("var ")
      for child = node.firstChild; child != null; child = child.nextSibling {
        if child.previousSibling != null {
          _emit("," + _space)
        }
        var symbol = child.symbol.asVariableSymbol
        _emit(_mangleName(symbol))
        if symbol.value != null {
          _emit(_space + "=" + _space)
          _emitExpression(symbol.value, .COMMA)
        }
      }
    }

    def _emitSpaceBeforeKeyword(node Node) {
      if !_minify || !node.kind.isUnary && !node.isString && !node.isNumberLessThanZero {
        _emit(" ")
      }
    }

    def _emitStatement(node Node) {
      switch node.kind {
        case .VARIABLES {
          _emit(_indent)
          _emitVariables(node)
          _emitSemicolonAfterStatement
        }

        case .EXPRESSION {
          _emit(_indent)
          _emitExpression(node.expressionValue, .LOWEST)
          _emitSemicolonAfterStatement
        }

        case .BREAK {
          _emit(_indent + "break")
          _emitSemicolonAfterStatement
        }

        case .CONTINUE {
          _emit(_indent + "continue")
          _emitSemicolonAfterStatement
        }

        case .RETURN {
          _emit(_indent + "return")
          var value = node.returnValue
          if value != null {
            _emitSpaceBeforeKeyword(value)
            _emitExpression(value, .LOWEST)
          }
          _emitSemicolonAfterStatement
        }

        case .THROW {
          var value = node.throwValue
          _emit(_indent + "throw")
          _emitSpaceBeforeKeyword(value)
          _emitExpression(value, .LOWEST)
          _emitSemicolonAfterStatement
        }

        case .FOR {
          var setup = node.forSetup
          var test = node.forTest
          var update = node.forUpdate
          _emit(_indent + "for" + _space + "(")
          if !setup.isEmptySequence {
            if setup.kind == .VARIABLES {
              _emitVariables(setup)
            } else {
              _emitExpression(setup, .LOWEST)
            }
          }
          _emit(";" + _space)
          if !test.isEmptySequence {
            _emitExpression(test, .LOWEST)
          }
          _emit(";" + _space)
          if !update.isEmptySequence {
            _emitExpression(update, .LOWEST)
          }
          _emit(")")
          _emitBlock(node.forBlock, .AFTER_PARENTHESIS, .CAN_OMIT_BRACES)
          _emit(_newline)
        }

        case .FOREACH {
          _emit(_indent + "for" + _space + "(var " + _mangleName(node.symbol) + " in ")
          _emitExpression(node.foreachValue, .LOWEST)
          _emit(")")
          _emitBlock(node.foreachBlock, .AFTER_PARENTHESIS, .CAN_OMIT_BRACES)
          _emit(_newline)
        }

        case .IF {
          _emit(_indent)
          _emitIf(node)
          _emit(_newline)
        }

        case .SWITCH {
          var switchValue = node.switchValue
          _emit(_indent + "switch" + _space + "(")
          _emitExpression(switchValue, .LOWEST)
          _emit(")" + _space + "{" + _newline)
          _increaseIndent
          for child = switchValue.nextSibling; child != null; child = child.nextSibling {
            var block = child.caseBlock
            _emitSemicolonIfNeeded
            if child.previousSibling != switchValue {
              _emit(_newline)
            }
            if child.hasOneChild {
              _emit(_indent + "default:")
            } else {
              for value = child.firstChild; value != block; value = value.nextSibling {
                if value.previousSibling != null {
                  _emit(_newline)
                }
                _emit(_indent + "case ")
                _emitExpression(value, .LOWEST)
                _emit(":")
              }
            }
            if !_minify {
              _emit(" {\n")
              _increaseIndent
            }
            _emitStatements(block)
            if !block.blockAlwaysEndsWithReturn {
              _emitSemicolonIfNeeded
              _emit(_indent + "break")
              _emitSemicolonAfterStatement
            }
            if !_minify {
              _decreaseIndent
              _emit(_indent + "}\n")
            }
          }
          _decreaseIndent
          _emit(_indent + "}" + _newline)
          _needsSemicolon = false
        }

        case .TRY {
          var tryBlock = node.tryBlock
          var finallyBlock = node.finallyBlock
          _emit(_indent + "try")
          _emitBlock(tryBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
          _emit(_newline)
          for child = tryBlock.nextSibling; child != finallyBlock; child = child.nextSibling {
            _emit(_newline)
            _emitComments(child.comments)
            _emit(_indent + "catch" + _space + "(" + _mangleName(child.symbol) + ")")
            _emitBlock(child.catchBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
            _emit(_newline)
          }
          if finallyBlock != null {
            _emit(_newline)
            _emitComments(finallyBlock.comments)
            _emit(_indent + "finally")
            _emitBlock(finallyBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
            _emit(_newline)
          }
        }

        case .WHILE {
          _emit(_indent + "while" + _space + "(")
          _emitExpression(node.whileTest, .LOWEST)
          _emit(")")
          _emitBlock(node.whileBlock, .AFTER_PARENTHESIS, .CAN_OMIT_BRACES)
          _emit(_newline)
        }

        default {
          assert(false)
        }
      }
    }

    def _emitIf(node Node) {
      var trueBlock = node.ifTrue
      var falseBlock = node.ifFalse
      _emit("if" + _space + "(")
      _emitExpression(node.ifTest, .LOWEST)
      _emit(")")

      # Make sure to always keep braces to avoid the dangling "else" case
      # "if (a) if (b) c; else d; else e;"
      # "if (a) { if (b) if (c) d; else e; } else f;"
      # "if (a) { if (b) c; else if (d) e; } else f;"
      # "if (a) { while (true) if (b) break; } else c;"
      var braces = BracesMode.CAN_OMIT_BRACES
      if falseBlock != null {
        var statement = trueBlock.blockStatement
        if statement != null && (statement.kind == .IF ||
            statement.kind == .FOR && statement.forBlock.blockStatement != null ||
            statement.kind == .FOREACH && statement.foreachBlock.blockStatement != null ||
            statement.kind == .WHILE && statement.whileBlock.blockStatement != null) {
          braces = .MUST_KEEP_BRACES
        }
      }
      _emitBlock(node.ifTrue, .AFTER_PARENTHESIS, braces)

      if falseBlock != null {
        var singleIf = _singleIf(falseBlock)
        _emitSemicolonIfNeeded
        _emit(_newline + _newline)
        _emitComments(falseBlock.comments)
        if singleIf != null {
          _emitComments(singleIf.comments)
        }
        _emit(_indent + "else")

        if singleIf != null {
          _emit(" ")
          _emitIf(singleIf)
        } else {
          _emitBlock(falseBlock, .AFTER_KEYWORD, .CAN_OMIT_BRACES)
        }
      }
    }

    def _emitContent(content Content) {
      switch content.kind {
        case .BOOL { _emit(content.asBool.toString) }
        case .INT { _emit(content.asInt.toString) }
        case .DOUBLE { _emit(content.asDouble.toString) }
        case .STRING { _emit(quoteString(content.asString, .SHORTEST)) }
      }
    }

    def _emitCommaSeparatedExpressions(from Node, to Node) {
      while from != to {
        _emitExpression(from, .COMMA)
        from = from.nextSibling
        if from != to {
          _emit("," + _space)
        }
      }
    }

    def _emitExpression(node Node, precedence Precedence) {
      var kind = node.kind
      _addMapping(node.range)

      switch kind {
        case .TYPE {
          _emit(_fullName(node.resolvedType.symbol))
        }

        case .NULL {
          _emit("null")
        }

        case .NAME {
          var symbol = node.symbol
          _emit(symbol != null ? _fullName(symbol) : node.asString)
        }

        case .DOT {
          _emitExpression(node.dotTarget, .MEMBER)
          _emit("." + (node.symbol != null ? _mangleName(node.symbol) : node.asString))
        }

        case .CONSTANT {
          _emitContent(node.content)
        }

        case .CALL {
          var value = node.callValue
          var call = value.kind == .SUPER
          var wrap = value.kind == .LAMBDA && node.parent != null && node.parent.kind == .EXPRESSION

          if wrap {
            _emit("(")
          }

          if !call && node.symbol != null && node.symbol.kind == .FUNCTION_CONSTRUCTOR {
            _emit("new " + _fullName(node.symbol))
          } else if !call && value.kind == .DOT && value.asString == "new" {
            _emit("new ")
            _emitExpression(value.dotTarget, .MEMBER)
          } else {
            _emitExpression(value, .UNARY_POSTFIX)
            if call {
              _emit(".call")
            }
          }

          if wrap {
            _emit(")")
          }

          _emit("(")

          if call {
            _emit(_mangleName(_enclosingFunction.this))
          }

          for child = value.nextSibling; child != null; child = child.nextSibling {
            if call || child.previousSibling != value {
              _emit("," + _space)
            }
            _emitExpression(child, .COMMA)
          }

          _emit(")")
        }

        case .INITIALIZER_LIST, .INITIALIZER_MAP {
          var useBraces = kind == .INITIALIZER_MAP
          var isIndented = false

          if !_minify {
            for child = node.firstChild; child != null; child = child.nextSibling {
              if child.comments != null {
                isIndented = true
                break
              }
            }
          }

          _emit(useBraces ? "{" : "[")
          if isIndented {
            _increaseIndent
          }

          for child = node.firstChild; child != null; child = child.nextSibling {
            if child.previousSibling != null {
              _emit("," + (isIndented ? "" : _space))
            }
            if isIndented {
              _emit("\n")
              _emitComments(child.comments)
              _emit(_indent)
            }
            _emitExpression(child, .COMMA)
          }

          if isIndented {
            _decreaseIndent
            _emit("\n" + _indent)
          }
          _emit(useBraces ? "}" : "]")
        }

        case .PAIR {
          _emitExpression(node.firstValue, .LOWEST)
          _emit(":" + _space)
          _emitExpression(node.secondValue, .LOWEST)
        }

        case .INDEX {
          _emitExpression(node.indexLeft, .UNARY_POSTFIX)
          _emit("[")
          _emitExpression(node.indexRight, .LOWEST)
          _emit("]")
        }

        case .ASSIGN_INDEX {
          if Precedence.ASSIGN as int < precedence as int {
            _emit("(")
          }
          _emitExpression(node.assignIndexLeft, .UNARY_POSTFIX)
          _emit("[")
          _emitExpression(node.assignIndexCenter, .LOWEST)
          _emit("]" + _space + "=" + _space + "")
          _emitExpression(node.assignIndexRight, .ASSIGN)
          if Precedence.ASSIGN as int < precedence as int {
            _emit(")")
          }
        }

        case .CAST {
          _emitExpression(node.castValue, precedence)
        }

        case .PARAMETERIZE {
          _emitExpression(node.parameterizeValue, precedence)
        }

        case .SEQUENCE {
          if Precedence.COMMA as int <= precedence as int {
            _emit("(")
          }
          _emitCommaSeparatedExpressions(node.firstChild, null)
          if Precedence.COMMA as int <= precedence as int {
            _emit(")")
          }
        }

        case .SUPER {
          _emit(_fullName(node.symbol))
        }

        case .HOOK {
          if Precedence.ASSIGN as int < precedence as int {
            _emit("(")
          }
          _emitExpression(node.hookTest, .LOGICAL_OR)
          _emit(_space + "?" + _space)
          _emitExpression(node.hookTrue, .ASSIGN)
          _emit(_space + ":" + _space)
          _emitExpression(node.hookFalse, .ASSIGN)
          if Precedence.ASSIGN as int < precedence as int {
            _emit(")")
          }
        }

        case .LAMBDA {
          var symbol = node.symbol.asFunctionSymbol
          _emit("function(")
          _emitArgumentList(symbol.arguments)
          _emit(")")
          _emitBlock(symbol.block, .AFTER_PARENTHESIS, .MUST_KEEP_BRACES)
        }

        case .COMPLEMENT, .DECREMENT, .INCREMENT, .NEGATIVE, .NOT, .POSITIVE {
          var value = node.unaryValue
          var info = operatorInfo[kind]
          if info.precedence as int < precedence as int {
            _emit("(")
          }
          _emit(info.text)
          _emitExpression(value, info.precedence)
          if info.precedence as int < precedence as int {
            _emit(")")
          }
        }

        default {
          if kind.isBinary {
            var info = operatorInfo[kind]
            var right = node.binaryRight

            if info.precedence as int < precedence as int {
              _emit("(")
            }
            _emitExpression(node.binaryLeft, info.precedence.incrementIfRightAssociative(info.associativity))

            # Always emit spaces around keyword operators, even when minifying
            _emit(kind == .IN ? " in " : kind == .IS ? " instanceof " : _space + (kind == .EQUAL ? "===" : kind == .NOT_EQUAL ? "!==" : info.text) + _space)

            # Prevent "x - -1" from becoming "x--1"
            if _minify && (
                kind == .ADD && (right.kind == .POSITIVE || right.kind == .INCREMENT) ||
                kind == .SUBTRACT && (right.kind == .NEGATIVE || right.kind == .DECREMENT || right.isNumberLessThanZero)) {
              _emit(" ")
            }

            _emitExpression(right, info.precedence.incrementIfLeftAssociative(info.associativity))
            if info.precedence as int < precedence as int {
              _emit(")")
            }
          }

          else {
            assert(false)
          }
        }
      }
    }

    def _patchObject(symbol ObjectSymbol, globalObjects List<ObjectSymbol>, globalFunctions List<FunctionSymbol>, globalVariables List<VariableSymbol>) {
      var shouldLiftGlobals = _mangle && symbol.parent != null
      _allocateNamingGroupIndex(symbol)

      # Scan over child objects
      symbol.objects.removeIf(object => {
        _patchObject(object, globalObjects, globalFunctions, globalVariables)

        # When mangling, filter out all internal objects and move them to the global namespace
        if shouldLiftGlobals && !object.isImportedOrExported {
          globalObjects.append(object)
          return true
        }

        return false
      })

      # Scan over child functions
      var isPrimaryConstructor = true
      symbol.functions.removeIf(function => {
        var block = function.block
        var this = function.this
        _allocateNamingGroupIndex(function)

        # Check to see if we need an explicit "self" parameter while patching the block
        _needsSelf = false
        _currentSelf = this
        _enclosingFunction = function
        _patchNode(block)
        _enclosingFunction = null

        # Only insert the "self" variable if required to handle capture inside lambdas
        if _needsSelf {
          _unionVariableWithFunction(this, function)
          if block != null {
            var variable = Node.createVariable(this)
            var merged = false
            this.value = Node.createName("this")

            # When mangling, add the "self" variable to an existing variable statement if present
            if _mangle && block.hasChildren {
              var firstChild = block.firstChild
              if firstChild.kind == .VARIABLES {
                firstChild.prependChild(variable)
                merged = true
              } else if firstChild.kind == .FOR {
                if firstChild.forSetup.kind == .VARIABLES {
                  firstChild.forSetup.prependChild(variable)
                  merged = true
                } else if firstChild.forSetup.isEmptySequence {
                  firstChild.forSetup.replaceWith(Node.createVariables.appendChild(variable))
                  merged = true
                }
              }
            }

            if !merged {
              block.prependChild(Node.createVariables.appendChild(variable))
            }
          }
        } else if this != null {
          this.name = "this"
          this.flags |= Symbol.IS_EXPORTED
        }

        for argument in function.arguments {
          _allocateNamingGroupIndex(argument)
          _unionVariableWithFunction(argument, function)
        }

        # When mangling, filter out all internal global functions and move them to the global namespace
        if shouldLiftGlobals && function.kind == .FUNCTION_GLOBAL && !function.isImportedOrExported {
          globalFunctions.append(function)
          return true
        }

        # Rename extra constructors overloads so they don't conflict
        if function.kind == .FUNCTION_CONSTRUCTOR {
          if isPrimaryConstructor {
            function.flags |= Symbol.IS_PRIMARY_CONSTRUCTOR
            isPrimaryConstructor = false
          }
        }

        return false
      })

      # Scan over child variables
      symbol.variables.removeIf(variable => {
        _allocateNamingGroupIndex(variable)
        _patchNode(variable.value)

        # When mangling, filter out all internal global variables and move them to the global namespace
        if shouldLiftGlobals && variable.kind == .VARIABLE_GLOBAL && !variable.isImportedOrExported {
          globalVariables.append(variable)
          return true
        }

        return false
      })
    }

    def _createIntBinary(kind NodeKind, left Node, right Node) Node {
      if kind == .MULTIPLY {
        _needsMultiply = true
        return Node.createCall(Node.createSymbolReference(_multiply)).withType(_cache.intType).appendChild(left).appendChild(right)
      }
      return _wrapWithIntCast(Node.createBinary(kind, left, right).withType(_cache.intType))
    }

    def _wrapWithNot(node Node) Node {
      return Node.createUnary(.NOT, node).withType(_cache.boolType).withRange(node.range)
    }

    def _wrapWithIntCast(node Node) Node {
      return Node.createBinary(.BITWISE_OR, node, Node.createInt(0).withType(_cache.intType)).withType(_cache.intType).withRange(node.range)
    }

    def _patchBinaryArithmetic(node Node) {
      # Make sure arithmetic integer operators don't emit doubles outside the
      # integer range. Allowing this causes JIT slowdowns due to extra checks
      # during compilation and potential deoptimizations during execution.
      if node.resolvedType == _cache.intType && !_alwaysConvertsOperandsToInt(node.parent) {
        var left = node.binaryLeft
        var right = node.binaryRight
        if left.resolvedType == _cache.intType && right.resolvedType == _cache.intType {
          node.become(_createIntBinary(node.kind, left.remove, right.remove).withRange(node.range))
        }
      }
    }

    # Group each variable inside the function with the function itself so that
    # they can be renamed together and won't cause any collisions inside the
    # function
    def _unionVariableWithFunction(symbol Symbol, function Symbol) {
      if _mangle && function != null {
        assert(symbol.id in _namingGroupIndexForSymbol)
        assert(function.id in _namingGroupIndexForSymbol)
        _localVariableUnionFind.union(
          _namingGroupIndexForSymbol[symbol.id],
          _namingGroupIndexForSymbol[function.id])
      }
    }

    def _patchNode(node Node) {
      if node == null {
        return
      }

      var oldEnclosingFunction = _enclosingFunction
      var symbol = node.symbol
      var kind = node.kind

      if _mangle && symbol != null {
        _allocateNamingGroupIndex(symbol)
        if node.kind != .TYPE {
          _symbolCounts[symbol.id] = _symbolCounts.get(symbol.id, 0) + 1
        }
      }

      if kind == .LAMBDA {
        _enclosingFunction = symbol.asFunctionSymbol
      }

      for child = node.firstChild; child != null; child = child.nextSibling {
        _patchNode(child)
      }

      if kind == .LAMBDA {
        _enclosingFunction = oldEnclosingFunction
      }

      switch kind {
        case .CONSTANT {
          if _mangle && node.content.kind == .BOOL {
            node.become(Node.createUnary(.NOT, Node.createInt(node.asBool ? 0 : 1)))
          }
        }

        case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE, .REMAINDER {
          _patchBinaryArithmetic(node)
        }

        case .ASSIGN_INDEX {
          if _mangle {
            _peepholeMangleAssignIndex(node)
          }
        }

        case .INDEX {
          if _mangle {
            _peepholeMangleIndex(node)
          }
        }

        case .BLOCK {
          if _mangle {
            _peepholeMangleBlock(node)
          }
        }

        case .CAST {
          _patchCast(node)
        }

        case .FOREACH {
          _unionVariableWithFunction(symbol, _enclosingFunction)
        }

        case .IF {
          if _mangle {
            _peepholeMangleIf(node)
          }
        }

        case .FOR {
          if _mangle {
            _peepholeMangleFor(node)
          }
        }

        case .WHILE {
          if _mangle {
            _peepholeMangleWhile(node)
          }
        }

        case .HOOK {
          if _mangle {
            _peepholeMangleHook(node)
          }
        }

        case .LAMBDA {
          var function = symbol.asFunctionSymbol
          for argument in function.arguments {
            _allocateNamingGroupIndex(argument)
            _unionVariableWithFunction(argument, function)
          }
          _unionVariableWithFunction(function, _enclosingFunction)
        }

        case .NAME {
          if symbol != null && symbol == _currentSelf && _enclosingFunction != null && _enclosingFunction.kind == .FUNCTION_LOCAL {
            _needsSelf = true
          }
        }

        case .TRY {
          _patchTry(node)
        }

        case .VARIABLE {
          _unionVariableWithFunction(symbol, _enclosingFunction)
        }

        default {
          if _mangle && kind.isBinary {
            _peepholeMangleBinary(node)
          }
        }
      }
    }

    def _patchTry(node Node) {
      if node.hasChildren && !node.hasOneChild {
        var tryBlock = node.tryBlock
        var finallyBlock = node.finallyBlock
        var firstCatch = finallyBlock != null ? finallyBlock.previousSibling : node.lastChild
        var variable = VariableSymbol.new(.VARIABLE_LOCAL, firstCatch.kind == .CATCH && firstCatch.symbol != null ?
          firstCatch.symbol.name : _enclosingFunction.scope.generateName("e"))
        var block = Node.createBlock.appendChild(Node.createThrow(Node.createSymbolReference(variable)))

        # Iterate backwards over the catch blocks
        for child = firstCatch, previous = child.previousSibling; child != tryBlock; child = previous, previous = child.previousSibling {
          var catchBlock = child.remove.catchBlock.remove

          # Just rename all catch symbols to the same name instead of substituting the variable
          if child.symbol != null {
            child.symbol.name = variable.name
          }

          # Build up the chain of tests in reverse
          if child.symbol != null && child.symbol.resolvedType != .DYNAMIC {
            var test = Node.createBinary(.IS, Node.createSymbolReference(variable), Node.createType(child.symbol.resolvedType))
            block = Node.createBlock.appendChild(catchBlock.hasChildren
              ? Node.createIf(test, catchBlock, block)
              : Node.createIf(Node.createUnary(.NOT, test), block, null))
          } else {
            block = catchBlock
          }
        }

        node.insertChildAfter(tryBlock, Node.createCatch(variable, block))

        # Make sure the new variable name is mangled
        _allocateNamingGroupIndex(variable)
        _unionVariableWithFunction(variable, _enclosingFunction)
      }
    }

    def _assignSourceIfNoSideEffects(node Node) Node {
      if node.kind == .ASSIGN {
        var right = node.binaryRight
        return node.binaryLeft.hasNoSideEffects && right.hasNoSideEffects ? right : null
      }

      if node.kind == .ASSIGN_INDEX {
        var right = node.assignIndexRight
        return node.assignIndexLeft.hasNoSideEffects && node.assignIndexCenter.hasNoSideEffects && right.hasNoSideEffects ? right : null
      }

      return null
    }

    def _peepholeMangleSequence(node Node) {
      assert(node.kind == .SEQUENCE)

      # "a = 0, b[c] = 0, d = 0;" => "a = b[c] = d = 0;"
      # "a = 0, b = 0, c = 1, d = 1;" => "a = b = 0, c = d = 1;"
      for child = node.lastChild; child != null; child = child.previousSibling {
        var childRight = _assignSourceIfNoSideEffects(child)
        if childRight != null {
          while true {
            var previous = child.previousSibling
            if previous == null {
              break
            }
            var previousRight = _assignSourceIfNoSideEffects(previous)
            if previousRight == null || !_looksTheSame(previousRight, childRight) {
              break
            }
            previousRight.become(child.remove)
            child = previous
          }
        }
      }
    }

    def _peepholeMangleBinary(node Node) {
      var kind = node.kind
      var left = node.binaryLeft
      var right = node.binaryRight

      # "(a, b) || c" => "a, b || c"
      # "(a, b) && c" => "a, b && c"
      if (kind == .LOGICAL_OR || kind == .LOGICAL_AND) && left.kind == .SEQUENCE {
        var binary = Node.createBinary(kind, left.lastChild.cloneAndStealChildren, right.remove)
        _peepholeMangleBinary(binary)
        left.lastChild.replaceWith(binary)
        node.become(left.remove)
      }

      # "a + (b + c)" => "(a + b) + c"
      else if kind.isBinaryAssociative && right.kind == kind {
        while true {
          node.rotateBinaryRightToLeft
          node = node.binaryLeft
          if !node.kind.isBinaryAssociative || node.binaryRight.kind != node.kind {
            break
          }
        }
      }

      else if (kind == .GREATER_THAN_OR_EQUAL || kind == .LESS_THAN_OR_EQUAL) && _cache.isInteger(left.resolvedType) && _cache.isInteger(right.resolvedType) {
        if left.isInt {
          var value = left.asInt

          # "2 >= a" => "3 > a"
          if node.kind == .GREATER_THAN_OR_EQUAL && _canIncrement(value) {
            left.content = IntContent.new(value + 1)
            node.kind = .GREATER_THAN
          }

          # "2 <= a" => "1 < a"
          else if node.kind == .LESS_THAN_OR_EQUAL && _canDecrement(value) {
            left.content = IntContent.new(value - 1)
            node.kind = .LESS_THAN
          }
        } else if right.isInt {
          var value = right.asInt

          # "a >= 2" => "a > 1"
          if node.kind == .GREATER_THAN_OR_EQUAL && _canDecrement(value) {
            right.content = IntContent.new(value - 1)
            node.kind = .GREATER_THAN
          }

          # "a <= 2" => "a < 3"
          else if node.kind == .LESS_THAN_OR_EQUAL && _canIncrement(value) {
            right.content = IntContent.new(value + 1)
            node.kind = .LESS_THAN
          }
        }
      }
    }

    # Simplifies the node assuming it's used in a boolean context. Note that
    # this may replace the passed-in node, which will then need to be queried
    # again if it's needed for further stuff.
    def _peepholeMangleBoolean(node Node, canSwap BooleanSwap) BooleanSwap {
      var kind = node.kind

      if kind == .EQUAL || kind == .NOT_EQUAL {
        var left = node.binaryLeft
        var right = node.binaryRight
        var replacement = _isFalsy(right) ? left : _isFalsy(left) ? right : null

        # "if (a != 0) b;" => "if (a) b;"
        if replacement != null {

          # This minification is not valid for floating-point values because
          # of NaN, since NaN != 0 but NaN is falsy in JavaScript
          if left.resolvedType != null && left.resolvedType != _cache.doubleType && right.resolvedType != null && right.resolvedType != _cache.doubleType {
            replacement.remove
            node.become(kind == .EQUAL ? Node.createUnary(.NOT, replacement) : replacement)
          }
        }

        else if _cache.isInteger(left.resolvedType) && _cache.isInteger(right.resolvedType) && (kind == .NOT_EQUAL || kind == .EQUAL && canSwap == .SWAP) {

          # "if (a != -1) c;" => "if (~a) c;"
          # "if (a == -1) c; else d;" => "if (~a) d; else c;"
          if right.isInt && right.asInt == -1 {
            node.become(Node.createUnary(.COMPLEMENT, left.remove))
          }

          # "if (-1 != b) c;" => "if (~b) c;"
          # "if (-1 == b) c; else d;" => "if (~b) d; else c;"
          else if left.isInt && left.asInt == -1 {
            node.become(Node.createUnary(.COMPLEMENT, right.remove))
          }

          # "if (a != b) c;" => "if (a ^ b) c;"
          # "if (a == b) c; else d;" => "if (a ^ b) d; else c;"
          else {
            node.kind = .BITWISE_XOR
          }

          return kind == .EQUAL ? .SWAP : .NO_SWAP
        }
      }

      # "if (a != 0 || b != 0) c;" => "if (a || b) c;"
      else if kind == .LOGICAL_AND || kind == .LOGICAL_OR {
        _peepholeMangleBoolean(node.binaryLeft, .NO_SWAP)
        _peepholeMangleBoolean(node.binaryRight, .NO_SWAP)
      }

      # "if (!a) b; else c;" => "if (a) c; else b;"
      # "a == 0 ? b : c;" => "a ? c : b;"
      # This is not an "else if" check since EQUAL may be turned into NOT above
      if node.kind == .NOT && canSwap == .SWAP {
        node.become(node.unaryValue.remove)
        return .SWAP
      }

      # "if (a, !b) c; else d;" => "if (a, b) d; else c;"
      if node.kind == .SEQUENCE {
        return _peepholeMangleBoolean(node.lastChild, canSwap)
      }

      return .NO_SWAP
    }

    def _peepholeMangleIf(node Node) {
      var test = node.ifTest
      var trueBlock = node.ifTrue
      var falseBlock = node.ifFalse
      var trueStatement = trueBlock.blockStatement
      var swapped = _peepholeMangleBoolean(test, falseBlock != null || trueStatement != null && trueStatement.kind == .EXPRESSION ? .SWAP : .NO_SWAP)

      if falseBlock != null {
        var falseStatement = falseBlock.blockStatement

        # "if (!a) b; else c;" => "if (a) c; else b;"
        if swapped == .SWAP {
          var block = trueBlock
          trueBlock = falseBlock
          falseBlock = block
          var statement = trueStatement
          trueStatement = falseStatement
          falseStatement = statement
          trueBlock.swapWith(falseBlock)
        }

        if trueStatement != null && falseStatement != null {

          # "if (a) b; else c;" => "a ? b : c;"
          if trueStatement.kind == .EXPRESSION && falseStatement.kind == .EXPRESSION {
            var hook = Node.createHook(test.remove, trueStatement.expressionValue.remove, falseStatement.expressionValue.remove)
            _peepholeMangleHook(hook)
            node.become(Node.createExpression(hook))
          }

          # "if (a) return b; else return c;" => "return a ? b : c;"
          else if trueStatement.kind == .RETURN && falseStatement.kind == .RETURN {
            var trueValue = trueStatement.returnValue
            var falseValue = falseStatement.returnValue
            if trueValue != null && falseValue != null {
              var hook = Node.createHook(test.remove, trueValue.remove, falseValue.remove)
              _peepholeMangleHook(hook)
              node.become(Node.createReturn(hook))
            }
          }
        }
      }

      # "if (a) b;" => "a && b;"
      # "if (!a) b;" => "a || b;"
      else if trueStatement != null && trueStatement.kind == .EXPRESSION {
        var binary = Node.createBinary(swapped == .SWAP ? .LOGICAL_OR : .LOGICAL_AND, test.remove, trueStatement.expressionValue.remove)
        _peepholeMangleBinary(binary)
        node.become(Node.createExpression(binary))
      }

      # "if (a) if (b) c;" => "if (a && b) c;"
      else {
        var singleIf = _singleIf(trueBlock)
        if singleIf != null && singleIf.ifFalse == null {
          var block = singleIf.ifTrue
          test.replaceWith(Node.createBinary(.LOGICAL_AND, test.cloneAndStealChildren, singleIf.ifTest.remove))
          trueBlock.replaceWith(block.remove)
        }
      }
    }

    def _peepholeMangleWhile(node Node) {
      var test = node.whileTest
      var block = node.whileBlock
      _peepholeMangleBoolean(test.remove, .NO_SWAP)

      # "while (a) {}" => "for (; a;) {}"
      var loop = Node.createFor(Node.createSequence, test, Node.createSequence, block.remove).withRange(node.range)
      _peepholeMangleFor(loop)
      node.become(loop)
    }

    def _peepholeMangleFor(node Node) {
      var test = node.forTest
      _peepholeMangleBoolean(test, .NO_SWAP)

      # "for (; true;) {}" => "for (;;) {}"
      if test.kind == .NOT && test.unaryValue.isInt && test.unaryValue.asInt == 0 {
        var empty = Node.createSequence
        test.replaceWith(empty)
        test = empty
      }

      # "for (a;;) if (b) break;" => "for (a; b;) {}"
      if node.forUpdate.isEmptySequence {
        var statement = node.forBlock.blockStatement
        if statement != null && statement.kind == .IF && statement.ifFalse == null {
          var branch = statement.ifTrue.blockStatement
          if branch != null && branch.kind == .BREAK {
            var condition = statement.remove.ifTest.remove
            condition.invertBooleanCondition(_cache)
            if test.isEmptySequence {
              test.replaceWith(condition)
            } else {
              condition = Node.createBinary(.LOGICAL_AND, test.cloneAndStealChildren, condition)
              _peepholeMangleBinary(condition)
              test.become(condition)
            }
          }
        }
      }
    }

    def _peepholeMangleHook(node Node) {
      var test = node.hookTest
      var trueValue = node.hookTrue
      var falseValue = node.hookFalse
      var swapped = _peepholeMangleBoolean(test, .SWAP)

      # "!a ? b : c;" => "a ? c : b;"
      if swapped == .SWAP {
        var temp = trueValue
        trueValue = falseValue
        falseValue = temp
        trueValue.swapWith(falseValue)
      }

      # "a.b ? c : null" => "a.b && c"
      if falseValue.kind == .CAST && falseValue.castValue.kind == .NULL && test.resolvedType != null && test.resolvedType != .DYNAMIC && test.resolvedType.isReference {
        node.become(Node.createBinary(.LOGICAL_AND, test.remove, trueValue.remove))
        return
      }

      # "a ? a : b" => "a || b"
      if _looksTheSame(test, trueValue) && test.hasNoSideEffects {
        node.become(Node.createBinary(.LOGICAL_OR, test.remove, falseValue.remove))
        return
      }

      # "a ? b : a" => "a && b"
      if _looksTheSame(test, falseValue) && test.hasNoSideEffects {
        node.become(Node.createBinary(.LOGICAL_AND, test.remove, trueValue.remove))
        return
      }

      # "a ? b : b" => "a, b"
      if _looksTheSame(trueValue, falseValue) {
        node.become(test.hasNoSideEffects ? trueValue.remove : Node.createSequence.appendChild(test.remove).appendChild(trueValue.remove))
        return
      }

      # Collapse partially-identical hook expressions
      if falseValue.kind == .HOOK {
        var falseTest = falseValue.hookTest
        var falseTrueValue = falseValue.hookTrue
        var falseFalseValue = falseValue.hookFalse

        # "a ? b : c ? b : d" => "a || c ? b : d"
        # "a ? b : c || d ? b : e" => "a || c || d ? b : e"
        if _looksTheSame(trueValue, falseTrueValue) {
          var both = Node.createBinary(.LOGICAL_OR, test.cloneAndStealChildren, falseTest.remove)
          _peepholeMangleBinary(both)
          test.replaceWith(both)
          falseValue.replaceWith(falseFalseValue.remove)
          _peepholeMangleHook(node)
          return
        }
      }

      # Collapse partially-identical binary expressions
      if trueValue.kind == falseValue.kind && trueValue.kind.isBinary {
        var trueLeft = trueValue.binaryLeft
        var trueRight = trueValue.binaryRight
        var falseLeft = falseValue.binaryLeft
        var falseRight = falseValue.binaryRight

        # "a ? b = c : b = d;" => "b = a ? c : d;"
        if _looksTheSame(trueLeft, falseLeft) {
          var hook = Node.createHook(test.remove, trueRight.remove, falseRight.remove)
          _peepholeMangleHook(hook)
          node.become(Node.createBinary(trueValue.kind, trueLeft.remove, hook))
        }

        # "a ? b + 100 : c + 100;" => "(a ? b + c) + 100;"
        else if _looksTheSame(trueRight, falseRight) && !trueValue.kind.isBinaryAssign {
          var hook = Node.createHook(test.remove, trueLeft.remove, falseLeft.remove)
          _peepholeMangleHook(hook)
          node.become(Node.createBinary(trueValue.kind, hook, trueRight.remove))
        }
      }
    }

    def _peepholeMangleAssignIndex(node Node) {
      var left = node.assignIndexLeft
      var center = node.assignIndexCenter
      var right = node.assignIndexRight

      if _isIdentifierString(center) {
        node.become(Node.createBinary(.ASSIGN, Node.createDot(left.remove, center.asString).withRange(
          Range.span(left.range, center.range)), right.remove).withRange(node.range))
      }
    }

    def _peepholeMangleIndex(node Node) {
      var left = node.indexLeft
      var right = node.indexRight

      if _isIdentifierString(right) {
        node.become(Node.createDot(left.remove, right.asString).withRange(node.range).withType(node.resolvedType))
      }
    }

    def _peepholeMangleBlock(node Node) {
      for child = node.firstChild, next Node = null; child != null; child = next {
        var previous = child.previousSibling
        next = child.nextSibling

        switch child.kind {
          # "var a; var b;" => "var a, b;"
          case .VARIABLES {
            if previous != null && previous.kind == .VARIABLES {
              child.replaceWith(previous.remove.appendChildrenFrom(child))
            }
          }

          # "a; b; c;" => "a, b, c;"
          case .EXPRESSION {
            if child.expressionValue.hasNoSideEffects {
              child.remove
            } else if previous != null && previous.kind == .EXPRESSION {
              var sequence = Node.createSequence(previous.remove.expressionValue.remove, child.expressionValue.remove)
              _peepholeMangleSequence(sequence)
              child.become(Node.createExpression(sequence))
            }
          }

          case .RETURN {
            while previous != null {
              # "if (a) return b; return c;" => "return a ? b : c;"
              if child.returnValue != null && previous.kind == .IF && previous.ifFalse == null {
                var statement = previous.ifTrue.blockStatement
                if statement != null && statement.kind == .RETURN && statement.returnValue != null {
                  var hook = Node.createHook(previous.remove.ifTest.remove, statement.returnValue.remove, child.returnValue.remove)
                  _peepholeMangleHook(hook)
                  child.become(Node.createReturn(hook))
                } else {
                  break
                }
              }

              # "a; return b;" => "return a, b;"
              else if child.returnValue != null && previous.kind == .EXPRESSION {
                var sequence = Node.createSequence(previous.remove.expressionValue.remove, child.returnValue.remove)
                _peepholeMangleSequence(sequence)
                child.become(Node.createReturn(sequence))
              }

              else {
                break
              }

              previous = child.previousSibling
            }
          }

          case .IF {
            while previous != null {
              # "if (a) b; if (c) b;" => "if (a || c) b;"
              if child.ifFalse == null && previous.kind == .IF && previous.ifFalse == null && _looksTheSame(previous.ifTrue, child.ifTrue) {
                child.ifTest.replaceWith(Node.createBinary(.LOGICAL_OR, previous.remove.ifTest.remove, child.ifTest.cloneAndStealChildren))
              }

              # "a; if (b) c;" => "if (a, b) c;"
              else if previous.kind == .EXPRESSION {
                var sequence = Node.createSequence(previous.remove.expressionValue.remove, child.ifTest.cloneAndStealChildren)
                _peepholeMangleSequence(sequence)
                child.ifTest.replaceWith(sequence)
              }

              else {
                break
              }

              previous = child.previousSibling
            }

            # "void foo() { if (a) return; b(); c() }" => "void foo() { if (!a) { b(); c() } }"
            # "while (a) { if (b) continue; c(); d() }" => "while (a) { if (!b) { c(); d() } }"
            if child.ifFalse == null {
              var trueBlock = child.ifTrue
              if trueBlock.hasChildren {
                var statement = trueBlock.lastChild
                if (statement.kind == .RETURN && statement.returnValue == null || statement.kind == .CONTINUE) && _isJumpImplied(node, statement.kind) {
                  var block Node

                  # If the if statement block without the jump is empty, then flip
                  # the condition of the if statement and reuse the block. Otherwise,
                  # create an else branch for the if statement and use that block.
                  statement.remove
                  if !trueBlock.hasChildren {
                    child.ifTest.invertBooleanCondition(_cache)
                    block = trueBlock
                  } else if next != null {
                    block = Node.createBlock
                    child.appendChild(block)
                    assert(block == child.ifFalse)
                  } else {
                    return # Returning here is fine because this is the last child
                  }

                  # Move the rest of this block into the block for the if statement
                  while child.nextSibling != null {
                    block.appendChild(child.nextSibling.remove)
                  }
                  _peepholeMangleBlock(block)
                  _peepholeMangleIf(child)

                  # "a(); if (b) return; c();" => "a(); if (!b) c();" => "a(); !b && c();" => "a(), !b && c();"
                  if child.kind == .EXPRESSION && previous != null && previous.kind == .EXPRESSION {
                    var sequence = Node.createSequence(previous.remove.expressionValue.remove, child.expressionValue.remove)
                    _peepholeMangleSequence(sequence)
                    child.become(Node.createExpression(sequence))
                  }
                  return
                }
              }
            }
          }

          case .FOR {
            var setup = child.forSetup

            # "var a; for (;;) {}" => "for (var a;;) {}"
            if previous != null && setup.isEmptySequence && previous.kind == .VARIABLES {
              setup.replaceWith(previous.remove.appendChildrenFrom(setup))
            }

            # "var a; for (var b;;) {}" => "for (var a, b;;) {}"
            else if previous != null && setup.kind == .VARIABLES && previous.kind == .VARIABLES {
              setup.replaceWith(previous.remove.appendChildrenFrom(setup))
            }

            # "a; for (b;;) {}" => "for (a, b;;) {}"
            else if previous != null && setup.kind.isExpression && previous.kind == .EXPRESSION {
              setup.replaceWith(Node.createSequence(previous.remove.expressionValue.remove, setup.cloneAndStealChildren))
            }
          }
        }
      }
    }

    def _patchCast(node Node) {
      var value = node.castValue
      var type = node.resolvedType
      var valueType = value.resolvedType

      # Cast to bool
      if type == _cache.boolType {
        if valueType != _cache.boolType {
          node.become(_wrapWithNot(_wrapWithNot(value.remove)))
        }
      }

      # Cast to int
      else if _cache.isInteger(type) {
        if !_cache.isInteger(valueType) && !_alwaysConvertsOperandsToInt(node.parent) {
          node.become(_wrapWithIntCast(value.remove))
        } else if value.isInt {
          node.become(value.remove.withType(node.resolvedType))
        }
      }

      # Cast to double
      else if type == _cache.doubleType {
        if !_cache.isNumeric(valueType) {
          node.become(Node.createUnary(.POSITIVE, value.remove).withRange(node.range).withType(_cache.doubleType))
        }
      }

      # Cast to string
      else if type == _cache.stringType {
        if valueType != _cache.stringType {
          node.become(Node.createBinary(.ADD, value.remove, Node.createString("").withType(_cache.stringType)).withType(_cache.stringType).withRange(node.range))
        }
      }
    }
  }

  namespace JavaScriptEmitter {
    def _isJumpImplied(node Node, kind NodeKind) bool {
      assert(node.kind == .BLOCK)
      assert(kind == .RETURN || kind == .CONTINUE)
      var parent = node.parent
      if kind == .RETURN && parent == null || kind == .CONTINUE && parent != null && parent.kind.isLoop {
        return true
      }
      if parent != null && parent.kind == .IF && parent.nextSibling == null {
        return _isJumpImplied(parent.parent, kind)
      }
      return false
    }

    def _canIncrement(value int) bool {
      return value < 0x7FFFFFFF
    }

    def _canDecrement(value int) bool {
      return value >= -0x7FFFFFFF
    }

    def _isIdentifierString(node Node) bool {
      if node.isString {
        var value = node.asString
        for i in 0..value.count {
          var c = value[i]
          if (c < 'A' || c > 'Z') && (c < 'a' || c > 'z') && c != '_' && c != '$' && (i == 0 || c < '0' || c > '9') {
            return false
          }
        }
        return value != "" && !(value in _isKeyword)
      }
      return false
    }

    def _singleIf(block Node) Node {
      if block == null {
        return null
      }
      var statement = block.blockStatement
      if statement != null && statement.kind == .IF {
        return statement
      }
      return null
    }

    def _symbolsOrStringsLookTheSame(left Node, right Node) bool {
      return
        left.symbol != null && left.symbol == right.symbol ||
        left.symbol == null && right.symbol == null && left.asString == right.asString
    }

    def _childrenLookTheSame(left Node, right Node) bool {
      var leftChild = left.firstChild
      var rightChild = right.firstChild

      while leftChild != null && rightChild != null {
        if !_looksTheSame(leftChild, rightChild) {
          return false
        }

        leftChild = leftChild.nextSibling
        rightChild = rightChild.nextSibling
      }

      return leftChild == null && rightChild == null
    }

    def _looksTheSame(left Node, right Node) bool {
      if left.kind == right.kind {
        switch left.kind {
          case .NULL { return true }
          case .NAME { return _symbolsOrStringsLookTheSame(left, right) }
          case .DOT { return _symbolsOrStringsLookTheSame(left, right) && _looksTheSame(left.dotTarget, right.dotTarget) }

          case .CONSTANT {
            switch left.content.kind {
              case .INT { return right.isInt && left.asInt == right.asInt }
              case .BOOL { return right.isBool && left.asBool == right.asBool }
              case .DOUBLE { return right.isDouble && left.asDouble == right.asDouble }
              case .STRING { return right.isString && left.asString == right.asString }
            }
          }

          case
            .BLOCK, .BREAK, .CONTINUE, .EXPRESSION, .IF, .RETURN, .THROW, .WHILE,
            .ASSIGN_INDEX, .CALL, .HOOK, .INDEX, .INITIALIZER_LIST, .INITIALIZER_MAP, .PAIR, .SEQUENCE,
            .COMPLEMENT, .DECREMENT, .INCREMENT, .NEGATIVE, .NOT, .POSITIVE {
            return _childrenLookTheSame(left, right)
          }

          default {
            if left.kind.isBinary { return _childrenLookTheSame(left, right) }
          }
        }
      }

      # Null literals are always implicitly casted, so unwrap implicit casts
      if left.kind == .CAST { return _looksTheSame(left.castValue, right) }
      if right.kind == .CAST { return _looksTheSame(left, right.castValue) }
      return false
    }

    def _numberToName(number int) string {
      const WRAP = 26 * 2
      var name = ""
      if number >= WRAP {
        name = _numberToName(number / WRAP - 1)
        number = number % WRAP
      }
      name += string.fromCodeUnit(number + (number < 26 ? 'a' : 'A' - 26))
      return name
    }

    def _isCompactNodeKind(kind NodeKind) bool {
      return kind == .EXPRESSION || kind == .VARIABLES || kind.isJump
    }

    def _isFalsy(node Node) bool {
      switch node.kind {
        case .NULL { return true }
        case .CAST { return _isFalsy(node.castValue) }
        case .CONSTANT {
          var content = node.content
          switch content.kind {
            case .INT { return content.asInt == 0 }
            case .DOUBLE { return content.asDouble == 0 || content.asDouble.isNaN }
            case .STRING { return content.asString == "" }
          }
        }
      }
      return false
    }

    def _fullName(symbol Symbol) string {
      var parent = symbol.parent
      if parent != null && parent.kind != .OBJECT_GLOBAL {
        var enclosingName = _fullName(parent)
        if symbol.isPrimaryConstructor {
          return enclosingName
        }
        if symbol.kind == .FUNCTION_INSTANCE {
          enclosingName += ".prototype"
        }
        return enclosingName + "." + _mangleName(symbol)
      }
      return _mangleName(symbol)
    }

    def _shouldRenameSymbol(symbol Symbol) bool {
      # Don't rename annotations since "@rename" is used for renaming and is identified by name
      return !symbol.isImportedOrExported && symbol.kind != .FUNCTION_ANNOTATION
    }

    def _mangleName(symbol Symbol) string {
      if symbol.isPrimaryConstructor {
        symbol = symbol.parent
      }
      if !symbol.isImportedOrExported && (symbol.name in _isKeyword ||
        symbol.parent != null && symbol.parent.kind == .OBJECT_CLASS && !symbol.kind.isOnInstances && symbol.name in _isFunctionProperty) {
        return "$" + symbol.name
      }
      return symbol.nameWithRenaming
    }

    def _needsExtends(objects List<ObjectSymbol>) bool {
      for object in objects {
        if !object.isImported && object.baseClass != null {
          return true
        }
      }
      return false
    }

    def _computeNamespacePrefix(symbol ObjectSymbol) string {
      assert(symbol.kind.isObject)
      return symbol.kind == .OBJECT_GLOBAL ? "" : _computeNamespacePrefix(symbol.parent.asObjectSymbol) + _mangleName(symbol) + "."
    }

    def _alwaysConvertsOperandsToInt(node Node) bool {
      if node != null {
        switch node.kind {
          case
            .ASSIGN_BITWISE_AND, .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_XOR,
            .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT, .BITWISE_AND, .BITWISE_OR,
            .BITWISE_XOR, .COMPLEMENT, .SHIFT_LEFT, .SHIFT_RIGHT {
            return true
          }
        }
      }
      return false
    }

    const _isFunctionProperty = {
      "apply": 0,
      "call": 0,
      "length": 0,
      "name": 0,
    }

    const _isKeyword = {
      "arguments": 0,
      "Boolean": 0,
      "break": 0,
      "case": 0,
      "catch": 0,
      "class": 0,
      "const": 0,
      "constructor": 0,
      "continue": 0,
      "Date": 0,
      "debugger": 0,
      "default": 0,
      "delete": 0,
      "do": 0,
      "double": 0,
      "else": 0,
      "export": 0,
      "extends": 0,
      "false": 0,
      "finally": 0,
      "float": 0,
      "for": 0,
      "Function": 0,
      "function": 0,
      "if": 0,
      "import": 0,
      "in": 0,
      "instanceof": 0,
      "int": 0,
      "let": 0,
      "new": 0,
      "null": 0,
      "Number": 0,
      "Object": 0,
      "return": 0,
      "String": 0,
      "super": 0,
      "this": 0,
      "throw": 0,
      "true": 0,
      "try": 0,
      "var": 0,
    }
  }
}
