namespace astral {
  class DebugEmitter : Emitter {
    override void visit(TypeSymbol global) {
      emitType(global)
      createSource("out.sk")
    }

    private {
      Symbol previousSymbol = null

      static bool isAbstractFunction(Symbol symbol) {
        return symbol.kind.isFunction() && symbol.asFunction().block == null
      }

      void emitNewlineBeforeSymbol(Symbol symbol) {
        if (previousSymbol != null &&
            (!isAbstractFunction(previousSymbol) || !isAbstractFunction(symbol) || symbol.comments != null) &&
            (!previousSymbol.kind.isVariable() || !symbol.kind.isVariable() || symbol.comments != null)) {
          previousSymbol = null
          emit("\n")
        }
      }

      void emitNewlineAfterSymbol(Symbol symbol) {
        previousSymbol = symbol
      }

      void emitComments(Symbol symbol) {
        var comments = symbol.comments
        if (comments != null) {
          for (var i = 0; i < comments.size(); i++) {
            emit(indent + "//" + comments[i])
          }
        }
      }

      void emitType(TypeSymbol symbol) {
        emitNewlineBeforeSymbol(symbol)
        emitComments(symbol)

        switch (symbol.kind) {
          case .TYPE_CLASS {
            emit(indent + "class " + symbol.name)
            emitParameterList(symbol.parameters)
            if (symbol.base != null) {
              emit(" : ")
              emitExpression(symbol.base, .LOWEST)
            }
            emit(" {\n")
            increaseIndent()
          }

          case .TYPE_INTERFACE {
            emit(indent + "interface " + symbol.name)
            emitParameterList(symbol.parameters)
            emit(" {\n")
            increaseIndent()
          }

          case .TYPE_NAMESPACE {
            emit(indent + "namespace " + symbol.name + " {\n")
            increaseIndent()
          }
        }

        previousSymbol = null

        for (var i = 0; i < symbol.types.size(); i++) {
          emitType(symbol.types[i])
        }

        for (var i = 0; i < symbol.variables.size(); i++) {
          emitVariable(symbol.variables[i])
        }

        for (var i = 0; i < symbol.functions.size(); i++) {
          emitFunction(symbol.functions[i])
        }

        switch (symbol.kind) {
          case .TYPE_CLASS, .TYPE_INTERFACE, .TYPE_NAMESPACE {
            decreaseIndent()
            emit(indent + "}\n")
          }
        }

        emitNewlineAfterSymbol(symbol)
      }

      void emitParameterList(List<ParameterSymbol> parameters) {
        if (parameters != null) {
          emit("<")
          for (var i = 0; i < parameters.size(); i++) {
            if (i > 0) emit(", ")
            emit(parameters[i].name)
          }
          emit(">")
        }
      }

      void emitArgumentList(List<VariableSymbol> arguments) {
        for (var i = 0; i < arguments.size(); i++) {
          if (i > 0) emit(", ")
          var arg = arguments[i]
          emit(arg.name)
          if (arg.type != null) {
            emit(" ")
            emitExpression(arg.type, .LOWEST)
          }
          if (arg.value != null) {
            emit(" = ")
            emitExpression(arg.value, .LOWEST)
          }
        }
      }

      void emitFunction(FunctionSymbol symbol) {
        emitNewlineBeforeSymbol(symbol)
        emitComments(symbol)
        emit(indent)
        switch (symbol.kind) {
          case .FUNCTION_CONSTRUCTOR { emit("cdef ") }
          case .FUNCTION_GLOBAL { emit("def ") }
          case .FUNCTION_INSTANCE { emit("idef ") }
        }
        emit(symbol.name)
        emitParameterList(symbol.parameters)
        emit("(")
        emitArgumentList(symbol.arguments)
        emit(")")
        if (symbol.returnType != null) {
          emit(" ")
          emitExpression(symbol.returnType, .LOWEST)
        }
        if (symbol.block != null) {
          emitBlock(symbol.block)
        }
        emit("\n")
        emitNewlineAfterSymbol(symbol)
      }

      void emitVariable(VariableSymbol symbol) {
        emitNewlineBeforeSymbol(symbol)
        emitComments(symbol)
        emit(indent + (symbol.kind == .VARIABLE_INSTANCE ? "ivar " : "var ") + symbol.name)
        if (symbol.type != null) {
          emit(" ")
          emitExpression(symbol.type, .LOWEST)
        }
        if (symbol.value != null) {
          emit(" = ")
          emitExpression(symbol.value, .LOWEST)
        }
        emit("\n")
        emitNewlineAfterSymbol(symbol)
      }

      void emitBlock(Node node) {
        emit(" {\n")
        increaseIndent()
        for (var i = 0; i < node.children.size(); i++) {
          emitStatement(node.children[i])
        }
        decreaseIndent()
        emit(indent + "}")
      }

      void emitStatement(Node node) {
        switch (node.kind) {
          case .VAR {
            emitVariable((VariableSymbol)node.symbol)
          }

          case .EXPRESSION {
            emit(indent)
            emitExpression(node.expressionValue(), .LOWEST)
            emit("\n")
          }

          case .BREAK {
            emit(indent + "break\n")
          }

          case .CONTINUE {
            emit(indent + "continue\n")
          }

          case .RETURN {
            emit(indent + "return")
            var value = node.returnValue()
            if (value != null) {
              emit(" ")
              emitExpression(value, .LOWEST)
            }
            emit("\n")
          }

          case .IF {
            emit(indent + "if ")
            emitExpression(node.ifTest(), .LOWEST)
            emitBlock(node.ifTrue())
            var block = node.ifFalse()
            if (block != null) {
              emit(" else")
              emitBlock(block)
            }
            emit("\n")
          }

          case .WHILE {
            emit(indent + "while ")
            emitExpression(node.whileTest(), .LOWEST)
            emitBlock(node.whileBlock())
            emit("\n")
          }

          default {
            assert false
          }
        }
      }

      void emitExpression(Node node, Precedence precedence) {
        switch (node.kind) {
          case .NULL {
            emit("null")
          }

          case .NAME {
            emit(node.symbol != null ? node.symbol.fullName() : node.asString())
          }

          case .DYNAMIC {
            emit("dynamic")
          }

          case .DOT {
            emitExpression(node.dotTarget(), .MEMBER)
            emit("." + (node.symbol != null ? node.symbol.name : node.asString()))
          }

          case .CONSTANT {
            var value = node.content
            switch (value.kind()) {
              case .BOOL { emit(value.asBool().toString()) }
              case .INT { emit(value.asInt().toString()) }
              case .DOUBLE { emit(value.asDouble().toString()) }
              case .STRING { emit(quoteString(value.asString(), '"')) }
            }
          }

          case .CALL {
            emitExpression(node.callValue(), .UNARY_POSTFIX)
            emit("(")
            for (var i = 1; i < node.children.size(); i++) {
              if (i > 1) {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }
            emit(")")
          }

          case .CAST {
            if (.COMPARE < precedence) emit("(")
            emitExpression(node.castValue(), .COMPARE)
            emit(" as ")
            emitExpression(node.castType(), .COMPARE)
            if (.COMPARE < precedence) emit(")")
          }

          case .HOOK {
            if (.ASSIGN < precedence) emit("(")
            emitExpression(node.hookTest(), .LOGICAL_OR)
            emit(" ? ")
            emitExpression(node.hookTrue(), .ASSIGN)
            emit(" : ")
            emitExpression(node.hookFalse(), .ASSIGN)
            if (.ASSIGN < precedence) emit(")")
          }

          case .LAMBDA {
            var symbol = (FunctionSymbol)node.symbol
            emit("(")
            emitArgumentList(symbol.arguments)
            emit(")")
            if (symbol.returnType != null) {
              emit(" ")
              emitExpression(symbol.returnType, .LOWEST)
            }
            emit(" =>")
            emitBlock(symbol.block)
          }

          case .LAMBDA_TYPE {
            emit("fn(")
            for (var i = 0; i + 1 < node.children.size(); i++) {
              if (i > 0) emit(", ")
              emitExpression(node.children[i], .LOWEST)
            }
            emit(")")
            var returnType = node.children[node.children.size() - 1]
            if (returnType != null) {
              emit(" ")
              emitExpression(returnType, .LOWEST)
            }
          }

          case .PARAMETERIZE {
            emitExpression(node.children[0], .UNARY_POSTFIX)
            emit("<")
            for (var i = 1; i < node.children.size(); i++) {
              if (i > 1) {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }
            emit(">")
          }

          case .INDEX {
            emitExpression(node.children[0], .UNARY_POSTFIX)
            emit("[")
            for (var i = 1; i < node.children.size(); i++) {
              if (i > 1) {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }
            emit("]")
          }

          case .ASSIGN_INDEX {
            var count = node.children.size()
            if (.ASSIGN < precedence) emit("(")
            emitExpression(node.children[0], .UNARY_POSTFIX)
            emit("[")
            for (var i = 1; i + 1 < count; i++) {
              if (i > 1) {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }
            emit("] = ")
            emitExpression(node.children[count - 1], .LOWEST)
            if (.ASSIGN < precedence) emit(")")
          }

          case .TYPE {
            emit(node.resolvedType.toString())
          }

          default {
            if (node.kind.isUnary()) {
              var value = node.unaryValue()
              var info = operatorInfo[node.kind]
              if (info.precedence < precedence) emit("(")
              emit(info.text)
              emitExpression(value, info.precedence)
              if (info.precedence < precedence) emit(")")
            }

            else if (node.kind.isBinary()) {
              var info = operatorInfo[node.kind]
              if (info.precedence < precedence) emit("(")
              emitExpression(node.binaryLeft(), info.precedence.incrementIfRightAssociative(info.associativity))
              emit(" " + info.text + " ")
              emitExpression(node.binaryRight(), info.precedence.incrementIfLeftAssociative(info.associativity))
              if (info.precedence < precedence) emit(")")
            }

            else {
              assert false
            }
          }
        }
      }
    }
  }
}
