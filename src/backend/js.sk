namespace Skew {
  class JsEmitter : Emitter {
    over visit(global ObjectSymbol) {
      patchTree(global)
      var objects = sortedObjects(global)

      # The entire body of code is wrapped in a closure for safety
      emit(indent + "(function() {\n")
      increaseIndent

      if needsExtends(objects) {
        emit(indent + "function $extends(derived, base) {\n")
        emit(indent + "  derived.prototype = Object.create(base.prototype);\n")
        emit(indent + "  derived.prototype.constructor = derived;\n")
        emit(indent + "}\n\n")
      }

      if needsMultiply {
        emit(indent + "var $imul = Math.imul || function(a, b) {\n")
        emit(indent + "  var ah = a >>> 16, al = a & 65535, bh = b >>> 16, bl = b & 65535;\n")
        emit(indent + "  return al * bl + (ah * bl + al * bh << 16) | 0;\n")
        emit(indent + "};\n\n")
      }

      # Emit objects and functions
      for object in objects {
        emitObject(object)
      }

      # Emit variables
      for object in objects {
        var o = object
        prefix = ""
        while o.kind != .OBJECT_GLOBAL {
          prefix = mangleName(o) + "." + prefix
          o = o.parent.asObjectSymbol
        }
        for variable in object.variables {
          emitVariable(variable)
        }
      }

      # Emit entry point
      var entryPointSymbol = cache.entryPointSymbol
      if entryPointSymbol != null {
        var type = entryPointSymbol.resolvedType
        var callText = fullName(entryPointSymbol) + (type.argumentTypes.isEmpty ? "()" : "(process.argv.slice(2))")
        emit("\n" + indent + (type.returnType == cache.intType ? "process.exit(" + callText + ")" : callText) + ";\n")
      }

      # End the closure wrapping everything
      decreaseIndent
      emit(indent + "}());\n")

      createSource(options.outputDirectory != "" ? options.outputDirectory + "/compiled.js" : options.outputFile)
    }

    @private {
      const options CompilerOptions
      const cache TypeCache
      var needsMultiply = false
      var previousSymbol Symbol = null
      var previousNode Node = null
      var prefix = ""

      def emitNewlineBeforeSymbol(symbol Symbol) {
        if previousSymbol != null &&
            (!previousSymbol.kind.isObject || !symbol.kind.isObject || symbol.comments != null || previousSymbol.kind == .OBJECT_ENUM || symbol.kind == .OBJECT_ENUM) &&
            (!previousSymbol.kind.isVariable || !symbol.kind.isVariable || symbol.comments != null) {
          emit("\n")
        }
        previousSymbol = null
      }

      def emitNewlineAfterSymbol(symbol Symbol) {
        previousSymbol = symbol
      }

      def isCompactNodeKind(kind NodeKind) bool {
        return kind == .EXPRESSION || kind == .VAR || kind.isJump
      }

      def emitNewlineBeforeStatement(node Node) {
        if previousNode != null && (node.comments != null || !isCompactNodeKind(previousNode.kind) || !isCompactNodeKind(node.kind)) {
          emit("\n")
        }
        previousNode = null
      }

      def emitNewlineAfterStatement(node Node) {
        previousNode = node
      }

      def emitComments(comments List<string>) {
        if comments != null {
          for comment in comments {
            emit(indent + "//" + comment)
          }
        }
      }

      def emitObject(symbol ObjectSymbol) {
        if symbol.isImported {
          return
        }

        prefix = symbol.parent != null ? computePrefix(symbol.parent.asObjectSymbol) : ""

        switch symbol.kind {
          case .OBJECT_NAMESPACE, .OBJECT_INTERFACE {
            emitNewlineBeforeSymbol(symbol)
            emitComments(symbol.comments)
            emit(indent + (prefix == "" && !symbol.isExported ? "var " : prefix) + mangleName(symbol) + " = {};\n")
            emitNewlineAfterSymbol(symbol)
          }

          case .OBJECT_ENUM {
            emitNewlineBeforeSymbol(symbol)
            emitComments(symbol.comments)
            emit(indent + (prefix == "" && !symbol.isExported ? "var " : prefix) + mangleName(symbol) + " = {")
            increaseIndent
            var isFirst = true
            for variable in symbol.variables {
              if variable.kind == .VARIABLE_ENUM {
                var value = variable.enumInfo.value.toString
                if isFirst { isFirst = false }
                else { emit(",") }
                emit("\n")
                emitNewlineBeforeSymbol(variable)
                emitComments(variable.comments)
                emit(indent + mangleName(variable) + ": " + value + ", " + value + ": " + quoteString(variable.enumInfo.text, '"'))
                emitNewlineAfterSymbol(variable)
              }
            }
            decreaseIndent
            if !isFirst { emit("\n" + indent) }
            emit("};\n")
            emitNewlineAfterSymbol(symbol)
          }

          case .OBJECT_CLASS {
            for function in symbol.functions {
              if function.kind == .FUNCTION_CONSTRUCTOR {
                if function.comments == null && symbol.comments != null {
                  function.comments = symbol.comments
                }
                emitFunction(function)
                if symbol.baseClass != null {
                  emit("\n" + indent + "$extends(" + fullName(symbol) + ", " + fullName(symbol.baseClass) + ");\n")
                }
              }
            }
          }
        }

        if symbol.kind != .OBJECT_GLOBAL {
          prefix += mangleName(symbol) + "."
        }

        for function in symbol.functions {
          if function.kind != .FUNCTION_CONSTRUCTOR {
            emitFunction(function)
          }
        }
      }

      def emitArgumentList(arguments List<VariableSymbol>) {
        for i in 0..arguments.count {
          if i > 0 {
            emit(", ")
          }
          emit(mangleName(arguments[i]))
        }
      }

      def emitFunction(symbol FunctionSymbol) {
        if symbol.block == null {
          return
        }

        emitNewlineBeforeSymbol(symbol)
        emitComments(symbol.comments)

        var isExpression = prefix != "" || symbol.isExported
        var name = mangleName(symbol.kind == .FUNCTION_CONSTRUCTOR ? symbol.parent : symbol)

        if isExpression {
          emit(indent + prefix + (symbol.kind == .FUNCTION_INSTANCE ? "prototype." : "") + name + " = function(")
        } else {
          emit(indent + "function " + name + "(")
        }

        emitArgumentList(symbol.arguments)
        emit(") {\n")
        increaseIndent

        if symbol.self != null {
          emit(indent + "var " + mangleName(symbol.self) + " = this;\n")
        }

        emitStatements(symbol.block.children)
        decreaseIndent
        emit(indent + "}" + (isExpression ? ";\n" : "\n"))
        emitNewlineAfterSymbol(symbol)
      }

      def emitVariable(symbol VariableSymbol) {
        if symbol.isImported {
          return
        }

        if symbol.kind != .VARIABLE_INSTANCE && (symbol.value != null || prefix == "" || symbol.kind == .VARIABLE_LOCAL) {
          emitNewlineBeforeSymbol(symbol)
          emitComments(symbol.comments)
          emit(indent + (prefix == "" && !symbol.isExported || symbol.kind == .VARIABLE_LOCAL ? "var " : prefix) + mangleName(symbol))

          if symbol.value != null {
            emit(" = ")
            emitExpression(symbol.value, .LOWEST)
          }

          emit(";\n")
          emitNewlineAfterSymbol(symbol)
        }
      }

      def emitStatements(statements List<Node>) {
        previousNode = null

        for statement in statements {
          emitNewlineBeforeStatement(statement)
          emitComments(statement.comments)
          emitStatement(statement)
          emitNewlineAfterStatement(statement)
        }

        previousNode = null
      }

      def emitBlock(node Node) {
        emit(" {\n")
        increaseIndent
        emitStatements(node.children)
        decreaseIndent
        emit(indent + "}")
      }

      def emitStatement(node Node) {
        switch node.kind {
          case .VAR {
            emitVariable(node.symbol.asVariableSymbol)
          }

          case .EXPRESSION {
            emit(indent)
            emitExpression(node.expressionValue, .LOWEST)
            emit(";\n")
          }

          case .BREAK {
            emit(indent + "break;\n")
          }

          case .CONTINUE {
            emit(indent + "continue;\n")
          }

          case .RETURN {
            emit(indent + "return")
            var value = node.returnValue
            if value != null {
              emit(" ")
              emitExpression(value, .LOWEST)
            }
            emit(";\n")
          }

          case .THROW {
            emit(indent + "throw ")
            emitExpression(node.throwValue, .LOWEST)
            emit(";\n")
          }

          case .FOR {
            var test = node.forTest
            var update = node.forUpdate
            var children = node.children
            var count = children.count
            emit(indent + "for (")
            if count > 3 {
              for i in 3..count {
                var child = children[i]
                if i != 3 {
                  emit(", ")
                }
                if child.kind == .VAR {
                  var symbol = child.symbol.asVariableSymbol
                  if i == 3 {
                    emit("var ")
                  }
                  emit(mangleName(symbol) + " = ")
                  emitExpression(symbol.value, .LOWEST)
                } else {
                  emitExpression(child, .LOWEST)
                }
              }
            }
            emit("; ")
            if test != null {
              emitExpression(test, .LOWEST)
            }
            emit("; ")
            if update != null {
              emitExpression(update, .LOWEST)
            }
            emit(")")
            emitBlock(node.forBlock)
            emit("\n")
          }

          case .FOREACH {
            emit(indent + "for (var " + mangleName(node.symbol) + " in ")
            emitExpression(node.foreachValue, .LOWEST)
            emit(")")
            emitBlock(node.foreachBlock)
            emit("\n")
          }

          case .IF {
            emit(indent)
            emitIf(node)
            emit("\n")
          }

          case .SWITCH {
            var cases = node.children
            emit(indent + "switch (")
            emitExpression(node.switchValue, .LOWEST)
            emit(") {\n")
            increaseIndent
            for i in 1..cases.count {
              var child = cases[i]
              var values = child.children
              var block = child.caseBlock
              if i != 1 {
                emit("\n")
              }
              if values.count == 1 {
                emit(indent + "default:")
              } else {
                for j in 1..values.count {
                  if j != 1 { emit("\n") }
                  emit(indent + "case ")
                  emitExpression(values[j], .LOWEST)
                  emit(":")
                }
              }
              emit(" {\n")
              increaseIndent
              emitStatements(block.children)
              if !block.blockAlwaysEndsWithReturn {
                emit(indent + "break;\n")
              }
              decreaseIndent
              emit(indent + "}\n")
            }
            decreaseIndent
            emit(indent + "}\n")
          }

          case .TRY {
            var children = node.children
            var finallyBlock = node.finallyBlock
            emit(indent + "try")
            emitBlock(node.tryBlock)
            emit("\n")
            for i in 1..children.count - 1 {
              var child = children[i]
              emit("\n")
              emitComments(child.comments)
              emit(indent + "catch (" + (child.symbol != null ? mangleName(child.symbol) : "$e") + ")")
              emitBlock(child.catchBlock)
              emit("\n")
            }
            if finallyBlock != null {
              emit("\n")
              emitComments(finallyBlock.comments)
              emit(indent + "finally")
              emitBlock(finallyBlock)
              emit("\n")
            }
          }

          case .WHILE {
            emit(indent + "while (")
            emitExpression(node.whileTest, .LOWEST)
            emit(")")
            emitBlock(node.whileBlock)
            emit("\n")
          }

          default {
            assert(false)
          }
        }
      }

      def emitIf(node Node) {
        emit("if (")
        emitExpression(node.ifTest, .LOWEST)
        emit(")")
        emitBlock(node.ifTrue)

        var block = node.ifFalse
        if block != null {
          var singleIf = block.children.count == 1 && block.children[0].kind == .IF ? block.children[0] : null
          emit("\n\n")
          emitComments(block.comments)
          if singleIf != null {
            emitComments(singleIf.comments)
          }
          emit(indent + "else")

          if singleIf != null {
            emit(" ")
            emitIf(singleIf)
          } else {
            emitBlock(block)
          }
        }
      }

      def emitContent(content Content) {
        switch content.kind {
          case .BOOL { emit(content.asBool.toString) }
          case .INT { emit(content.asInt.toString) }
          case .DOUBLE { emit(content.asDouble.toString) }
          case .STRING { emit(quoteString(content.asString, '"')) }
        }
      }

      def emitExpression(node Node, precedence Precedence) {
        switch node.kind {
          case .TYPE {
            emit(fullName(node.resolvedType.symbol))
          }

          case .NULL {
            emit("null")
          }

          case .NAME {
            var symbol = node.symbol
            emit(symbol != null ? symbol.kind == .VARIABLE_ENUM && options.enumFormat == .STRING ? quoteString(symbol.name, '"') : fullName(symbol) : node.asString)
          }

          case .DOT {
            emitExpression(node.dotTarget, .MEMBER)
            emit("." + (node.symbol != null ? mangleName(node.symbol) : node.asString))
          }

          case .CONSTANT {
            emitContent(node.content)
          }

          case .CALL {
            var value = node.callValue
            var call = value.kind == .SUPER
            var wrap = value.kind == .LAMBDA && node.parent != null && node.parent.kind == .EXPRESSION

            if wrap {
              emit("(")
            }

            if !call && node.symbol != null && node.symbol.kind == .FUNCTION_CONSTRUCTOR {
              emit("new " + fullName(node.symbol))
            } else {
              emitExpression(value, .UNARY_POSTFIX)
              if call {
                emit(".call")
              }
            }

            if wrap {
              emit(")")
            }

            emit("(")

            if call {
              emit(mangleName(node.symbol.asFunctionSymbol.self))
            }

            for i in 1..node.children.count {
              if call || i > 1 {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit(")")
          }

          case .INITIALIZER_LIST, .INITIALIZER_MAP, .INITIALIZER_SET {
            var useBraces = node.kind == .INITIALIZER_MAP || node.kind == .INITIALIZER_SET && node.children.isEmpty
            emit(useBraces ? "{" : "[")

            for i in 0..node.children.count {
              if i != 0 {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit(useBraces ? "}" : "]")
          }

          case .PAIR {
            emitExpression(node.firstValue, .LOWEST)
            emit(": ")
            emitExpression(node.secondValue, .LOWEST)
          }

          case .INDEX {
            emitExpression(node.children[0], .UNARY_POSTFIX)
            emit("[")

            for i in 1..node.children.count {
              if i > 1 {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit("]")
          }

          case .ASSIGN_INDEX {
            if Precedence.ASSIGN as int < precedence as int {
              emit("(")
            }

            emitExpression(node.children.first, .UNARY_POSTFIX)
            emit("[")

            for i in 1..node.children.count - 1 {
              if i > 1 {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit("] = ")
            emitExpression(node.children.last, .LOWEST)

            if Precedence.ASSIGN as int < precedence as int {
              emit(")")
            }
          }

          case .CAST {
            emitExpression(node.castValue, precedence)
          }

          case .PARAMETERIZE {
            emitExpression(node.parameterizeValue, precedence)
          }

          case .SUPER {
            emit(fullName(node.symbol))
          }

          case .HOOK {
            if Precedence.ASSIGN as int < precedence as int {
              emit("(")
            }
            emitExpression(node.hookTest, .LOGICAL_OR)
            emit(" ? ")
            emitExpression(node.hookTrue, .ASSIGN)
            emit(" : ")
            emitExpression(node.hookFalse, .ASSIGN)
            if Precedence.ASSIGN as int < precedence as int {
              emit(")")
            }
          }

          case .LAMBDA {
            var symbol = node.symbol.asFunctionSymbol
            emit("function(")
            emitArgumentList(symbol.arguments)
            emit(")")
            emitBlock(symbol.block)
          }

          default {
            if node.kind.isUnary {
              var value = node.unaryValue
              var info = operatorInfo[node.kind]
              if info.precedence as int < precedence as int {
                emit("(")
              }
              emit(info.text)
              emitExpression(value, info.precedence)
              if info.precedence as int < precedence as int {
                emit(")")
              }
            }

            else if node.kind.isBinary {
              var info = operatorInfo[node.kind]
              if info.precedence as int < precedence as int {
                emit("(")
              }
              emitExpression(node.binaryLeft, info.precedence.incrementIfRightAssociative(info.associativity))
              emit(node.kind == .EQUAL ? " === " : node.kind == .NOT_EQUAL ? " !== " : " " + info.text + " ")
              emitExpression(node.binaryRight, info.precedence.incrementIfLeftAssociative(info.associativity))
              if info.precedence as int < precedence as int {
                emit(")")
              }
            }

            else {
              assert(false)
            }
          }
        }
      }

      def patchTree(symbol ObjectSymbol) {
        for object in symbol.objects {
          patchTree(object)
        }

        for function in symbol.functions {
          patchTree(function.block)
        }

        for variable in symbol.variables {
          patchTree(variable.value)
        }
      }

      def createIntBinary(kind NodeKind, left Node, right Node) Node {
        if kind == .MULTIPLY {
          needsMultiply = true
          return Node.createCall(Node.createName("$imul"), [left, right]).withType(cache.intType)
        }
        return wrapWithIntCast(Node.createBinary(kind, left, right).withType(cache.intType))
      }

      def wrapWithNot(node Node) Node {
        return Node.createUnary(.NOT, node).withType(cache.boolType).withRange(node.range)
      }

      def wrapWithIntCast(node Node) Node {
        return Node.createBinary(.BITWISE_OR, node, Node.createInt(0).withType(cache.intType)).withType(cache.intType).withRange(node.range)
      }

      def wrapWithTypeIndex(node Node, index Type, type Type) Node {
        return Node.createIndex(Node.createType(index), [node]).withType(type).withRange(node.range)
      }

      def patchBinaryArithmetic(node Node) {
        # Make sure arithmetic integer operators don't emit doubles outside the
        # integer range. Allowing this causes JIT slowdowns due to extra checks
        # during compilation and potential deoptimizations during execution.
        if node.resolvedType == cache.intType && !alwaysConvertsOperandsToInt(node.parent) {
          var left = node.binaryLeft
          var right = node.binaryRight
          if left.resolvedType == cache.intType && right.resolvedType == cache.intType {
            node.become(createIntBinary(node.kind, left.replaceWithNull, right.replaceWithNull).withRange(node.range))
          }
        }
      }

      def patchTree(node Node) {
        if node == null {
          return
        }

        var children = node.children
        var kind = node.kind

        if children != null {
          for child in children {
            patchTree(child)
          }
        }

        switch kind {
          case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE, .REMAINDER { patchBinaryArithmetic(node) }
          case .CAST { patchCast(node) }
        }
      }

      def patchCast(node Node) {
        var value = node.castValue
        var type = node.resolvedType
        var valueType = value.resolvedType

        # Cast to bool
        if type == cache.boolType {
          if valueType != cache.boolType {
            node.become(wrapWithNot(wrapWithNot(value.replaceWithNull)))
          }
        }

        # Cast to int
        else if type == cache.intType {
          # Cast from enum to int, only needed if the enum is represented as a string
          if valueType.isEnum {
            if options.enumFormat == .STRING {
              node.become(wrapWithTypeIndex(value.replaceWithNull, valueType, type))
            }
          }

          # Non-enum cast to int
          else if valueType != cache.intType && !alwaysConvertsOperandsToInt(node.parent) {
            node.become(wrapWithIntCast(value.replaceWithNull))
          }
        }

        # Cast to double
        else if type == cache.doubleType {
          if !cache.isNumeric(valueType) {
            node.become(Node.createUnary(.POSITIVE, value.replaceWithNull).withRange(node.range).withType(cache.doubleType))
          }
        }

        # Cast to string
        else if type == cache.stringType {
          # Cast from enum to string, only needed if the enum is represented as an int
          if valueType.isEnum {
            if options.enumFormat == .INT {
              node.become(wrapWithTypeIndex(value.replaceWithNull, valueType, type))
            }
          }

          # Non-enum cast to string
          else if valueType != cache.stringType {
            node.become(Node.createBinary(.ADD, value.replaceWithNull, Node.createString("").withType(cache.stringType)).withType(cache.stringType).withRange(node.range))
          }
        }

        # Cast to enum
        else if type.isEnum {
          # Cast from int or string to enum, only needed if the format is the other one
          if valueType == cache.intType && options.enumFormat == .STRING || valueType == cache.stringType && options.enumFormat == .INT {
            node.become(wrapWithTypeIndex(value.replaceWithNull, type, type))
          }
        }
      }
    }
  }

  namespace JsEmitter {
    @private {
      def fullName(symbol Symbol) string {
        var parent = symbol.parent
        if parent != null && parent.kind != .OBJECT_GLOBAL {
          var enclosingName = fullName(parent)
          if symbol.kind == .FUNCTION_CONSTRUCTOR {
            return enclosingName
          }
          if symbol.kind == .FUNCTION_INSTANCE {
            enclosingName += ".prototype"
          }
          return enclosingName + "." + mangleName(symbol)
        }
        return mangleName(symbol)
      }

      def mangleName(symbol Symbol) string {
        if symbol.kind == .FUNCTION_CONSTRUCTOR {
          symbol = symbol.parent
        }
        if !symbol.isImportedOrExported && symbol.name in isKeyword {
          return "$" + symbol.name
        }
        return symbol.nameWithRenaming
      }

      const isKeyword = {
        "apply": 0,
        "arguments": 0,
        "Boolean": 0,
        "break": 0,
        "call": 0,
        "case": 0,
        "catch": 0,
        "class": 0,
        "const": 0,
        "constructor": 0,
        "continue": 0,
        "Date": 0,
        "debugger": 0,
        "default": 0,
        "delete": 0,
        "do": 0,
        "double": 0,
        "else": 0,
        "export": 0,
        "extends": 0,
        "false": 0,
        "finally": 0,
        "float": 0,
        "for": 0,
        "Function": 0,
        "function": 0,
        "if": 0,
        "import": 0,
        "in": 0,
        "instanceof": 0,
        "int": 0,
        "let": 0,
        "new": 0,
        "null": 0,
        "Number": 0,
        "Object": 0,
        "return": 0,
        "String": 0,
        "super": 0,
        "this": 0,
        "throw": 0,
        "true": 0,
        "try": 0,
        "var": 0,
      }

      def needsExtends(objects List<ObjectSymbol>) bool {
        for object in objects {
          if !object.isImported && object.baseClass != null {
            return true
          }
        }
        return false
      }

      def computePrefix(symbol ObjectSymbol) string {
        assert(symbol.kind.isObject)
        return symbol.kind == .OBJECT_GLOBAL ? "" : computePrefix(symbol.parent.asObjectSymbol) + mangleName(symbol) + "."
      }

      def alwaysConvertsOperandsToInt(node Node) bool {
        if node != null {
          switch node.kind {
            case
              .ASSIGN_BITWISE_AND, .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_XOR,
              .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT, .BITWISE_AND, .BITWISE_OR,
              .BITWISE_XOR, .COMPLEMENT, .SHIFT_LEFT, .SHIFT_RIGHT {
              return true
            }
          }
        }
        return false
      }
    }
  }
}
