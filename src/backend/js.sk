namespace Skew {
  enum ExtractGroupsMode {
    ALL_SYMBOLS
    ONLY_LOCAL_VARIABLES
    ONLY_INSTANCE_VARIABLES
  }

  class SymbolGroup {
    const symbols List<Symbol>
    const count int
  }

  class JsEmitter : Emitter {
    over visit(global ObjectSymbol) {
      # Shorten the library function names while still avoiding needing to
      # do conflict detection with user-defined symbol names
      mangle = options.jsMangle
      if mangle {
        extends = "$e"
        imul = "$i"
      }

      minify = options.jsMinify
      if minify {
        indentAmount = ""
        newline = ""
        space = ""
      }

      # Preprocess the code
      patchObject(global)
      if mangle {
        renameSymbols
      }
      var objects = sortedObjects(global)

      # The entire body of code is wrapped in a closure for safety
      emit(indent + "(function()" + space + "{" + newline)
      increaseIndent

      if needsExtends(objects) {
        var derived = mangle ? "d" : "derived"
        var base = mangle ? "b" : "base"
        emit(indent + "function " + extends + minifySpace("(" + derived + ", " + base + ") {") + newline)
        emit(indent + minifySpace("  " + derived + ".prototype = Object.create(" + base + ".prototype);") + newline)
        emit(indent + minifySpace("  " + derived + ".prototype.constructor = " + derived + ";") + newline)
        emit(indent + minifySpace("}") + newline + newline)
      }

      if needsMultiply {
        emit(indent + "var " + imul + minifySpace(" = Math.imul || function(a, b) {") + newline)
        emit(indent + indentAmount + "var " + minifySpace("ah = a >>> 16, al = a & 65535, bh = b >>> 16, bl = b & 65535;") + newline)
        emit(indent + indentAmount + "return " + minifySpace("al * bl + (ah * bl + al * bh << 16) | 0;") + newline)
        emit(indent + minifySpace("};") + newline + newline)
      }

      # Emit objects and functions
      for object in objects {
        emitObject(object)
      }

      # Emit variables
      for object in objects {
        var o = object
        prefix = ""
        while o.kind != .OBJECT_GLOBAL {
          prefix = mangleName(o) + "." + prefix
          o = o.parent.asObjectSymbol
        }
        for variable in object.variables {
          emitVariable(variable)
        }
      }

      # Emit entry point
      var entryPointSymbol = cache.entryPointSymbol
      if entryPointSymbol != null {
        var type = entryPointSymbol.resolvedType
        var callText = fullName(entryPointSymbol) + (type.argumentTypes.isEmpty ? "()" : "(process.argv.slice(2))")
        emitSemicolonIfNeeded
        emit(newline + indent + (type.returnType == cache.intType ? "process.exit(" + callText + ")" : callText))
        emitSemicolonAfterStatement
      }

      # End the closure wrapping everything
      decreaseIndent
      emit(indent + "})();\n")

      createSource(options.outputDirectory != "" ? options.outputDirectory + "/compiled.js" : options.outputFile)
    }

    @private {
      enum AfterToken {
        AFTER_KEYWORD
        AFTER_PARENTHESIS
      }

      enum BracesMode {
        MUST_KEEP_BRACES
        CAN_OMIT_BRACES
      }

      const options CompilerOptions
      const cache TypeCache
      var needsMultiply = false
      var prefix = ""
      var previousNode Node = null
      var previousSymbol Symbol = null
      var enclosingFunction FunctionSymbol = null # This includes lambdas during patching but not during emission

      # A union-find data structure is used to quickly merge symbols into
      # groups. All local variables inside a function are merged with that
      # function. The map create a quick way of getting from a symbol to its
      # union/find index.
      var allSymbols List<Symbol> = []
      var extends = "$extends"
      var imul = "$imul"
      var localVariableUnionFind UnionFind = UnionFind.new
      var namingGroupIndexForSymbol IntMap<int> = {}
      var nextSymbolName = 0
      var symbolCounts IntMap<int> = {}

      # For minification
      var mangle = false
      var minify = false
      var needsSemicolon = false
      var newline = "\n"
      var space = " "

      def allocateNamingGroupIndex(symbol Symbol) {
        if mangle && !(symbol.id in namingGroupIndexForSymbol) {
          var index = localVariableUnionFind.allocate
          namingGroupIndexForSymbol[symbol.id] = index
          allSymbols.append(symbol)

          # Explicitly add function arguments since they won't be reached by
          # normal tree traversal
          if symbol.kind.isFunction {
            var context = symbol.asFunctionSymbol.self
            if context != null {
              allocateNamingGroupIndex(context)
            }
            for argument in symbol.asFunctionSymbol.arguments {
              allocateNamingGroupIndex(argument)
            }
          }
        }
      }

      def renameSymbols {
        # This holds the groups used for naming. Unioning two labels using
        # this object will cause both groups of symbols to have the same name.
        var namingGroupsUnionFind = UnionFind.new.allocate(allSymbols.count)

        # These are optional and only reduce the number of generated names
        var order List<int> = []
        aliasLocalVariables(namingGroupsUnionFind, order)
        aliasUnrelatedProperties(namingGroupsUnionFind, order)

        # Ensure all overridden symbols have the same generated name. This is
        # manditory for correctness, otherwise virtual functions break.
        for symbol in allSymbols {
          if symbol.kind.isFunction && symbol.asFunctionSymbol.overridden != null {
            assert(symbol.id in namingGroupIndexForSymbol)
            assert(symbol.asFunctionSymbol.overridden.id in namingGroupIndexForSymbol)
            namingGroupsUnionFind.union(namingGroupIndexForSymbol[symbol.id], namingGroupIndexForSymbol[symbol.asFunctionSymbol.overridden.id])
          }
        }

        # Collect all reserved names together into one big set for querying
        var reservedNames StringMap<int> = {}
        for symbol in allSymbols {
          if symbol.isImportedOrExported {
            reservedNames[symbol.name] = 0
          }
        }

        # Everything that should have the same name is now grouped together.
        # Generate and assign names to all internal symbols, but use shorter
        # names for more frequently used symbols.
        var sortedGroups List<SymbolGroup> = []
        for group in extractGroups(namingGroupsUnionFind, .ALL_SYMBOLS) {
          var count = 0
          for symbol in group {
            if !symbol.isImportedOrExported {
              count += symbolCounts.get(symbol.id, 0)
            }
          }
          sortedGroups.append(SymbolGroup.new(group, count))
        }
        sortedGroups.sort((a, b) => b.count - a.count)
        for group in sortedGroups {
          var name = ""
          for symbol in group.symbols {
            if !symbol.isImportedOrExported {
              if name == "" {
                name = generateSymbolName(reservedNames)
              }
              symbol.name = name
            }
          }
        }
      }

      # Merge local variables from different functions together in the order
      # they were declared. This will cause every argument list to use the same
      # variables in the same order, which should offer better gzip:
      #
      #   function d(a, b) {}
      #   function e(a, b, c) {}
      #
      def aliasLocalVariables(unionFind UnionFind, order List<int>) {
        zipTogetherInOrder(unionFind, order, extractGroups(localVariableUnionFind, .ONLY_LOCAL_VARIABLES))
      }

      # Merge all related types together into naming groups. This ensures names
      # will be unique within a subclass hierarchy allowing names to be
      # duplicated in separate subclass hierarchies.
      def aliasUnrelatedProperties(unionFind UnionFind, order List<int>) {
        var relatedTypesUnionFind = UnionFind.new.allocate(allSymbols.count)
        for i in 0..allSymbols.count {
          var symbol = allSymbols[i]
          if symbol.kind == .OBJECT_CLASS {
            var baseClass = symbol.asObjectSymbol.baseClass
            if baseClass != null {
              relatedTypesUnionFind.union(i, namingGroupIndexForSymbol[baseClass.id])
            }
            for variable in symbol.asObjectSymbol.variables {
              relatedTypesUnionFind.union(i, namingGroupIndexForSymbol[variable.id])
            }
          }
        }
        zipTogetherInOrder(unionFind, order, extractGroups(relatedTypesUnionFind, .ONLY_INSTANCE_VARIABLES))
      }

      def zipTogetherInOrder(unionFind UnionFind, order List<int>, groups List<List<Symbol>>) {
        for group in groups {
          for i in 0..group.count {
            var symbol = group[i]
            var index = namingGroupIndexForSymbol[symbol.id]
            if i >= order.count {
              order.append(index)
            } else {
              unionFind.union(index, order[i])
            }
          }
        }
      }

      def numberToName(number int) string {
        const WRAP = 26 * 2
        var name = ""
        if number >= WRAP {
          name = numberToName(number / WRAP - 1)
          number = number % WRAP
        }
        name += string.fromCodeUnit(number + (number < 26 ? 'a' : 'A' - 26))
        return name
      }

      def generateSymbolName(reservedNames StringMap<int>) string {
        while true {
          var name = numberToName(nextSymbolName)
          nextSymbolName++
          if !(name in reservedNames) {
            return name
          }
        }
      }

      def extractGroups(unionFind UnionFind, mode ExtractGroupsMode) List<List<Symbol>> {
        var labelToGroup IntMap<List<Symbol>> = {}
        for symbol in allSymbols {
          if mode == .ONLY_LOCAL_VARIABLES && symbol.kind != .VARIABLE_LOCAL ||
              mode == .ONLY_INSTANCE_VARIABLES && symbol.kind != .VARIABLE_INSTANCE {
            continue
          }
          assert(symbol.id in namingGroupIndexForSymbol)
          var label = unionFind.find(namingGroupIndexForSymbol[symbol.id])
          var group = labelToGroup.get(label, null)
          if group == null {
            group = []
            labelToGroup[label] = group
          }
          group.append(symbol)
        }
        return labelToGroup.values
      }

      def minifySpace(text string) string {
        return minify ? text.replaceAll(" ", "") : text
      }

      def emitSemicolonAfterStatement {
        if !minify {
          emit(";\n")
        } else {
          needsSemicolon = true
        }
      }

      def emitSemicolonIfNeeded {
        if needsSemicolon {
          emit(";")
          needsSemicolon = false
        }
      }

      def emitNewlineBeforeSymbol(symbol Symbol) {
        emitSemicolonIfNeeded
        if !minify && previousSymbol != null &&
            (!previousSymbol.kind.isObject || !symbol.kind.isObject || symbol.comments != null || previousSymbol.kind == .OBJECT_ENUM || symbol.kind == .OBJECT_ENUM) &&
            (!previousSymbol.kind.isVariable || !symbol.kind.isVariable || symbol.comments != null) {
          emit("\n")
        }
        previousSymbol = null
      }

      def emitNewlineAfterSymbol(symbol Symbol) {
        previousSymbol = symbol
      }

      def isCompactNodeKind(kind NodeKind) bool {
        return kind == .EXPRESSION || kind == .VAR || kind.isJump
      }

      def emitNewlineBeforeStatement(node Node) {
        if !minify && previousNode != null && (node.comments != null || !isCompactNodeKind(previousNode.kind) || !isCompactNodeKind(node.kind)) {
          emit("\n")
        }
        previousNode = null
      }

      def emitNewlineAfterStatement(node Node) {
        previousNode = node
      }

      def emitComments(comments List<string>) {
        if comments != null && !minify {
          for comment in comments {
            emit(indent + "//" + comment)
          }
        }
      }

      def emitObject(symbol ObjectSymbol) {
        if symbol.isImported {
          return
        }

        prefix = symbol.parent != null ? computePrefix(symbol.parent.asObjectSymbol) : ""

        switch symbol.kind {
          case .OBJECT_NAMESPACE, .OBJECT_INTERFACE {
            emitNewlineBeforeSymbol(symbol)
            emitComments(symbol.comments)
            emit(indent + (prefix == "" && !symbol.isExported ? "var " : prefix) + mangleName(symbol) + space + "=" + space + "{}")
            emitSemicolonAfterStatement
            emitNewlineAfterSymbol(symbol)
          }

          case .OBJECT_ENUM {
            emitNewlineBeforeSymbol(symbol)
            emitComments(symbol.comments)
            emit(indent + (prefix == "" && !symbol.isExported ? "var " : prefix) + mangleName(symbol) + space + "=" + space + "{")
            increaseIndent
            var isFirst = true
            for variable in symbol.variables {
              if variable.kind == .VARIABLE_ENUM {
                var value = variable.enumInfo.value.toString
                if isFirst {
                  isFirst = false
                } else {
                  emit(",")
                }
                emit(newline)
                emitNewlineBeforeSymbol(variable)
                emitComments(variable.comments)
                emit(indent + mangleName(variable) + ":" + space + value + "," + space + value + ":" + space + quoteString(variable.enumInfo.text, '"'))
                emitNewlineAfterSymbol(variable)
              }
            }
            decreaseIndent
            if !isFirst && !minify {
              emit("\n" + indent)
            }
            emit("}")
            emitSemicolonAfterStatement
            emitNewlineAfterSymbol(symbol)
          }

          case .OBJECT_CLASS {
            for function in symbol.functions {
              if function.kind == .FUNCTION_CONSTRUCTOR {
                if function.comments == null && symbol.comments != null {
                  function.comments = symbol.comments
                }
                emitFunction(function)
                if symbol.baseClass != null {
                  if !minify {
                    emit("\n" + indent)
                  }
                  emitSemicolonIfNeeded
                  emit(extends + "(" + fullName(symbol) + "," + space + fullName(symbol.baseClass) + ")")
                  emitSemicolonAfterStatement
                }
              }
            }
          }
        }

        if symbol.kind != .OBJECT_GLOBAL {
          prefix += mangleName(symbol) + "."
        }

        for function in symbol.functions {
          if function.kind != .FUNCTION_CONSTRUCTOR {
            emitFunction(function)
          }
        }
      }

      def emitArgumentList(arguments List<VariableSymbol>) {
        for i in 0..arguments.count {
          if i > 0 {
            emit("," + space)
          }
          emit(mangleName(arguments[i]))
        }
      }

      def emitFunction(symbol FunctionSymbol) {
        if symbol.block == null {
          return
        }

        emitNewlineBeforeSymbol(symbol)
        emitComments(symbol.comments)

        var isExpression = prefix != "" || symbol.isExported
        var name = mangleName(symbol.kind == .FUNCTION_CONSTRUCTOR ? symbol.parent : symbol)

        if isExpression {
          emit(indent + prefix + (symbol.kind == .FUNCTION_INSTANCE ? "prototype." : "") + name + space + "=" + space + "function(")
        } else {
          emit(indent + "function " + name + "(")
        }

        emitArgumentList(symbol.arguments)
        emit(")" + space + "{" + newline)
        increaseIndent

        if symbol.self != null {
          emit(indent + "var " + mangleName(symbol.self) + space + "=" + space + "this")
          emitSemicolonAfterStatement
        }

        enclosingFunction = symbol
        emitStatements(symbol.block.children)
        enclosingFunction = null
        decreaseIndent
        emit(indent + "}")
        if isExpression {
          emitSemicolonAfterStatement
        } else {
          needsSemicolon = false
          emit(newline)
        }
        emitNewlineAfterSymbol(symbol)
      }

      def emitVariable(symbol VariableSymbol) {
        if symbol.isImported {
          return
        }

        if symbol.kind != .VARIABLE_INSTANCE && (symbol.value != null || prefix == "" || symbol.kind == .VARIABLE_LOCAL) {
          emitNewlineBeforeSymbol(symbol)
          emitComments(symbol.comments)
          emit(indent + (prefix == "" && !symbol.isExported || symbol.kind == .VARIABLE_LOCAL ? "var " : prefix) + mangleName(symbol))

          if symbol.value != null {
            emit(space + "=" + space)
            emitExpression(symbol.value, .LOWEST)
          }

          emitSemicolonAfterStatement
          emitNewlineAfterSymbol(symbol)
        }
      }

      def emitStatements(statements List<Node>) {
        previousNode = null

        for statement in statements {
          emitSemicolonIfNeeded
          emitNewlineBeforeStatement(statement)
          emitComments(statement.comments)
          emitStatement(statement)
          emitNewlineAfterStatement(statement)
        }

        previousNode = null
      }

      def emitBlock(node Node, after AfterToken, mode BracesMode) {
        var shouldMinify = mode == .CAN_OMIT_BRACES && minify
        if shouldMinify && !node.hasChildren {
          emit(";")
        } else if shouldMinify && node.children.count == 1 {
          if after == .AFTER_KEYWORD {
            emit(" ")
          }
          emitStatement(node.children.first)
        } else {
          emit(space + "{" + newline)
          if node.hasChildren {
            increaseIndent
            emitStatements(node.children)
            decreaseIndent
          }
          emit(indent + "}")
          needsSemicolon = false
        }
      }

      def emitStatement(node Node) {
        switch node.kind {
          case .VAR {
            emitVariable(node.symbol.asVariableSymbol)
          }

          case .EXPRESSION {
            emit(indent)
            emitExpression(node.expressionValue, .LOWEST)
            emitSemicolonAfterStatement
          }

          case .BREAK {
            emit(indent + "break")
            emitSemicolonAfterStatement
          }

          case .CONTINUE {
            emit(indent + "continue")
            emitSemicolonAfterStatement
          }

          case .RETURN {
            emit(indent + "return")
            var value = node.returnValue
            if value != null {
              emit(" ")
              emitExpression(value, .LOWEST)
            }
            emitSemicolonAfterStatement
          }

          case .THROW {
            emit(indent + "throw ")
            emitExpression(node.throwValue, .LOWEST)
            emitSemicolonAfterStatement
          }

          case .FOR {
            var test = node.forTest
            var update = node.forUpdate
            var children = node.children
            var count = children.count
            emit(indent + "for" + space + "(")
            if count > 3 {
              for i in 3..count {
                var child = children[i]
                if i != 3 {
                  emit("," + space)
                }
                if child.kind == .VAR {
                  var symbol = child.symbol.asVariableSymbol
                  if i == 3 {
                    emit("var ")
                  }
                  emit(mangleName(symbol) + space + "=" + space)
                  emitExpression(symbol.value, .LOWEST)
                } else {
                  emitExpression(child, .LOWEST)
                }
              }
            }
            emit(";" + space)
            if test != null {
              emitExpression(test, .LOWEST)
            }
            emit(";" + space)
            if update != null {
              emitExpression(update, .LOWEST)
            }
            emit(")")
            emitBlock(node.forBlock, .AFTER_PARENTHESIS, .MUST_KEEP_BRACES)
            emit(newline)
          }

          case .FOREACH {
            emit(indent + "for" + space + "(var " + mangleName(node.symbol) + " in ")
            emitExpression(node.foreachValue, .LOWEST)
            emit(")")
            emitBlock(node.foreachBlock, .AFTER_PARENTHESIS, .MUST_KEEP_BRACES)
            emit(newline)
          }

          case .IF {
            emit(indent)
            emitIf(node)
            emit(newline)
          }

          case .SWITCH {
            var cases = node.children
            emit(indent + "switch" + space + "(")
            emitExpression(node.switchValue, .LOWEST)
            emit(")" + space + "{" + newline)
            increaseIndent
            for i in 1..cases.count {
              var child = cases[i]
              var values = child.children
              var block = child.caseBlock
              emitSemicolonIfNeeded
              if i != 1 {
                emit(newline)
              }
              if values.count == 1 {
                emit(indent + "default:")
              } else {
                for j in 1..values.count {
                  if j != 1 {
                    emit(newline)
                  }
                  emit(indent + "case ")
                  emitExpression(values[j], .LOWEST)
                  emit(":")
                }
              }
              if !minify {
                emit(" {\n")
                increaseIndent
              }
              emitStatements(block.children)
              if !block.blockAlwaysEndsWithReturn {
                emitSemicolonIfNeeded
                emit(indent + "break")
                emitSemicolonAfterStatement
              }
              if !minify {
                decreaseIndent
                emit(indent + "}\n")
              }
            }
            decreaseIndent
            emit(indent + "}" + newline)
            needsSemicolon = false
          }

          case .TRY {
            var children = node.children
            var finallyBlock = node.finallyBlock
            emit(indent + "try")
            emitBlock(node.tryBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
            emit(newline)
            for i in 1..children.count - 1 {
              var child = children[i]
              emit(newline)
              emitComments(child.comments)
              emit(indent + "catch" + space + "(" + (child.symbol != null ? mangleName(child.symbol) : "$e") + ")")
              emitBlock(child.catchBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
              emit(newline)
            }
            if finallyBlock != null {
              emit(newline)
              emitComments(finallyBlock.comments)
              emit(indent + "finally")
              emitBlock(finallyBlock, .AFTER_KEYWORD, .MUST_KEEP_BRACES)
              emit(newline)
            }
          }

          case .WHILE {
            emit(indent + "while" + space + "(")
            emitExpression(node.whileTest, .LOWEST)
            emit(")")
            emitBlock(node.whileBlock, .AFTER_PARENTHESIS, .CAN_OMIT_BRACES)
            emit(newline)
          }

          default {
            assert(false)
          }
        }
      }

      def emitIf(node Node) {
        var trueBlock = node.ifTrue
        var falseBlock = node.ifFalse
        emit("if" + space + "(")
        emitExpression(node.ifTest, .LOWEST)
        emit(")")

        # Make sure to always keep braces to avoid the dangling "else" case
        var trueStatement = trueBlock.blockStatement
        emitBlock(node.ifTrue, .AFTER_PARENTHESIS, falseBlock != null && trueStatement != null && trueStatement.kind == .IF ? .MUST_KEEP_BRACES : .CAN_OMIT_BRACES)

        if falseBlock != null {
          var falseStatement = falseBlock.blockStatement
          var singleIf = falseStatement != null && falseStatement.kind == .IF ? falseStatement : null
          emitSemicolonIfNeeded
          emit(newline + newline)
          emitComments(falseBlock.comments)
          if singleIf != null {
            emitComments(singleIf.comments)
          }
          emit(indent + "else")

          if singleIf != null {
            emit(" ")
            emitIf(singleIf)
          } else {
            emitBlock(falseBlock, .AFTER_KEYWORD, .CAN_OMIT_BRACES)
          }
        }
      }

      def emitContent(content Content) {
        switch content.kind {
          case .BOOL { emit(content.asBool.toString) }
          case .INT { emit(content.asInt.toString) }
          case .DOUBLE { emit(content.asDouble.toString) }
          case .STRING { emit(quoteString(content.asString, '"')) }
        }
      }

      def emitExpression(node Node, precedence Precedence) {
        var kind = node.kind
        switch kind {
          case .TYPE {
            emit(fullName(node.resolvedType.symbol))
          }

          case .NULL {
            emit("null")
          }

          case .NAME {
            var symbol = node.symbol
            emit(symbol != null ? symbol.kind == .VARIABLE_ENUM && options.enumFormat == .STRING ? quoteString(symbol.name, '"') : fullName(symbol) : node.asString)
          }

          case .DOT {
            emitExpression(node.dotTarget, .MEMBER)
            emit("." + (node.symbol != null ? mangleName(node.symbol) : node.asString))
          }

          case .CONSTANT {
            emitContent(node.content)
          }

          case .CALL {
            var value = node.callValue
            var call = value.kind == .SUPER
            var wrap = value.kind == .LAMBDA && node.parent != null && node.parent.kind == .EXPRESSION

            if wrap {
              emit("(")
            }

            if !call && node.symbol != null && node.symbol.kind == .FUNCTION_CONSTRUCTOR {
              emit("new " + fullName(node.symbol))
            } else {
              emitExpression(value, .UNARY_POSTFIX)
              if call {
                emit(".call")
              }
            }

            if wrap {
              emit(")")
            }

            emit("(")

            if call {
              emit(mangleName(enclosingFunction.self))
            }

            for i in 1..node.children.count {
              if call || i > 1 {
                emit("," + space)
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit(")")
          }

          case .INITIALIZER_LIST, .INITIALIZER_MAP, .INITIALIZER_SET {
            var useBraces = kind == .INITIALIZER_MAP || kind == .INITIALIZER_SET && node.children.isEmpty
            emit(useBraces ? "{" : "[")

            for i in 0..node.children.count {
              if i != 0 {
                emit("," + space)
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit(useBraces ? "}" : "]")
          }

          case .PAIR {
            emitExpression(node.firstValue, .LOWEST)
            emit(":" + space)
            emitExpression(node.secondValue, .LOWEST)
          }

          case .INDEX {
            emitExpression(node.children[0], .UNARY_POSTFIX)
            emit("[")

            for i in 1..node.children.count {
              if i > 1 {
                emit("," + space)
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit("]")
          }

          case .ASSIGN_INDEX {
            if Precedence.ASSIGN as int < precedence as int {
              emit("(")
            }

            emitExpression(node.children.first, .UNARY_POSTFIX)
            emit("[")

            for i in 1..node.children.count - 1 {
              if i > 1 {
                emit("," + space)
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit("]" + space + "=" + space + "")
            emitExpression(node.children.last, .LOWEST)

            if Precedence.ASSIGN as int < precedence as int {
              emit(")")
            }
          }

          case .CAST {
            emitExpression(node.castValue, precedence)
          }

          case .PARAMETERIZE {
            emitExpression(node.parameterizeValue, precedence)
          }

          case .SUPER {
            emit(fullName(node.symbol))
          }

          case .HOOK {
            if Precedence.ASSIGN as int < precedence as int {
              emit("(")
            }
            emitExpression(node.hookTest, .LOGICAL_OR)
            emit(space + "?" + space)
            emitExpression(node.hookTrue, .ASSIGN)
            emit(space + ":" + space)
            emitExpression(node.hookFalse, .ASSIGN)
            if Precedence.ASSIGN as int < precedence as int {
              emit(")")
            }
          }

          case .LAMBDA {
            var symbol = node.symbol.asFunctionSymbol
            emit("function(")
            emitArgumentList(symbol.arguments)
            emit(")")
            emitBlock(symbol.block, .AFTER_PARENTHESIS, .MUST_KEEP_BRACES)
          }

          default {
            if kind.isUnary {
              var value = node.unaryValue
              var info = operatorInfo[kind]
              if info.precedence as int < precedence as int {
                emit("(")
              }
              emit(info.text)
              emitExpression(value, info.precedence)
              if info.precedence as int < precedence as int {
                emit(")")
              }
            }

            else if kind.isBinary {
              var info = operatorInfo[kind]
              var right = node.binaryRight

              if info.precedence as int < precedence as int {
                emit("(")
              }
              emitExpression(node.binaryLeft, info.precedence.incrementIfRightAssociative(info.associativity))

              # Always emit spaces around keyword operators, even when minifying
              emit(kind == .IN ? " in " : kind == .IS ? " instanceof " : space + (kind == .EQUAL ? "===" : kind == .NOT_EQUAL ? "!==" : info.text) + space)

              # Prevent "x - -1" from becoming "x--1"
              if minify && (
                  kind == .ADD && (right.kind == .POSITIVE || right.kind == .INCREMENT) ||
                  kind == .SUBTRACT && (right.kind == .NEGATIVE || right.kind == .DECREMENT || right.isNumberLessThanZero)) {
                emit(" ")
              }

              emitExpression(right, info.precedence.incrementIfLeftAssociative(info.associativity))
              if info.precedence as int < precedence as int {
                emit(")")
              }
            }

            else {
              assert(false)
            }
          }
        }
      }

      def patchObject(symbol ObjectSymbol) {
        allocateNamingGroupIndex(symbol)

        for object in symbol.objects {
          patchObject(object)
        }

        for function in symbol.functions {
          allocateNamingGroupIndex(function)
          enclosingFunction = function
          patchNode(function.block)
          enclosingFunction = null
          for argument in function.arguments {
            allocateNamingGroupIndex(argument)
            unionVariableWithFunction(argument, function)
          }
          if function.self != null {
            unionVariableWithFunction(function.self, function)
          }
        }

        for variable in symbol.variables {
          allocateNamingGroupIndex(variable)
          patchNode(variable.value)
        }
      }

      def createIntBinary(kind NodeKind, left Node, right Node) Node {
        if kind == .MULTIPLY {
          needsMultiply = true
          return Node.createCall(Node.createName(imul), [left, right]).withType(cache.intType)
        }
        return wrapWithIntCast(Node.createBinary(kind, left, right).withType(cache.intType))
      }

      def wrapWithNot(node Node) Node {
        return Node.createUnary(.NOT, node).withType(cache.boolType).withRange(node.range)
      }

      def wrapWithIntCast(node Node) Node {
        return Node.createBinary(.BITWISE_OR, node, Node.createInt(0).withType(cache.intType)).withType(cache.intType).withRange(node.range)
      }

      def wrapWithTypeIndex(node Node, index Type, type Type) Node {
        return Node.createIndex(Node.createType(index), [node]).withType(type).withRange(node.range)
      }

      def patchBinaryArithmetic(node Node) {
        # Make sure arithmetic integer operators don't emit doubles outside the
        # integer range. Allowing this causes JIT slowdowns due to extra checks
        # during compilation and potential deoptimizations during execution.
        if node.resolvedType == cache.intType && !alwaysConvertsOperandsToInt(node.parent) {
          var left = node.binaryLeft
          var right = node.binaryRight
          if left.resolvedType == cache.intType && right.resolvedType == cache.intType {
            node.become(createIntBinary(node.kind, left.replaceWithNull, right.replaceWithNull).withRange(node.range))
          }
        }
      }

      # Group each variable inside the function with the function itself so that
      # they can be renamed together and won't cause any collisions inside the
      # function
      def unionVariableWithFunction(symbol Symbol, function Symbol) {
        if mangle && function != null {
          assert(symbol.id in namingGroupIndexForSymbol)
          assert(function.id in namingGroupIndexForSymbol)
          localVariableUnionFind.union(
            namingGroupIndexForSymbol[symbol.id],
            namingGroupIndexForSymbol[function.id])
        }
      }

      def patchNode(node Node) {
        if node == null {
          return
        }

        var oldEnclosingFunction = enclosingFunction
        var children = node.children
        var symbol = node.symbol
        var kind = node.kind

        if mangle && symbol != null {
          allocateNamingGroupIndex(symbol)
          if node.kind != .TYPE {
            symbolCounts[symbol.id] = symbolCounts.get(symbol.id, 0) + 1
          }
        }

        if children != null {
          if kind == .LAMBDA {
            enclosingFunction = node.symbol.asFunctionSymbol
          }

          for child in children {
            patchNode(child)
          }

          if kind == .LAMBDA {
            enclosingFunction = oldEnclosingFunction
          }
        }

        switch kind {
          case .ADD, .SUBTRACT, .MULTIPLY, .DIVIDE, .REMAINDER {
            patchBinaryArithmetic(node)
          }

          case .CAST {
            patchCast(node)
          }

          case .FOREACH {
            unionVariableWithFunction(node.symbol, enclosingFunction)
          }

          case .LAMBDA {
            var function = node.symbol.asFunctionSymbol
            for argument in function.arguments {
              allocateNamingGroupIndex(argument)
              unionVariableWithFunction(argument, function)
            }
            unionVariableWithFunction(function, enclosingFunction)
          }

          case .VAR {
            unionVariableWithFunction(node.symbol, enclosingFunction)
          }
        }
      }

      def patchCast(node Node) {
        var value = node.castValue
        var type = node.resolvedType
        var valueType = value.resolvedType

        # Cast to bool
        if type == cache.boolType {
          if valueType != cache.boolType {
            node.become(wrapWithNot(wrapWithNot(value.replaceWithNull)))
          }
        }

        # Cast to int
        else if type == cache.intType {
          # Cast from enum to int, only needed if the enum is represented as a string
          if valueType.isEnum {
            if options.enumFormat == .STRING {
              node.become(wrapWithTypeIndex(value.replaceWithNull, valueType, type))
            }
          }

          # Non-enum cast to int
          else if valueType != cache.intType && !alwaysConvertsOperandsToInt(node.parent) {
            node.become(wrapWithIntCast(value.replaceWithNull))
          }
        }

        # Cast to double
        else if type == cache.doubleType {
          if !cache.isNumeric(valueType) {
            node.become(Node.createUnary(.POSITIVE, value.replaceWithNull).withRange(node.range).withType(cache.doubleType))
          }
        }

        # Cast to string
        else if type == cache.stringType {
          # Cast from enum to string, only needed if the enum is represented as an int
          if valueType.isEnum {
            if options.enumFormat == .INT {
              node.become(wrapWithTypeIndex(value.replaceWithNull, valueType, type))
            }
          }

          # Non-enum cast to string
          else if valueType != cache.stringType {
            node.become(Node.createBinary(.ADD, value.replaceWithNull, Node.createString("").withType(cache.stringType)).withType(cache.stringType).withRange(node.range))
          }
        }

        # Cast to enum
        else if type.isEnum {
          # Cast from int or string to enum, only needed if the format is the other one
          if valueType == cache.intType && options.enumFormat == .STRING || valueType == cache.stringType && options.enumFormat == .INT {
            node.become(wrapWithTypeIndex(value.replaceWithNull, type, type))
          }
        }
      }
    }
  }

  namespace JsEmitter {
    @private {
      def fullName(symbol Symbol) string {
        var parent = symbol.parent
        if parent != null && parent.kind != .OBJECT_GLOBAL {
          var enclosingName = fullName(parent)
          if symbol.kind == .FUNCTION_CONSTRUCTOR {
            return enclosingName
          }
          if symbol.kind == .FUNCTION_INSTANCE {
            enclosingName += ".prototype"
          }
          return enclosingName + "." + mangleName(symbol)
        }
        return mangleName(symbol)
      }

      def mangleName(symbol Symbol) string {
        if symbol.kind == .FUNCTION_CONSTRUCTOR {
          symbol = symbol.parent
        }
        if !symbol.isImportedOrExported && symbol.name in isKeyword {
          return "$" + symbol.name
        }
        return symbol.nameWithRenaming
      }

      const isKeyword = {
        "apply": 0,
        "arguments": 0,
        "Boolean": 0,
        "break": 0,
        "call": 0,
        "case": 0,
        "catch": 0,
        "class": 0,
        "const": 0,
        "constructor": 0,
        "continue": 0,
        "Date": 0,
        "debugger": 0,
        "default": 0,
        "delete": 0,
        "do": 0,
        "double": 0,
        "else": 0,
        "export": 0,
        "extends": 0,
        "false": 0,
        "finally": 0,
        "float": 0,
        "for": 0,
        "Function": 0,
        "function": 0,
        "if": 0,
        "import": 0,
        "in": 0,
        "instanceof": 0,
        "int": 0,
        "let": 0,
        "new": 0,
        "null": 0,
        "Number": 0,
        "Object": 0,
        "return": 0,
        "String": 0,
        "super": 0,
        "this": 0,
        "throw": 0,
        "true": 0,
        "try": 0,
        "var": 0,
      }

      def needsExtends(objects List<ObjectSymbol>) bool {
        for object in objects {
          if !object.isImported && object.baseClass != null {
            return true
          }
        }
        return false
      }

      def computePrefix(symbol ObjectSymbol) string {
        assert(symbol.kind.isObject)
        return symbol.kind == .OBJECT_GLOBAL ? "" : computePrefix(symbol.parent.asObjectSymbol) + mangleName(symbol) + "."
      }

      def alwaysConvertsOperandsToInt(node Node) bool {
        if node != null {
          switch node.kind {
            case
              .ASSIGN_BITWISE_AND, .ASSIGN_BITWISE_OR, .ASSIGN_BITWISE_XOR,
              .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT, .BITWISE_AND, .BITWISE_OR,
              .BITWISE_XOR, .COMPLEMENT, .SHIFT_LEFT, .SHIFT_RIGHT {
              return true
            }
          }
        }
        return false
      }
    }
  }
}
