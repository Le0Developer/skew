namespace skew {
  class JsEmitter : Emitter {
    over visit(global ObjectSymbol) {
      var objects = sortedObjects(global)

      # The entire body of code is wrapped in a closure for safety
      emit(indent + "(function() {\n")
      increaseIndent

      if needsExtends(objects) {
        emit(indent + "function $extends(derived, base) {\n")
        emit(indent + "  derived.prototype = Object.create(base.prototype);\n")
        emit(indent + "  derived.prototype.constructor = derived;\n")
        emit(indent + "}\n\n")
      }

      # Emit objects and functions
      for object in objects {
        emitObject(object)
      }

      # Emit variables
      for object in objects {
        var o = object
        prefix = ""
        while o.kind != .OBJECT_GLOBAL {
          prefix = mangleName(o) + "." + prefix
          o = o.parent.asObjectSymbol
        }
        for variable in object.variables {
          emitVariable(variable)
        }
      }

      # Emit entry point
      var entryPointSymbol = cache.entryPointSymbol
      if entryPointSymbol != null {
        var type = entryPointSymbol.resolvedType
        var callText = fullName(entryPointSymbol) + (type.argumentTypes.isEmpty ? "()" : "(process.argv.slice(2))")
        emit("\n" + indent + (type.returnType == cache.intType ? "process.exit(" + callText + ")" : callText) + ";\n")
      }

      # End the closure wrapping everything
      decreaseIndent
      emit(indent + "}());\n")

      createSource("out.js")
    }

    @private {
      var previousSymbol Symbol = null
      var previousNode Node = null
      var prefix = ""

      def emitNewlineBeforeSymbol(symbol Symbol) {
        if previousSymbol != null &&
            (!previousSymbol.kind.isObject || !symbol.kind.isObject || symbol.comments != null || previousSymbol.kind == .OBJECT_ENUM || symbol.kind == .OBJECT_ENUM) &&
            (!previousSymbol.kind.isVariable || !symbol.kind.isVariable || symbol.comments != null) {
          emit("\n")
        }
        previousSymbol = null
      }

      def emitNewlineAfterSymbol(symbol Symbol) {
        previousSymbol = symbol
      }

      def isCompactNodeKind(kind NodeKind) bool {
        return kind == .EXPRESSION || kind == .VAR || kind.isJump
      }

      def emitNewlineBeforeStatement(node Node) {
        if previousNode != null && (node.comments != null || !isCompactNodeKind(previousNode.kind) || !isCompactNodeKind(node.kind)) {
          emit("\n")
        }
        previousNode = null
      }

      def emitNewlineAfterStatement(node Node) {
        previousNode = node
      }

      def emitComments(comments List<string>) {
        if comments != null {
          for comment in comments {
            emit(indent + "//" + comment)
          }
        }
      }

      def emitObject(symbol ObjectSymbol) {
        if symbol.isImported {
          return
        }

        prefix = symbol.parent != null ? computePrefix(symbol.parent.asObjectSymbol) : ""

        switch symbol.kind {
          case .OBJECT_NAMESPACE, .OBJECT_INTERFACE {
            emitNewlineBeforeSymbol(symbol)
            emitComments(symbol.comments)
            emit(indent + (prefix == "" && !symbol.isExported ? "var " : prefix) + mangleName(symbol) + " = {};\n")
            emitNewlineAfterSymbol(symbol)
          }

          case .OBJECT_ENUM {
            emitNewlineBeforeSymbol(symbol)
            emitComments(symbol.comments)
            emit(indent + (prefix == "" && !symbol.isExported ? "var " : prefix) + mangleName(symbol) + " = {")
            increaseIndent
            var isFirst = true
            for variable in symbol.variables {
              if variable.kind == .VARIABLE_ENUM {
                if isFirst { isFirst = false }
                else { emit(",") }
                emit("\n")
                emitNewlineBeforeSymbol(variable)
                emitComments(variable.comments)
                emit(indent + mangleName(variable) ": " variable.enumValue ", " variable.enumValue ": " quoteString(variable.name, '"'))
                emitNewlineAfterSymbol(variable)
              }
            }
            decreaseIndent
            if !isFirst { emit("\n") }
            emit("};\n")
            emitNewlineAfterSymbol(symbol)
          }

          case .OBJECT_CLASS {
            for function in symbol.functions {
              if function.kind == .FUNCTION_CONSTRUCTOR {
                if function.comments == null && symbol.comments != null {
                  function.comments = symbol.comments
                }
                emitFunction(function)
                if symbol.baseClass != null {
                  emit("\n" indent "$extends(" fullName(symbol) ", " fullName(symbol.baseClass) ");\n")
                }
              }
            }
          }
        }

        if symbol.kind != .OBJECT_GLOBAL {
          prefix += mangleName(symbol) + "."
        }

        for function in symbol.functions {
          if function.kind != .FUNCTION_CONSTRUCTOR {
            emitFunction(function)
          }
        }
      }

      def emitArgumentList(arguments List<VariableSymbol>) {
        for i in 0..arguments.count {
          if i > 0 {
            emit(", ")
          }
          emit(mangleName(arguments[i]))
        }
      }

      def emitFunction(symbol FunctionSymbol) {
        if symbol.block == null {
          return
        }

        emitNewlineBeforeSymbol(symbol)
        emitComments(symbol.comments)

        var isExpression = prefix != "" || symbol.isExported
        var name = mangleName(symbol.kind == .FUNCTION_CONSTRUCTOR ? symbol.parent : symbol)

        if isExpression {
          emit(indent + prefix + (symbol.kind == .FUNCTION_INSTANCE ? "prototype." : "") + name + " = function(")
        } else {
          emit(indent + "function " + name + "(")
        }

        emitArgumentList(symbol.arguments)
        emit(") {\n")
        increaseIndent

        if symbol.self != null {
          emit(indent + "var " + mangleName(symbol.self) + " = this;\n")
        }

        emitStatements(symbol.block.children)
        decreaseIndent
        emit(indent + "}" + (isExpression ? ";\n" : "\n"))
        emitNewlineAfterSymbol(symbol)
      }

      def emitVariable(symbol VariableSymbol) {
        if symbol.isImported {
          return
        }

        if symbol.kind != .VARIABLE_INSTANCE && (symbol.value != null || prefix == "") {
          emitNewlineBeforeSymbol(symbol)
          emitComments(symbol.comments)
          emit(indent + (prefix == "" && !symbol.isExported || symbol.kind == .VARIABLE_LOCAL ? "var " : prefix) + mangleName(symbol))

          if symbol.value != null {
            emit(" = ")
            emitExpression(symbol.value, .LOWEST)
          }

          emit(";\n")
          emitNewlineAfterSymbol(symbol)
        }
      }

      def emitStatements(statements List<Node>) {
        previousNode = null

        for statement in statements {
          emitNewlineBeforeStatement(statement)
          emitComments(statement.comments)
          emitStatement(statement)
          emitNewlineAfterStatement(statement)
        }

        previousNode = null
      }

      def emitBlock(node Node) {
        emit(" {\n")
        increaseIndent
        emitStatements(node.children)
        decreaseIndent
        emit(indent + "}")
      }

      def emitStatement(node Node) {
        switch node.kind {
          case .VAR {
            emitVariable(node.symbol.asVariableSymbol)
          }

          case .EXPRESSION {
            emit(indent)
            emitExpression(node.expressionValue, .LOWEST)
            emit(";\n")
          }

          case .BREAK {
            emit(indent + "break;\n")
          }

          case .CONTINUE {
            emit(indent + "continue;\n")
          }

          case .RETURN {
            emit(indent + "return")
            var value = node.returnValue
            if value != null {
              emit(" ")
              emitExpression(value, .LOWEST)
            }
            emit(";\n")
          }

          case .FOR {
            var test = node.forTest
            var update = node.forUpdate
            var children = node.children
            var count = children.count
            emit(indent "for (")
            if count > 3 {
              for i in 3..count {
                var child = children[i]
                if i != 3 {
                  emit(", ")
                }
                if child.kind == .VAR {
                  var symbol = child.symbol.asVariableSymbol
                  if i == 3 {
                    emit("var ")
                  }
                  emit(mangleName(symbol) " = ")
                  emitExpression(symbol.value, .LOWEST)
                } else {
                  emitExpression(child, .LOWEST)
                }
              }
            }
            emit("; ")
            if test != null {
              emitExpression(test, .LOWEST)
            }
            emit("; ")
            if update != null {
              emitExpression(update, .LOWEST)
            }
            emit(")")
            emitBlock(node.forBlock)
            emit("\n")
          }

          case .FOREACH {
            emit(indent "for (var " mangleName(node.symbol) " in ")
            emitExpression(node.foreachValue, .LOWEST)
            emit(")")
            emitBlock(node.foreachBlock)
            emit("\n")
          }

          case .IF {
            emit(indent)
            emitIf(node)
            emit("\n")
          }

          case .SWITCH {
            var cases = node.children
            emit(indent + "switch (")
            emitExpression(node.switchValue, .LOWEST)
            emit(") {\n")
            increaseIndent
            for i in 1..cases.count {
              var child = cases[i]
              var values = child.children
              if i != 1 {
                emit("\n")
              }
              if values.count == 1 {
                emit(indent + "default:")
              } else {
                for j in 1..values.count {
                  if j != 1 { emit("\n") }
                  emit(indent + "case ")
                  emitExpression(values[j], .LOWEST)
                  emit(":")
                }
              }
              emit(" {\n")
              increaseIndent
              emitStatements(child.caseBlock.children)
              emit(indent + "break;\n")
              decreaseIndent
              emit(indent + "}\n")
            }
            decreaseIndent
            emit(indent + "}\n")
          }

          case .WHILE {
            emit(indent + "while (")
            emitExpression(node.whileTest, .LOWEST)
            emit(")")
            emitBlock(node.whileBlock)
            emit("\n")
          }

          default {
            assert(false)
          }
        }
      }

      def emitIf(node Node) {
        emit("if (")
        emitExpression(node.ifTest, .LOWEST)
        emit(")")
        emitBlock(node.ifTrue)

        var block = node.ifFalse
        if block != null {
          var singleIf = block.children.count == 1 && block.children[0].kind == .IF ? block.children[0] : null
          emit("\n\n")
          emitComments(block.comments)
          if singleIf != null {
            emitComments(singleIf.comments)
          }
          emit(indent + "else")

          if singleIf != null {
            emit(" ")
            emitIf(singleIf)
          } else {
            emitBlock(block)
          }
        }
      }

      def emitExpression(node Node, precedence Precedence) {
        switch (node.kind) {
          case .TYPE {
            emit(fullName(node.resolvedType.symbol))
          }

          case .NULL {
            emit("null")
          }

          case .NAME {
            emit(node.symbol != null ? fullName(node.symbol) : node.asString)
          }

          case .DOT {
            emitExpression(node.dotTarget, .MEMBER)
            emit("." + (node.symbol != null ? mangleName(node.symbol) : node.asString))
          }

          case .CONSTANT {
            var value = node.content
            switch value.kind {
              case .BOOL { emit(value.asBool.toString) }
              case .INT { emit(value.asInt.toString) }
              case .DOUBLE { emit(value.asDouble.toString) }
              case .STRING { emit(quoteString(value.asString, '"')) }
            }
          }

          case .CALL {
            var value = node.callValue
            var call = value.kind == .SUPER
            var wrap = value.kind == .LAMBDA && node.parent != null && node.parent.kind == .EXPRESSION

            if wrap {
              emit("(")
            }

            if !call && node.symbol != null && node.symbol.kind == .FUNCTION_CONSTRUCTOR {
              emit("new " + fullName(node.symbol))
            } else {
              emitExpression(value, .UNARY_POSTFIX)
              if call {
                emit(".call")
              }
            }

            if wrap {
              emit(")")
            }

            emit("(")

            if call {
              emit(mangleName(node.symbol.asFunctionSymbol.self))
            }

            for i in 1..node.children.count {
              if call || i > 1 {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit(")")
          }

          case .INITIALIZER_LIST, .INITIALIZER_MAP, .INITIALIZER_SET {
            var useBraces = node.kind == .INITIALIZER_MAP || node.kind == .INITIALIZER_SET && node.children.isEmpty
            emit(useBraces ? "{" : "[")

            for i in 0..node.children.count {
              if i != 0 {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit(useBraces ? "}" : "]")
          }

          case .PAIR {
            emitExpression(node.firstValue, .LOWEST)
            emit(": ")
            emitExpression(node.secondValue, .LOWEST)
          }

          case .INDEX {
            emitExpression(node.children[0], .UNARY_POSTFIX)
            emit("[")

            for i in 1..node.children.count {
              if i > 1 {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit("]")
          }

          case .ASSIGN_INDEX {
            if Precedence.ASSIGN as int < precedence as int {
              emit("(")
            }

            emitExpression(node.children.first, .UNARY_POSTFIX)
            emit("[")

            for i in 1..node.children.count - 1 {
              if i > 1 {
                emit(", ")
              }
              emitExpression(node.children[i], .LOWEST)
            }

            emit("] = ")
            emitExpression(node.children.last, .LOWEST)

            if Precedence.ASSIGN as int < precedence as int {
              emit(")")
            }
          }

          case .CAST {
            var value = node.castValue
            var from = value.resolvedType
            var to = node.resolvedType

            if from.isEnum && to == cache.stringType {
              emit(fullName(from.symbol) + "[")
              emitExpression(value, precedence)
              emit("]")
            }

            else if from == cache.stringType && to.isEnum {
              emit(fullName(to.symbol) + "[")
              emitExpression(value, precedence)
              emit("]")
            }

            # TODO: Do this better
            else if to == cache.intType {
              emit("((")
              emitExpression(value, precedence)
              emit(") | 0)")
            }

            else {
              emitExpression(value, precedence)
            }
          }

          case .PARAMETERIZE {
            emitExpression(node.parameterizeValue, precedence)
          }

          case .SUPER {
            emit(fullName(node.symbol))
          }

          case .HOOK {
            if Precedence.ASSIGN as int < precedence as int {
              emit("(")
            }
            emitExpression(node.hookTest, .LOGICAL_OR)
            emit(" ? ")
            emitExpression(node.hookTrue, .ASSIGN)
            emit(" : ")
            emitExpression(node.hookFalse, .ASSIGN)
            if Precedence.ASSIGN as int < precedence as int {
              emit(")")
            }
          }

          case .LAMBDA {
            var symbol = node.symbol.asFunctionSymbol
            emit("function(")
            emitArgumentList(symbol.arguments)
            emit(")")
            emitBlock(symbol.block)
          }

          default {
            if node.kind.isUnary {
              var value = node.unaryValue
              var info = operatorInfo[node.kind]
              if info.precedence as int < precedence as int {
                emit("(")
              }
              emit(info.text)
              emitExpression(value, info.precedence)
              if info.precedence as int < precedence as int {
                emit(")")
              }
            }

            # TODO: Remove hack
            else if node.kind == .DIVIDE && node.resolvedType == cache.intType {
              emit("((")
              emitExpression(node.binaryLeft, .LOWEST)
              emit(") / (")
              emitExpression(node.binaryRight, .LOWEST)
              emit(") | 0)")
            }

            else if node.kind.isBinary {
              var info = operatorInfo[node.kind]
              if info.precedence as int < precedence as int {
                emit("(")
              }
              emitExpression(node.binaryLeft, info.precedence.incrementIfRightAssociative(info.associativity))
              emit(node.kind == .EQUAL ? " === " : node.kind == .NOT_EQUAL ? " !== " : " " + info.text + " ")
              emitExpression(node.binaryRight, info.precedence.incrementIfLeftAssociative(info.associativity))
              if info.precedence as int < precedence as int {
                emit(")")
              }
            }

            else {
              assert(false)
            }
          }
        }
      }
    }
  }

  namespace JsEmitter {
    @private {
      def fullName(symbol Symbol) string {
        var parent = symbol.parent
        if parent != null && parent.kind != .OBJECT_GLOBAL {
          var enclosingName = fullName(parent)
          if symbol.kind == .FUNCTION_CONSTRUCTOR {
            return enclosingName
          }
          if symbol.kind == .FUNCTION_INSTANCE {
            enclosingName += ".prototype"
          }
          return enclosingName "." mangleName(symbol)
        }
        return mangleName(symbol)
      }

      def mangleName(symbol Symbol) string {
        if symbol.kind == .FUNCTION_CONSTRUCTOR {
          symbol = symbol.parent
        }
        if !symbol.isImportedOrExported && symbol.name in isKeyword {
          return "$" symbol.name
        }
        return symbol.name
      }

      const isKeyword = {
        "apply": 0,
        "arguments": 0,
        "Boolean": 0,
        "break": 0,
        "call": 0,
        "case": 0,
        "catch": 0,
        "class": 0,
        "const": 0,
        "constructor": 0,
        "continue": 0,
        "Date": 0,
        "debugger": 0,
        "default": 0,
        "delete": 0,
        "do": 0,
        "double": 0,
        "else": 0,
        "export": 0,
        "extends": 0,
        "false": 0,
        "finally": 0,
        "float": 0,
        "for": 0,
        "Function": 0,
        "function": 0,
        "if": 0,
        "import": 0,
        "in": 0,
        "instanceof": 0,
        "int": 0,
        "let": 0,
        "new": 0,
        "null": 0,
        "Number": 0,
        "Object": 0,
        "return": 0,
        "String": 0,
        "super": 0,
        "this": 0,
        "throw": 0,
        "true": 0,
        "try": 0,
        "var": 0,
      }

      def needsExtends(objects List<ObjectSymbol>) bool {
        for object in objects {
          if !object.isImported && object.baseClass != null {
            return true
          }
        }
        return false
      }

      def computePrefix(symbol ObjectSymbol) string {
        assert(symbol.kind.isObject)
        return symbol.kind == .OBJECT_GLOBAL ? "" : computePrefix(symbol.parent.asObjectSymbol) + mangleName(symbol) + "."
      }
    }
  }
}
