namespace tests {
  void testSimple() {

test("
class Foo<T> {
  def foo T
}

class Bar<T> {
  def bar T
}

def main {
  var x Foo<Bar<Foo<int>>>
  var a bool = x
  var b bool = x.foo
  var c bool = x.foo.bar
  var d bool = x.foo.bar.foo
}
", "
<stdin>:11:16: error: Cannot convert from type \"Foo<Bar<Foo<int>>>\" to type \"bool\"
  var a bool = x
               ^
<stdin>:12:16: error: Cannot convert from type \"Bar<Foo<int>>\" to type \"bool\"
  var b bool = x.foo
               ~~~~~
<stdin>:13:16: error: Cannot convert from type \"Foo<int>\" to type \"bool\"
  var c bool = x.foo.bar
               ~~~~~~~~~
<stdin>:14:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var d bool = x.foo.bar.foo
               ~~~~~~~~~~~~~
")

test("
class Foo {
  def new {}
  def []=() {}
}

def main {
  Foo.new[ ]= false
  Foo.new[] = false
  Foo.new[]= false
}
", "
<stdin>:7:10: error: Expected 0 arguments but found 1 argument
  Foo.new[ ]= false
         ~~~~~~~~~~
<stdin>:8:10: error: Expected 0 arguments but found 1 argument
  Foo.new[] = false
         ~~~~~~~~~~
<stdin>:9:10: error: Expected 0 arguments but found 1 argument
  Foo.new[]= false
         ~~~~~~~~~
")

test("
class Foo {
  def new {}
}

namespace Foo {
  def new(x int) Foo {
    return new
  }
}

def main {
  Foo.new
  Foo.new(100)
}
", "
")

test("
class Foo<T> {
  def size int
  def pop() T
  def shift() T
  def push(value T)
  def unshift(value T)
  def map<R>(callback fn(T) R) Foo<R>
  def filter(callback fn(T) bool) Foo<T>
}

def main {
  var x Foo<int>
  x.push(x.size)
  x.filter(1.0)
  x.map(1.0)
  x.map<string>(1.0)
  x.filter(x => x + 100)
  x.map(x => x + 100)
  var y int = x.map<string>(1.0)
}
", "
<stdin>:14:12: error: Cannot convert from type \"double\" to type \"fn(int) bool\"
  x.filter(1.0)
           ~~~
<stdin>:15:3: error: Cannot use unparameterized type \"map\"
  x.map(1.0)
  ~~~~~
<stdin>:16:17: error: Cannot convert from type \"double\" to type \"fn(int) string\"
  x.map<string>(1.0)
                ~~~
<stdin>:17:17: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  x.filter(x => x + 100)
                ~~~~~~~
<stdin>:18:3: error: Cannot use unparameterized type \"map\"
  x.map(x => x + 100)
  ~~~~~
<stdin>:18:9: error: Unable to determine the type of \"x\"
  x.map(x => x + 100)
        ^
<stdin>:19:29: error: Cannot convert from type \"double\" to type \"fn(int) string\"
  var y int = x.map<string>(1.0)
                            ~~~
<stdin>:19:15: error: Cannot convert from type \"Foo<int>\" to type \"int\"
  var y int = x.map<string>(1.0)
              ~~~~~~~~~~~~~~~~~~
")

test("
class Foo {
  def new
  def foo<T>(t T) Foo
}

def main {
  Foo.new.foo(0).foo(0.0)
  Foo.new.foo<bool>(0).foo<int>(0.0)
}
", "
<stdin>:7:3: error: Cannot use unparameterized type \"foo\"
  Foo.new.foo(0).foo(0.0)
  ~~~~~~~~~~~
<stdin>:8:21: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  Foo.new.foo<bool>(0).foo<int>(0.0)
                    ^
<stdin>:8:33: error: Cannot convert from type \"double\" to type \"int\" without a cast
  Foo.new.foo<bool>(0).foo<int>(0.0)
                                ~~~
")

test("
class Foo<T> {
  def new
}

def main {
  var x int = Foo.new
  var y int = Foo<int>.new
}
", "
<stdin>:6:15: error: Cannot use unparameterized type \"Foo\"
  var x int = Foo.new
              ~~~
<stdin>:7:15: error: Cannot convert from type \"Foo<int>\" to type \"int\"
  var y int = Foo<int>.new
              ~~~~~~~~~~~~
")

test("
class Foo {
  def new
  def foo Foo
  def bar
}

def main {
  var x int = => Foo.new
  var y int = => Foo.new.foo
  var z int = => Foo.new.bar
}
", "
<stdin>:8:15: error: Cannot convert from type \"fn() Foo\" to type \"int\"
  var x int = => Foo.new
              ~~~~~~~~~~
<stdin>:9:15: error: Cannot convert from type \"fn() Foo\" to type \"int\"
  var y int = => Foo.new.foo
              ~~~~~~~~~~~~~~
<stdin>:10:15: error: Cannot convert from type \"fn()\" to type \"int\"
  var z int = => Foo.new.bar
              ~~~~~~~~~~~~~~
")

test("
def main {
  bar(x => foo(x))
}

def foo(x int) int {
  return 0
}

def bar(x fn(int)) {
}
", "
")

  }
}
