namespace tests {
  void testSimple() {

test("
class Foo<T> {
  def foo T
}

class Bar<T> {
  def bar T
}

def main {
  var x Foo<Bar<Foo<int>>>
  var a bool = x
  var b bool = x.foo
  var c bool = x.foo.bar
  var d bool = x.foo.bar.foo
}
", "
<stdin>:11:16: error: Cannot convert from type \"Foo<Bar<Foo<int>>>\" to type \"bool\"
  var a bool = x
               ^
<stdin>:12:16: error: Cannot convert from type \"Bar<Foo<int>>\" to type \"bool\"
  var b bool = x.foo
               ~~~~~
<stdin>:13:16: error: Cannot convert from type \"Foo<int>\" to type \"bool\"
  var c bool = x.foo.bar
               ~~~~~~~~~
<stdin>:14:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var d bool = x.foo.bar.foo
               ~~~~~~~~~~~~~
")

test("
class Foo {
  def new {}
}

namespace Foo {
  def new(x int) Foo {
    return new
  }
}

def main {
  Foo.new
  Foo.new(100)
}
", "
")

test("
class Foo<T> {
  def size int
  def pop T
  def shift T
  def push(value T)
  def unshift(value T)
  def map<R>(callback fn(T) R) Foo<R>
  def filter(callback fn(T) bool) Foo<T>
}

def main {
  var x Foo<int>
  x.push(x.size)
  x.filter(1.0)
  x.map(1.0)
  x.map<string>(1.0)
  x.filter(x => x + 100)
  x.map(x => x + 100)
  var y int = x.map<string>(1.0)
}
", "
<stdin>:14:12: error: Cannot convert from type \"double\" to type \"fn(int) bool\"
  x.filter(1.0)
           ~~~
<stdin>:15:3: error: Cannot use unparameterized type \"map\" here
  x.map(1.0)
  ~~~~~
<stdin>:16:17: error: Cannot convert from type \"double\" to type \"fn(int) string\"
  x.map<string>(1.0)
                ~~~
<stdin>:17:17: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  x.filter(x => x + 100)
                ~~~~~~~
<stdin>:18:3: error: Cannot use unparameterized type \"map\" here
  x.map(x => x + 100)
  ~~~~~
<stdin>:18:9: error: Unable to determine the type of \"x\"
  x.map(x => x + 100)
        ^
<stdin>:19:29: error: Cannot convert from type \"double\" to type \"fn(int) string\"
  var y int = x.map<string>(1.0)
                            ~~~
<stdin>:19:15: error: Cannot convert from type \"Foo<string>\" to type \"int\"
  var y int = x.map<string>(1.0)
              ~~~~~~~~~~~~~~~~~~
")

test("
class Foo {
  def new
  def foo<T>(t T) Foo
}

def main {
  Foo.new.foo(0).foo(0.0)
  Foo.new.foo<bool>(0).foo<int>(0.0)
}
", "
<stdin>:7:3: error: Cannot use unparameterized type \"foo\" here
  Foo.new.foo(0).foo(0.0)
  ~~~~~~~~~~~
<stdin>:8:21: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  Foo.new.foo<bool>(0).foo<int>(0.0)
                    ^
<stdin>:8:33: error: Cannot convert from type \"double\" to type \"int\" without a cast
  Foo.new.foo<bool>(0).foo<int>(0.0)
                                ~~~
")

test("
class Foo {
  def new
  def foo Foo
  def bar
}

def main {
  var x int = => Foo.new
  var y int = => Foo.new.foo
  var z int = => Foo.new.bar
}
", "
<stdin>:8:15: error: Cannot convert from type \"fn() Foo\" to type \"int\"
  var x int = => Foo.new
              ~~~~~~~~~~
<stdin>:9:15: error: Cannot convert from type \"fn() Foo\" to type \"int\"
  var y int = => Foo.new.foo
              ~~~~~~~~~~~~~~
<stdin>:10:15: error: Cannot convert from type \"fn()\" to type \"int\"
  var z int = => Foo.new.bar
              ~~~~~~~~~~~~~~
")

test("
def main(x int) {
  main
  x
  x + 1
  x ? x : x
}
", "
<stdin>:2:3: warning: Unused expression
  main
  ~~~~
<stdin>:3:3: warning: Unused expression
  x
  ^
<stdin>:4:3: warning: Unused expression
  x + 1
  ~~~~~
<stdin>:5:3: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  x ? x : x
  ^
<stdin>:5:7: warning: Unused expression
  x ? x : x
      ^
<stdin>:5:11: warning: Unused expression
  x ? x : x
          ^
")

test("
def main {
  bar(x => foo(x))
  bar(x => x + 1)
  bar(x => x)
}

def foo(x int) int {
  return 0
}

def bar(x fn(int)) {
}
", "
<stdin>:3:12: warning: Unused expression
  bar(x => x + 1)
           ~~~~~
<stdin>:4:12: warning: Unused expression
  bar(x => x)
           ^
")

test("
def main {
  var x = null
  var y = => null
}
", "
<stdin>:2:7: error: Implicitly typed variables cannot be of type \"null\"
  var x = null
      ^
<stdin>:3:14: error: Cannot create a function with a return type of \"null\"
  var y = => null
             ~~~~
")

test("
def main {
  var a = => 0
  var b = => {}
  var c = () => 0
  var d = () => {}
  var e = () int => 0
  var f = () int => { return 0 }
  var g fn(int) = x => 0
  var h fn(int) = x => {}
  var i fn(int) int = (x) => 0
  var j fn(int) int = (x) => { return 0 }
  var k = (x int) => 0
  var l = (x int) => {}
  var m = (x int) int => 0
  var n = (x int) int => { return 0 }
}
", "
<stdin>:8:24: warning: Unused expression
  var g fn(int) = x => 0
                       ^
")

test("
class Foo<T> {
  def new
}

def main {
  var foo Foo<int> = Foo<int>.new
  var bar Foo<bool> = Foo<int>.new
}
", "
<stdin>:7:23: error: Cannot convert from type \"Foo<int>\" to type \"Foo<bool>\"
  var bar Foo<bool> = Foo<int>.new
                      ~~~~~~~~~~~~
")

test("
class Foo {
  def in(x int) bool
}

def main(foo Foo) {
  false in foo
  0 in foo
}
", "
<stdin>:6:3: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  false in foo
  ~~~~~
")

test("
namespace foo {
  namespace bar {
    def @baz
  }
}

@foo.bar.bax
@foo.bar.baz
def main
", "
<stdin>:7:10: error: \"@bax\" is not declared on type \"bar\"
@foo.bar.bax
         ~~~
")

test("
def @foo(x int)
def @bar

@foo
@foo(1, 2)
@bar(1)
def main
", "
<stdin>:4:1: error: Expected 1 argument but found 0 arguments when calling \"@foo\"
@foo
~~~~
<stdin>:5:5: error: Expected 1 argument but found 2 arguments when calling \"@foo\"
@foo(1, 2)
    ~~~~~~
<stdin>:6:5: error: The function \"@bar\" takes no arguments and is already called implicitly
@bar(1)
    ~~~
")

// These shouldn't cause missing newline errors
test("
def @foo

class foo {
  def -
  def new
}

class bar {
  def -

  @foo
  def new
}

class baz {
  def -

  # foo
  def new
}

def main bool {
  return 1 -
    1
}
", "
<stdin>:23:10: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  return 1 -
         ~~~
")

test("
class Foo {
  def foo {
    var self int
  }

  def bar(self int) {
  }

  def baz {
    if true {
      var self int
    }
  }
}
", "
<stdin>:3:9: error: \"self\" is already declared
    var self int
        ~~~~
<stdin>:6:11: error: \"self\" is already declared
  def bar(self int) {
          ~~~~
<stdin>:11:11: error: \"self\" shadows a previous declaration
      var self int
          ~~~~
")

test("
namespace a {
  class Foo.Bar {}
  class Foo.Baz {}
  class Foo {}
  def main(foo Foo.Bar, bar Foo.Baz) {}
}
namespace b {
  class Foo {
    class Bar {}
    class Baz {}
  }
  def main(foo Foo.Bar, bar Foo.Baz) {}
}
", "
")

test("
class ns1.Foo {}
var ns1 int
var ns2 int
class ns2.Foo {}
", "
<stdin>:2:5: error: \"ns1\" is already declared
var ns1 int
    ~~~
<stdin>:1:7: note: The previous declaration is here
class ns1.Foo {}
      ~~~
<stdin>:3:5: error: \"ns2\" is already declared
var ns2 int
    ~~~
<stdin>:4:7: note: The previous declaration is here
class ns2.Foo {}
      ~~~
")

test("
var ns.foo int
", "
<stdin>:1:7: error: Expected NEWLINE but found DOT
var ns.foo int
      ^
")

test("
def ns.foo int
", "
<stdin>:1:7: error: Expected NEWLINE but found DOT
def ns.foo int
      ^
")

test("
@skip
var a int

@skip {
  var x int
  var y int
}

@skip
@skip
def b

@skip
@skip {
  def c
}
", "
<stdin>:10:1: error: Duplicate annotation \"@skip\" on \"b\"
@skip
~~~~~
<stdin>:14:1: error: Duplicate annotation \"@skip\" on \"c\"
@skip {
~~~~~
<stdin>:1:1: error: Cannot use the annotation \"@skip\" on \"a\"
@skip
~~~~~
<stdin>:4:1: error: Cannot use the annotation \"@skip\" on \"x\"
@skip {
~~~~~
<stdin>:4:1: error: Cannot use the annotation \"@skip\" on \"y\"
@skip {
~~~~~
")

test("
class Foo {
  const a
  const b int
  const c = 0
  const d bool = 0
}

@import
class Bar {
  const a
  const b int
  const c = 0
  const d bool = 0
}

const a
const b int
const c = 0
const d bool = 0

@import {
  const w
  const x int
  const y = 0
  const z bool = 0
}
", "
<stdin>:2:9: error: Unable to determine the type of \"a\"
  const a
        ^
<stdin>:3:9: error: The constant \"b\" must be initialized
  const b int
        ^
<stdin>:5:18: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  const d bool = 0
                 ^
<stdin>:10:9: error: Unable to determine the type of \"a\"
  const a
        ^
<stdin>:13:18: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  const d bool = 0
                 ^
<stdin>:16:7: error: Unable to determine the type of \"a\"
const a
      ^
<stdin>:17:7: error: The constant \"b\" must be initialized
const b int
      ^
<stdin>:19:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
const d bool = 0
               ^
<stdin>:22:9: error: Unable to determine the type of \"w\"
  const w
        ^
<stdin>:25:18: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  const z bool = 0
                 ^
")

test("
const a = 0
var b = 0

class Foo {
  const x = 0
}

def main(foo Foo) {
  const y = 0
  a = 0
  b = 0
  foo.x = 0
  y = 0
}
", "
<stdin>:10:3: error: Cannot store to constant symbol \"a\"
  a = 0
  ^
<stdin>:12:7: error: Cannot store to constant symbol \"x\"
  foo.x = 0
      ^
<stdin>:13:3: error: Cannot store to constant symbol \"y\"
  y = 0
  ^
")

test("
@private
class Foo {
  @private
  var x int

  @private
  def foo {
    x = 0
    foo
    var y = => x
  }

  @private
  class Bar {}

  var bar Bar
}

@private
def main(foo Foo) {
  foo.x = 0
  foo.foo
  var x = => foo.x
  var y = => foo.foo
  var z Foo.Bar
}
", "
<stdin>:1:1: error: Cannot use the annotation \"@private\" on \"Foo\"
@private
~~~~~~~~
<stdin>:19:1: error: Cannot use the annotation \"@private\" on \"main\"
@private
~~~~~~~~
<stdin>:21:7: error: Cannot access \"@private\" symbol \"x\" here
  foo.x = 0
      ^
<stdin>:22:7: error: Cannot access \"@private\" symbol \"foo\" here
  foo.foo
      ~~~
<stdin>:23:18: error: Cannot access \"@private\" symbol \"x\" here
  var x = => foo.x
                 ^
<stdin>:24:18: error: Cannot access \"@private\" symbol \"foo\" here
  var y = => foo.foo
                 ~~~
<stdin>:25:13: error: Cannot access \"@private\" symbol \"Bar\" here
  var z Foo.Bar
            ~~~

")

test("
class bool {
  def +(x int, y int)
  def -(x int, y int) {}
}

def main {
  false + false
  false - false
}
", "
<stdin>:2:7: error: Expected \"+\" to take at most 1 argument
  def +(x int, y int)
      ^
<stdin>:3:7: error: Expected \"-\" to take at most 1 argument
  def -(x int, y int) {}
      ^
<stdin>:7:9: error: Expected 2 arguments but found 1 argument when calling \"+\"
  false + false
        ^
<stdin>:8:9: error: Expected 2 arguments but found 1 argument when calling \"-\"
  false - false
        ^
")

test("
class bool {
  def +(x bool)
  def -(x bool) {}
}

def main {
  false + false + false
  false - false - false
}
", "
<stdin>:7:3: error: The function \"+\" does not return a value
  false + false + false
  ~~~~~~~~~~~~~
<stdin>:8:3: error: The function \"-\" does not return a value
  false - false - false
  ~~~~~~~~~~~~~
")

test("
def main {
  0 + 0
  0 + 0.5
  0.5 + 0
  0.5 + 0.5
}
", "
<stdin>:2:3: warning: Unused expression
  0 + 0
  ~~~~~
<stdin>:3:3: warning: Unused expression
  0 + 0.5
  ~~~~~~~
<stdin>:4:3: warning: Unused expression
  0.5 + 0
  ~~~~~~~
<stdin>:5:3: warning: Unused expression
  0.5 + 0.5
  ~~~~~~~~~
")

test("
class Foo {
  def *
  def -(x int, y int)
  def <=> int
  def [...]
  def []
  def []=
  def foo=
  def !(x int)
  def {...}
}
", "
<stdin>:2:7: error: Expected \"*\" to take 1 argument
  def *
      ^
<stdin>:3:7: error: Expected \"-\" to take at most 1 argument
  def -(x int, y int)
      ^
<stdin>:4:7: error: Expected \"<=>\" to take 1 argument
  def <=> int
      ~~~
<stdin>:5:7: error: Expected \"[...]\" to take 1 argument
  def [...]
      ~~~~~
<stdin>:6:7: error: Expected \"[]\" to take at least 1 argument
  def []
      ~~
<stdin>:7:7: error: Expected \"[]=\" to take at least 2 arguments
  def []=
      ~~~
<stdin>:8:7: error: Expected \"foo=\" to take 1 argument
  def foo=
      ~~~~
<stdin>:9:7: error: Expected \"!\" to take 0 arguments
  def !(x int)
      ^
<stdin>:10:7: error: Expected \"{...}\" to take between 1 and 2 arguments
  def {...}
      ~~~~~
")

test("
def main(x List<double>) {
  var y bool = x[false]
}
", "
<stdin>:2:18: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var y bool = x[false]
                 ~~~~~
<stdin>:2:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var y bool = x[false]
               ~~~~~~~~
")

test("
def main(i int) {
  for i in false..false {
    i = false
  }
  for i in List<string>.new {
    i = false
  }
  for i in 0 {
    i = false
  }
  for j in 0..10 {}
  for j in 10..0 {}
}
", "
<stdin>:2:12: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  for i in false..false {
           ~~~~~
<stdin>:2:19: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  for i in false..false {
                  ~~~~~
<stdin>:2:7: error: \"i\" shadows a previous declaration
  for i in false..false {
      ^
<stdin>:1:10: note: The previous declaration is here
def main(i int) {
         ^
<stdin>:3:9: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    i = false
        ~~~~~
<stdin>:5:7: error: \"i\" shadows a previous declaration
  for i in List<string>.new {
      ^
<stdin>:1:10: note: The previous declaration is here
def main(i int) {
         ^
<stdin>:6:9: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    i = false
        ~~~~~
<stdin>:8:12: error: Cannot iterate over type \"int\"
  for i in 0 {
           ^
<stdin>:8:7: error: \"i\" shadows a previous declaration
  for i in 0 {
      ^
<stdin>:1:10: note: The previous declaration is here
def main(i int) {
         ^
<stdin>:9:9: error: Cannot convert from type \"bool\" to type \"int\" without a cast
    i = false
        ~~~~~
<stdin>:12:12: warning: This range is empty
  for j in 10..0 {}
           ~~~~~
")

test("
def main {
  var foo = true ? false : 0
  var bar bool = true ? 0 : 0.5
}
", "
<stdin>:2:20: error: No common type for \"bool\" and \"int\"
  var foo = true ? false : 0
                   ~~~~~~~~~
<stdin>:3:25: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var bar bool = true ? 0 : 0.5
                        ^
<stdin>:3:29: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var bar bool = true ? 0 : 0.5
                            ~~~
")

test("
def main {
  var a int = [false]
  var b List<int> = [false]
  var c List<List<int>> = [[false]]
  var d int = {1: 2}
  var e IntMap<bool> = {\"a\": \"b\"}
  var f StringMap<bool> = {1: 2}
  [false, 0]
  [0, 0.5] - 1
  [null, [1], [0.5]]
  [null]
  []
  {0: 1} - 1
  {\"a\": 1} - 1
  {0.5: 1} - 1
  [foo]
}

def foo(x int) {
}
", "
<stdin>:2:15: error: Cannot infer a type for this literal
  var a int = [false]
              ~~~~~~~
<stdin>:3:22: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var b List<int> = [false]
                     ~~~~~
<stdin>:4:29: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var c List<List<int>> = [[false]]
                            ~~~~~
<stdin>:5:15: error: Cannot infer a type for this literal
  var d int = {1: 2}
              ~~~~~~
<stdin>:6:25: error: Cannot convert from type \"string\" to type \"int\"
  var e IntMap<bool> = {\"a\": \"b\"}
                        ~~~
<stdin>:6:30: error: Cannot convert from type \"string\" to type \"bool\"
  var e IntMap<bool> = {\"a\": \"b\"}
                             ~~~
<stdin>:7:28: error: Cannot convert from type \"int\" to type \"string\"
  var f StringMap<bool> = {1: 2}
                           ^
<stdin>:7:31: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var f StringMap<bool> = {1: 2}
                              ^
<stdin>:8:11: error: No common type for \"bool\" and \"int\"
  [false, 0]
          ^
<stdin>:8:3: warning: Unused expression
  [false, 0]
  ~~~~~~~~~~
<stdin>:9:12: error: \"-\" is not declared on type \"List<double>\"
  [0, 0.5] - 1
           ^
<stdin>:10:15: error: No common type for \"List<int>\" and \"List<double>\"
  [null, [1], [0.5]]
              ~~~~~
<stdin>:10:3: warning: Unused expression
  [null, [1], [0.5]]
  ~~~~~~~~~~~~~~~~~~
<stdin>:11:3: error: Cannot infer a type for this literal
  [null]
  ~~~~~~
<stdin>:12:3: error: Cannot infer a type for this literal
  []
  ~~
<stdin>:13:10: error: \"-\" is not declared on type \"IntMap<int>\"
  {0: 1} - 1
         ^
<stdin>:14:12: error: \"-\" is not declared on type \"StringMap<int>\"
  {\"a\": 1} - 1
           ^
<stdin>:15:3: error: Cannot infer a type for this literal
  {0.5: 1} - 1
  ~~~~~~~~
<stdin>:16:3: error: Cannot infer a type for this literal
  [foo]
  ~~~~~
")

test("
class A {}

class B {
  def [...] {}
}

class C {
  def new {}
  def [...] {}
}

class D {
  def new {}
  def [...](x bool) D { return self }
}

def main {
  var a A = [1, 2]
  var b B = [1, 2]
  var c C = [1, 2]
  var d D = [1, 2]
}
", "
<stdin>:4:7: error: Expected \"[...]\" to take 1 argument
  def [...] {}
      ~~~~~
<stdin>:9:7: error: Expected \"[...]\" to take 1 argument
  def [...] {}
      ~~~~~
<stdin>:18:13: error: Cannot infer a type for this literal
  var a A = [1, 2]
            ~~~~~~
<stdin>:19:13: error: \"new\" is not declared on type \"B\"
  var b B = [1, 2]
            ~~~~~~
<stdin>:20:14: error: The function \"[...]\" does not return a value
  var c C = [1, 2]
             ^
<stdin>:20:14: error: Expected 0 arguments but found 1 argument when calling \"[...]\"
  var c C = [1, 2]
             ^
<stdin>:21:14: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var d D = [1, 2]
             ^
<stdin>:21:17: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var d D = [1, 2]
                ^
")

test("
class Foo {
  def [new](x int, y int, z int) int
  def {new}(x int, y int, z int) int
}
", "
<stdin>:2:34: error: Constructors cannot have a return type
  def [new](x int, y int, z int) int
                                 ~~~
<stdin>:2:7: error: Expected \"[new]\" to take at most 1 argument
  def [new](x int, y int, z int) int
      ~~~~~
<stdin>:3:34: error: Constructors cannot have a return type
  def {new}(x int, y int, z int) int
                                 ~~~
<stdin>:3:7: error: Expected \"{new}\" to take at most 2 arguments
  def {new}(x int, y int, z int) int
      ~~~~~
")

test("
class Foo {
  def foo int {
    return Bar<int>.new.foo
  }

  def bar List<int> {
    return Bar<int>.new.foo
  }
}

class Bar<X> {
  def new
  def foo List<X>
}
", "
<stdin>:3:12: error: Cannot convert from type \"List<int>\" to type \"int\"
    return Bar<int>.new.foo
           ~~~~~~~~~~~~~~~~
")

test("
class Foo {
  def foo int
  def foo double
  def bar(x int)
  def bar(x double)
  def bar(x int)
}
", "
<stdin>:3:7: error: Duplicate overloaded function \"foo\"
  def foo double
      ~~~
<stdin>:2:7: note: The previous declaration is here
  def foo int
      ~~~
<stdin>:6:7: error: Duplicate overloaded function \"bar\"
  def bar(x int)
      ~~~
<stdin>:4:7: note: The previous declaration is here
  def bar(x int)
      ~~~
")

test("
def bar(x int) int
def bar(x double) double
def bar(x List<int>) List<int>

def main {
  var w bool = bar(null)
  var x bool = bar(0)
  var y bool = bar(0.5)
  var z bool = bar([])
}
", "
<stdin>:6:16: error: Cannot convert from type \"List<int>\" to type \"bool\"
  var w bool = bar(null)
               ~~~~~~~~~
<stdin>:7:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var x bool = bar(0)
               ~~~~~~
<stdin>:8:16: error: Cannot convert from type \"double\" to type \"bool\" without a cast
  var y bool = bar(0.5)
               ~~~~~~~~
<stdin>:9:16: error: Cannot convert from type \"List<int>\" to type \"bool\"
  var z bool = bar([])
               ~~~~~~~
")

test("
namespace Foo {
  def [new](x List<int>)
}

class Foo {}

def main(foo Foo) {
  foo = []
}
", "
<stdin>:8:9: error: The function \"[new]\" does not return a value
  foo = []
        ~~
")

test("
namespace Foo {
  def foo
  var bar = 0
}

class Foo<T> {
  def new
  def ifoo
  var ibar = 0
}

def main(foo Foo<int>) {
  foo.new
  Foo.new
  Foo<int>.new

  foo.foo
  Foo.foo
  Foo<int>.foo

  foo.bar = 0
  Foo.bar = 0
  Foo<int>.bar = 0

  foo.ifoo
  Foo.ifoo
  Foo<int>.ifoo

  foo.ibar = 0
  Foo.ibar = 0
  Foo<int>.ibar = 0
}
", "
<stdin>:13:7: error: Cannot access global member \"new\" from an instance context
  foo.new
      ~~~
<stdin>:14:3: error: Cannot use unparameterized type \"Foo\" here
  Foo.new
  ~~~
<stdin>:17:7: error: Cannot access global member \"foo\" from an instance context
  foo.foo
      ~~~
<stdin>:19:3: error: Cannot use parameterized type \"Foo<int>\" here
  Foo<int>.foo
  ~~~~~~~~
<stdin>:21:7: error: Cannot access global member \"bar\" from an instance context
  foo.bar = 0
      ~~~
<stdin>:23:3: error: Cannot use parameterized type \"Foo<int>\" here
  Foo<int>.bar = 0
  ~~~~~~~~
<stdin>:26:7: error: Cannot access instance member \"ifoo\" from a global context
  Foo.ifoo
      ~~~~
<stdin>:27:12: error: Cannot access instance member \"ifoo\" from a global context
  Foo<int>.ifoo
           ~~~~
<stdin>:30:7: error: Cannot access instance member \"ibar\" from a global context
  Foo.ibar = 0
      ~~~~
<stdin>:31:12: error: Cannot access instance member \"ibar\" from a global context
  Foo<int>.ibar = 0
           ~~~~
")

test("
class Foo : int {}
class Bar : fn() {}
class Baz : Baz {}
", "
<stdin>:1:13: error: Cannot derive from type \"int\"
class Foo : int {}
            ~~~
<stdin>:2:13: error: Cannot derive from type \"fn()\"
class Bar : fn() {}
            ~~~~
<stdin>:3:7: error: Cyclic declaration of \"Baz\"
class Baz : Baz {}
      ~~~
")

test("
class Foo { def foo }
class Bar : Foo { def bar }
class Baz : Foo { def baz }

def main(foo Foo, bar Bar, baz Baz) {
  foo.foo
  foo.bar
  bar.foo
  bar.bar
  baz.foo
  baz.bar
}
", "
<stdin>:7:7: error: \"bar\" is not declared on type \"Foo\"
  foo.bar
      ~~~
<stdin>:11:7: error: \"bar\" is not declared on type \"Baz\"
  baz.bar
      ~~~
")

test("
class Foo { def new }
class Bar : Foo { def new }
class Baz : Foo { def new }

def main {
  var a Foo = Foo.new
  var b Foo = Bar.new
  var c Foo = Baz.new
  var d Bar = Foo.new
  var e Bar = Bar.new
  var f Bar = Baz.new
}
", "
<stdin>:9:15: error: Cannot convert from type \"Foo\" to type \"Bar\" without a cast
  var d Bar = Foo.new
              ~~~~~~~
<stdin>:11:15: error: Cannot convert from type \"Baz\" to type \"Bar\"
  var f Bar = Baz.new
              ~~~~~~~
")

test("
class Foo<T> { def new }
class Bar : Foo<int> { def new }
class Baz : Foo<int> { def new }

def main {
  var foo = true ? Bar.new : Baz.new
  var bar int = foo
}
", "
<stdin>:7:17: error: Cannot convert from type \"Foo<int>\" to type \"int\"
  var bar int = foo
                ~~~
")

test("
class Foo<T> { def new }
class Bar : Foo<int> { def new }
class Baz : Foo<bool> { def new }

def main {
  var foo = true ? Bar.new : Baz.new
  var bar int = foo
}
", "
<stdin>:6:20: error: No common type for \"Bar\" and \"Baz\"
  var foo = true ? Bar.new : Baz.new
                   ~~~~~~~~~~~~~~~~~
")

test("
class Foo {
  @protected
  def foo

  @private
  def bar
}

class Bar : Foo {
  def baz {
    foo
    bar
    self.foo
    self.bar
  }
}

def main(foo Foo) {
  foo.foo
  foo.bar
}
", "
<stdin>:12:5: error: Cannot access \"@private\" symbol \"bar\" here
    bar
    ~~~
<stdin>:14:10: error: Cannot access \"@private\" symbol \"bar\" here
    self.bar
         ~~~
<stdin>:19:7: error: Cannot access \"@protected\" symbol \"foo\" here
  foo.foo
      ~~~
<stdin>:20:7: error: Cannot access \"@private\" symbol \"bar\" here
  foo.bar
      ~~~
")

test("
class Foo<A, B> {
  def foo(a A) Foo<A, B>
  def bar(b B) A
}

class Bar<T> : Foo<int, T> {
}

class Baz : Bar<bool> {
  def new
}

def foo string {
  return Baz.new.foo(0.5).bar(null)
}
", "
<stdin>:14:22: error: Cannot convert from type \"double\" to type \"int\" without a cast
  return Baz.new.foo(0.5).bar(null)
                     ~~~
<stdin>:14:31: error: Cannot convert from type \"null\" to type \"bool\"
  return Baz.new.foo(0.5).bar(null)
                              ~~~~
<stdin>:14:10: error: Cannot convert from type \"int\" to type \"string\"
  return Baz.new.foo(0.5).bar(null)
         ~~~~~~~~~~~~~~~~~~~~~~~~~~
")

test("
var a = 0 # a
var b = 0 # b
# comment
var c = 0 # c

# comment
var d = 0 # d
", "
")

test("
class Foo<T> {
  def foo(x T)
  def foo(x int)
}

def foo(foo Foo<bool>) {
  foo.foo(0)
  foo.foo(0.5)
  foo.foo(false)
}
", "
<stdin>:8:3: error: No overload of \"foo\" was found that takes 1 argument of type double
  foo.foo(0.5)
  ~~~~~~~
")

test("
class Foo {
  def +=(x int)
  def +=(x List<int>)
}

def foo(foo Foo) {
  foo += false
  foo += []
  foo += [false]
  foo += {}
  foo += {false}
}
", "
<stdin>:7:7: error: No overload of \"+=\" was found that takes 1 argument of type bool
  foo += false
      ~~
<stdin>:9:11: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  foo += [false]
          ~~~~~
<stdin>:10:10: error: Cannot infer a type for this literal
  foo += {}
         ~~
<stdin>:10:7: error: No overload of \"+=\" was found that takes 1 argument of type dynamic
  foo += {}
      ~~
<stdin>:11:10: error: Cannot infer a type for this literal
  foo += {false}
         ~~~~~~~
<stdin>:11:7: error: No overload of \"+=\" was found that takes 1 argument of type dynamic
  foo += {false}
      ~~
")

test("
class Foo {
  def +=(x dynamic)
  def +=(x List<int>)
}

def foo(foo Foo) {
  foo += false
  foo += [false]
}
", "
<stdin>:8:11: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  foo += [false]
          ~~~~~
")

test("
class Foo {
  def +=(x dynamic)
  def +=(x double)
}

def foo(foo Foo) {
  foo += 0
}
", "
<stdin>:7:7: error: Multiple matching overloads of \"+=\" were found that can take 1 argument of type int
  foo += 0
      ~~
")

test("
class Foo {
  def new
  def <=>(x Foo) int
}

var foo int = Foo.new < Foo.new
var bar bool = Foo.new <=> Foo.new
var baz int = 1 < 2
", "
<stdin>:6:15: error: Cannot convert from type \"bool\" to type \"int\" without a cast
var foo int = Foo.new < Foo.new
              ~~~~~~~~~~~~~~~~~
<stdin>:7:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
var bar bool = Foo.new <=> Foo.new
               ~~~~~~~~~~~~~~~~~~~
<stdin>:8:15: error: Cannot convert from type \"bool\" to type \"int\" without a cast
var baz int = 1 < 2
              ~~~~~
")

test("
def main(x List<List<int>>) {
  var foo = [false] in x
}
", "
<stdin>:2:14: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  var foo = [false] in x
             ~~~~~
")

test("
def main {
  for i in 0..10 {
    0 += 1
    0 = 1
    i += 1
    i = 1
  }
}
", "
<stdin>:3:5: error: Cannot store to this location
    0 += 1
    ^
<stdin>:4:5: error: Cannot store to this location
    0 = 1
    ^
<stdin>:5:5: error: Cannot store to constant symbol \"i\"
    i += 1
    ^
<stdin>:6:5: error: Cannot store to constant symbol \"i\"
    i = 1
    ^
")

  }
}
