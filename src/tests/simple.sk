namespace tests {
  void testSimple() {

test("
class Foo<T> {
  def foo T
}

class Bar<T> {
  def bar T
}

def main {
  var x Foo<Bar<Foo<int>>>
  var a bool = x
  var b bool = x.foo
  var c bool = x.foo.bar
  var d bool = x.foo.bar.foo
}
", "
<stdin>:11:16: error: Cannot convert from type \"Foo<Bar<Foo<int>>>\" to type \"bool\"
  var a bool = x
               ^
<stdin>:12:16: error: Cannot convert from type \"Bar<Foo<int>>\" to type \"bool\"
  var b bool = x.foo
               ~~~~~
<stdin>:13:16: error: Cannot convert from type \"Foo<int>\" to type \"bool\"
  var c bool = x.foo.bar
               ~~~~~~~~~
<stdin>:14:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  var d bool = x.foo.bar.foo
               ~~~~~~~~~~~~~
")

test("
class Foo {
  def new
}

def main {
  Foo.new[ ]= false
  Foo.new[] = false
  Foo.new[]= false
}
", "
<stdin>:6:10: error: \"[]=\" is not declared on type \"Foo\"
  Foo.new[ ]= false
         ~~~~~~~~~~
<stdin>:7:10: error: \"[]=\" is not declared on type \"Foo\"
  Foo.new[] = false
         ~~~~~~~~~~
<stdin>:8:10: error: \"[]=\" is not declared on type \"Foo\"
  Foo.new[]= false
         ~~~~~~~~~
")

test("
class Foo {
  def new {}
}

namespace Foo {
  def new(x int) Foo {
    return new
  }
}

def main {
  Foo.new
  Foo.new(100)
}
", "
")

test("
class Foo<T> {
  def size int
  def pop T
  def shift T
  def push(value T)
  def unshift(value T)
  def map<R>(callback fn(T) R) Foo<R>
  def filter(callback fn(T) bool) Foo<T>
}

def main {
  var x Foo<int>
  x.push(x.size)
  x.filter(1.0)
  x.map(1.0)
  x.map<string>(1.0)
  x.filter(x => x + 100)
  x.map(x => x + 100)
  var y int = x.map<string>(1.0)
}
", "
<stdin>:14:12: error: Cannot convert from type \"double\" to type \"fn(int) bool\"
  x.filter(1.0)
           ~~~
<stdin>:15:3: error: Cannot use unparameterized type \"map\"
  x.map(1.0)
  ~~~~~
<stdin>:16:17: error: Cannot convert from type \"double\" to type \"fn(int) string\"
  x.map<string>(1.0)
                ~~~
<stdin>:17:17: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  x.filter(x => x + 100)
                ~~~~~~~
<stdin>:18:3: error: Cannot use unparameterized type \"map\"
  x.map(x => x + 100)
  ~~~~~
<stdin>:18:9: error: Unable to determine the type of \"x\"
  x.map(x => x + 100)
        ^
<stdin>:19:29: error: Cannot convert from type \"double\" to type \"fn(int) string\"
  var y int = x.map<string>(1.0)
                            ~~~
<stdin>:19:15: error: Cannot convert from type \"Foo<int>\" to type \"int\"
  var y int = x.map<string>(1.0)
              ~~~~~~~~~~~~~~~~~~
")

test("
class Foo {
  def new
  def foo<T>(t T) Foo
}

def main {
  Foo.new.foo(0).foo(0.0)
  Foo.new.foo<bool>(0).foo<int>(0.0)
}
", "
<stdin>:7:3: error: Cannot use unparameterized type \"foo\"
  Foo.new.foo(0).foo(0.0)
  ~~~~~~~~~~~
<stdin>:8:21: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  Foo.new.foo<bool>(0).foo<int>(0.0)
                    ^
<stdin>:8:33: error: Cannot convert from type \"double\" to type \"int\" without a cast
  Foo.new.foo<bool>(0).foo<int>(0.0)
                                ~~~
")

test("
class Foo<T> {
  def new
}

def main {
  var x int = Foo.new
  var y int = Foo<int>.new
}
", "
<stdin>:6:15: error: Cannot use unparameterized type \"Foo\"
  var x int = Foo.new
              ~~~
<stdin>:7:15: error: Cannot convert from type \"Foo<int>\" to type \"int\"
  var y int = Foo<int>.new
              ~~~~~~~~~~~~
")

test("
class Foo {
  def new
  def foo Foo
  def bar
}

def main {
  var x int = => Foo.new
  var y int = => Foo.new.foo
  var z int = => Foo.new.bar
}
", "
<stdin>:8:15: error: Cannot convert from type \"fn() Foo\" to type \"int\"
  var x int = => Foo.new
              ~~~~~~~~~~
<stdin>:9:15: error: Cannot convert from type \"fn() Foo\" to type \"int\"
  var y int = => Foo.new.foo
              ~~~~~~~~~~~~~~
<stdin>:10:15: error: Cannot convert from type \"fn()\" to type \"int\"
  var z int = => Foo.new.bar
              ~~~~~~~~~~~~~~
")

test("
def main(x int) {
  main
  x
  x + 1
  x ? x : x
}
", "
<stdin>:2:3: warning: Unused expression
  main
  ~~~~
<stdin>:3:3: warning: Unused expression
  x
  ^
<stdin>:4:3: warning: Unused expression
  x + 1
  ~~~~~
<stdin>:5:3: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  x ? x : x
  ^
<stdin>:5:7: warning: Unused expression
  x ? x : x
      ^
<stdin>:5:11: warning: Unused expression
  x ? x : x
          ^
")

test("
def main {
  bar(x => foo(x))
  bar(x => x + 1)
  bar(x => x)
}

def foo(x int) int {
  return 0
}

def bar(x fn(int)) {
}
", "
<stdin>:3:12: warning: Unused expression
  bar(x => x + 1)
           ~~~~~
<stdin>:4:12: warning: Unused expression
  bar(x => x)
           ^
")

test("
def main {
  var x = null
  var y = => null
}
", "
<stdin>:2:7: error: Implicitly typed variables cannot be of type \"null\"
  var x = null
      ^
<stdin>:3:14: error: Cannot create a function with a return type of \"null\"
  var y = => null
             ~~~~
")

test("
def main {
  var a = => 0
  var b = => {}
  var c = () => 0
  var d = () => {}
  var e = () int => 0
  var f = () int => { return 0 }
  var g fn(int) = x => 0
  var h fn(int) = x => {}
  var i fn(int) int = (x) => 0
  var j fn(int) int = (x) => { return 0 }
  var k = (x int) => 0
  var l = (x int) => {}
  var m = (x int) int => 0
  var n = (x int) int => { return 0 }
}
", "
<stdin>:8:24: warning: Unused expression
  var g fn(int) = x => 0
                       ^
")

test("
class Foo<T> {
  def new
}

def main {
  var foo Foo<int> = Foo<int>.new
  var bar Foo<bool> = Foo<int>.new
}
", "
<stdin>:7:23: error: Cannot convert from type \"Foo<int>\" to type \"Foo<bool>\"
  var bar Foo<bool> = Foo<int>.new
                      ~~~~~~~~~~~~
")

test("
class Foo {
  def in(x int) bool
}

def main(foo Foo) {
  false in foo
  0 in foo
  not (0 in foo)
  0 not in foo
}
", "
<stdin>:8:10: warning: The \"not in\" operator is preferred over nesting \"in\" inside \"not\"
  not (0 in foo)
         ~~
<stdin>:6:3: error: Cannot convert from type \"bool\" to type \"int\" without a cast
  false in foo
  ~~~~~
<stdin>:8:3: warning: Unused expression
  not (0 in foo)
  ~~~~~~~~~~~~~~
<stdin>:9:3: warning: Unused expression
  0 not in foo
  ~~~~~~~~~~~~
")

test("
namespace foo {
  namespace bar {
    def @baz
  }
}

@foo.bar.bax
@foo.bar.baz
def main
", "
<stdin>:7:10: error: \"@bax\" is not declared on type \"bar\"
@foo.bar.bax
         ~~~
")

test("
def @foo(x int)
def @bar

@foo
@foo(1, 2)
@bar(1)
def main
", "
<stdin>:4:1: error: Expected 1 argument but found 0 arguments
@foo
~~~~
<stdin>:5:5: error: Expected 1 argument but found 2 arguments
@foo(1, 2)
    ~~~~~~
<stdin>:6:5: error: The function \"@bar\" takes no arguments and is already called implicitly
@bar(1)
    ~~~
")

// These shouldn't cause missing newline errors
test("
def @foo

class foo {
  def -
  def new
}

class bar {
  def -

  @foo
  def new
}

class baz {
  def -

  # foo
  def new
}

def main bool {
  return 1 -
    1
}
", "
<stdin>:23:10: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  return 1 -
         ~~~
")

test("
class Foo {
  def foo {
    var self int
  }

  def bar(self int) {
  }

  def baz {
    if true {
      var self int
    }
  }
}
", "
<stdin>:3:9: error: \"self\" is already declared
    var self int
        ~~~~
<stdin>:6:11: error: \"self\" is already declared
  def bar(self int) {
          ~~~~
<stdin>:11:11: error: \"self\" shadows a previous declaration
      var self int
          ~~~~
")

test("
namespace a {
  class Foo.Bar {}
  class Foo.Baz {}
  class Foo {}
  def main(foo Foo.Bar, bar Foo.Baz) {}
}
namespace b {
  class Foo {
    class Bar {}
    class Baz {}
  }
  def main(foo Foo.Bar, bar Foo.Baz) {}
}
", "
")

test("
class ns1.Foo {}
var ns1 int
var ns2 int
class ns2.Foo {}
", "
<stdin>:2:5: error: \"ns1\" is already declared
var ns1 int
    ~~~
<stdin>:1:7: note: The previous declaration is here
class ns1.Foo {}
      ~~~
<stdin>:3:5: error: \"ns2\" is already declared
var ns2 int
    ~~~
<stdin>:4:7: note: The previous declaration is here
class ns2.Foo {}
      ~~~
")

test("
var ns.foo int
", "
<stdin>:1:7: error: Expected NEWLINE but found DOT
var ns.foo int
      ^
")

test("
def ns.foo int
", "
<stdin>:1:7: error: Expected NEWLINE but found DOT
def ns.foo int
      ^
")

test("
@skip
var a int

@skip {
  var x int
  var y int
}

@skip
@skip
def b

@skip
@skip {
  def c
}
", "
<stdin>:10:1: error: Duplicate annotation \"@skip\" on \"b\"
@skip
~~~~~
<stdin>:14:1: error: Duplicate annotation \"@skip\" on \"c\"
@skip {
~~~~~
<stdin>:1:1: error: Cannot use the annotation \"@skip\" on \"a\"
@skip
~~~~~
<stdin>:4:1: error: Cannot use the annotation \"@skip\" on \"x\"
@skip {
~~~~~
<stdin>:4:1: error: Cannot use the annotation \"@skip\" on \"y\"
@skip {
~~~~~
")

test("
class Foo {
  const a
  const b int
  const c = 0
  const d bool = 0
}

@import
class Bar {
  const a
  const b int
  const c = 0
  const d bool = 0
}

const a
const b int
const c = 0
const d bool = 0

@import {
  const w
  const x int
  const y = 0
  const z bool = 0
}
", "
<stdin>:2:9: error: Unable to determine the type of \"a\"
  const a
        ^
<stdin>:3:9: error: The constant \"b\" must be initialized
  const b int
        ^
<stdin>:5:18: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  const d bool = 0
                 ^
<stdin>:10:9: error: Unable to determine the type of \"a\"
  const a
        ^
<stdin>:13:18: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  const d bool = 0
                 ^
<stdin>:16:7: error: Unable to determine the type of \"a\"
const a
      ^
<stdin>:17:7: error: The constant \"b\" must be initialized
const b int
      ^
<stdin>:19:16: error: Cannot convert from type \"int\" to type \"bool\" without a cast
const d bool = 0
               ^
<stdin>:22:9: error: Unable to determine the type of \"w\"
  const w
        ^
<stdin>:25:18: error: Cannot convert from type \"int\" to type \"bool\" without a cast
  const z bool = 0
                 ^
")

test("
const a = 0
var b = 0

class Foo {
  const x = 0
}

def main(foo Foo) {
  const y = 0
  a = 0
  b = 0
  foo.x = 0
  y = 0
}
", "
<stdin>:10:3: error: Cannot store to constant symbol \"a\"
  a = 0
  ^
<stdin>:12:7: error: Cannot store to constant symbol \"x\"
  foo.x = 0
      ^
<stdin>:13:3: error: Cannot store to constant symbol \"y\"
  y = 0
  ^
")

test("
@private
class Foo {
  @private
  var x int

  @private
  def foo {
    x = 0
    foo
    var y = => x
  }

  @private
  class Bar {}

  var bar Bar
}

@private
def main(foo Foo) {
  foo.x = 0
  foo.foo
  var x = => foo.x
  var y = => foo.foo
  var z Foo.Bar
}
", "
<stdin>:1:1: error: Cannot use the annotation \"@private\" on \"Foo\"
@private
~~~~~~~~
<stdin>:19:1: error: Cannot use the annotation \"@private\" on \"main\"
@private
~~~~~~~~
<stdin>:21:7: error: Cannot access \"@private\" symbol \"x\" here
  foo.x = 0
      ^
<stdin>:22:7: error: Cannot access \"@private\" symbol \"foo\" here
  foo.foo
      ~~~
<stdin>:23:18: error: Cannot access \"@private\" symbol \"x\" here
  var x = => foo.x
                 ^
<stdin>:24:18: error: Cannot access \"@private\" symbol \"foo\" here
  var y = => foo.foo
                 ~~~
<stdin>:25:13: error: Cannot access \"@private\" symbol \"Bar\" here
  var z Foo.Bar
            ~~~

")

test("
class bool {
  def +(x int, y int)
  def -(x int, y int) {}
}

def main {
  false + false
  false - false
}
", "
<stdin>:7:9: error: Expected 2 arguments but found 1 argument
  false + false
        ^
<stdin>:8:9: error: Expected 2 arguments but found 1 argument
  false - false
        ^
")

test("
class bool {
  def +(x bool)
  def -(x bool) {}
}

def main {
  false + false + false
  false - false - false
}
", "
<stdin>:7:3: error: The function \"+\" does not return a value
  false + false + false
  ~~~~~~~~~~~~~
<stdin>:8:3: error: The function \"-\" does not return a value
  false - false - false
  ~~~~~~~~~~~~~
")

test("
def main {
  0 + 0
  0 + 0.5
  0.5 + 0
  0.5 + 0.5
}
", "
<stdin>:2:3: warning: Unused expression
  0 + 0
  ~~~~~
<stdin>:3:3: warning: Unused expression
  0 + 0.5
  ~~~~~~~
<stdin>:4:3: warning: Unused expression
  0.5 + 0
  ~~~~~~~
<stdin>:5:3: warning: Unused expression
  0.5 + 0.5
  ~~~~~~~~~
")

  }
}
