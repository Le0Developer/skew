diff --git a/src/core/node.sk b/src/core/node.sk
index a7e0b22..64d1ad0 100644
--- a/src/core/node.sk
+++ b/src/core/node.sk
@@ -38,6 +38,7 @@ namespace astral {
     BITWISE_AND
     BITWISE_OR
     BITWISE_XOR
+    COMPARE
     DIVIDE
     EQUAL
     GREATER_THAN
@@ -85,6 +86,10 @@ namespace astral {
     bool isBinary() {
       return this >= ADD && this <= ASSIGN_SUBTRACT
     }
+
+    bool isBinaryComparison() {
+      return this >= GREATER_THAN && this <= LESS_THAN_OR_EQUAL
+    }
   }
 
   // Nodes represent executable code (variable initializers and function bodies)
@@ -98,6 +103,11 @@ namespace astral {
     Type resolvedType = null
     List<Node> children = []
 
+    Node withType(Type value) {
+      resolvedType = value
+      return this
+    }
+
     Node withSymbol(Symbol value) {
       symbol = value
       return this
@@ -144,9 +154,7 @@ namespace astral {
     Node removeChildAtIndex(int index) {
       assert index >= 0 && index < children.size()
       var child = children[index]
-      if (child != null) {
-        child.parent = null
-      }
+      updateParent(child, null)
       children.removeAt(index)
       return child
     }
@@ -156,13 +164,20 @@ namespace astral {
       return this
     }
 
+    List<Node> removeChildren() {
+      var result = children
+      for (var i = 0; i < children.size(); i++) {
+        updateParent(children[i], null)
+      }
+      children = []
+      return result
+    }
+
     Node replaceChild(int index, Node node) {
       assert index >= 0 && index < children.size()
       updateParent(node, this)
       var child = children[index]
-      if (child != null) {
-        child.parent = null
-      }
+      updateParent(child, null)
       children[index] = node
       return child
     }
@@ -172,14 +187,9 @@ namespace astral {
       return this
     }
 
-    string asString() {
-      assert kind == .NAME || kind == .DOT
-      return content.asString()
-    }
-
     private static void updateParent(Node node, Node parent) {
       if (node != null) {
-        assert node.parent == null
+        assert (node.parent == null) != (parent == null)
         node.parent = parent
       }
     }
@@ -324,6 +334,11 @@ namespace astral {
 
   // Getters
   in Node {
+    string asString() {
+      assert kind == .NAME || kind == .DOT
+      return content.asString()
+    }
+
     Node dotTarget() {
       assert kind == .DOT
       assert children.size() == 1
@@ -352,6 +367,13 @@ namespace astral {
       return children[0]
     }
 
+    Node indexValue() {
+      assert kind == .INDEX
+      assert children.size() >= 1
+      assert children[0].kind.isExpression()
+      return children[0]
+    }
+
     Node castValue() {
       assert kind == .CAST
       assert children.size() == 2
diff --git a/src/frontend/flex.l b/src/frontend/flex.l
index 6f6b7da..7911170 100644
--- a/src/frontend/flex.l
+++ b/src/frontend/flex.l
@@ -64,6 +64,7 @@
 ">>"                              SHIFT_RIGHT;
 "!="                              NOT_EQUAL;
 "=="                              EQUAL;
+"<=>"                             COMPARE;
 "<="                              LESS_THAN_OR_EQUAL;
 ">="                              GREATER_THAN_OR_EQUAL;
 "<"                               LESS_THAN;
diff --git a/src/frontend/lexer.sk b/src/frontend/lexer.sk
index 1f000eb..08bdbed 100644
--- a/src/frontend/lexer.sk
+++ b/src/frontend/lexer.sk
@@ -30,6 +30,7 @@ namespace astral {
     COLON
     COMMA
     COMMENT
+    COMPARE
     CONTINUE
     DEF
     DIVIDE
@@ -86,13 +87,13 @@ namespace astral {
     END_PARAMETER_LIST
   }
 
-  final List<TokenKind> yy_accept = [.YY_INVALID_ACTION, .YY_INVALID_ACTION, .YY_INVALID_ACTION, .END_OF_FILE, .ERROR, .WHITESPACE, .NEWLINE, .NOT, .ERROR, .REMAINDER, .BITWISE_AND, .ERROR, .LEFT_PARENTHESIS, .RIGHT_PARENTHESIS, .MULTIPLY, .PLUS, .COMMA, .MINUS, .DOT, .DIVIDE, .INT, .COLON, .LESS_THAN, .ASSIGN, .GREATER_THAN, .QUESTION_MARK, .IDENTIFIER, .LEFT_BRACKET, .RIGHT_BRACKET, .BITWISE_XOR, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .LEFT_BRACE, .BITWISE_OR, .RIGHT_BRACE, .TILDE, .WHITESPACE, .NEWLINE, .NOT_EQUAL, .YY_INVALID_ACTION, .STRING, .YY_INVALID_ACTION, .ASSIGN_REMAINDER, .LOGICAL_AND, .ASSIGN_BITWISE_AND, .YY_INVALID_ACTION, .CHARACTER, .YY_INVALID_ACTION, .POWER, .ASSIGN_MULTIPLY, .ASSIGN_PLUS, .ASSIGN_MINUS, .YY_INVALID_ACTION, .COMMENT, .ASSIGN_DIVIDE, .YY_INVALID_ACTION, .INT, .SHIFT_LEFT, .LESS_THAN_OR_EQUAL, .EQUAL, .ARROW, .GREATER_THAN_OR_EQUAL, .SHIFT_RIGHT, .IDENTIFIER, .INDEX, .ASSIGN_BITWISE_XOR, .AS, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IF, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .ASSIGN_BITWISE_OR, .LOGICAL_OR, .ASSIGN_POWER, .YY_INVALID_ACTION, .YY_INVALID_ACTION, .YY_INVALID_ACTION, .COMMENT, .COMMENT, .DOUBLE, .ASSIGN_SHIFT_LEFT, .ASSIGN_SHIFT_RIGHT, .ASSIGN_INDEX, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .DEF, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .VAR, .IDENTIFIER, .WHITESPACE, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .ELSE, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .NULL, .IDENTIFIER, .IDENTIFIER, .TRUE, .IDENTIFIER, .BREAK, .CLASS, .IDENTIFIER, .IDENTIFIER, .FALSE, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .SUPER, .WHILE, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .RETURN, .IDENTIFIER, .DYNAMIC, .IDENTIFIER, .IDENTIFIER, .CONTINUE, .IDENTIFIER, .IDENTIFIER, .INTERFACE, .NAMESPACE, .YY_INVALID_ACTION]
+  final List<TokenKind> yy_accept = [.YY_INVALID_ACTION, .YY_INVALID_ACTION, .YY_INVALID_ACTION, .END_OF_FILE, .ERROR, .WHITESPACE, .NEWLINE, .NOT, .ERROR, .REMAINDER, .BITWISE_AND, .ERROR, .LEFT_PARENTHESIS, .RIGHT_PARENTHESIS, .MULTIPLY, .PLUS, .COMMA, .MINUS, .DOT, .DIVIDE, .INT, .COLON, .LESS_THAN, .ASSIGN, .GREATER_THAN, .QUESTION_MARK, .IDENTIFIER, .LEFT_BRACKET, .RIGHT_BRACKET, .BITWISE_XOR, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .LEFT_BRACE, .BITWISE_OR, .RIGHT_BRACE, .TILDE, .WHITESPACE, .NEWLINE, .NOT_EQUAL, .YY_INVALID_ACTION, .STRING, .YY_INVALID_ACTION, .ASSIGN_REMAINDER, .LOGICAL_AND, .ASSIGN_BITWISE_AND, .YY_INVALID_ACTION, .CHARACTER, .YY_INVALID_ACTION, .POWER, .ASSIGN_MULTIPLY, .ASSIGN_PLUS, .ASSIGN_MINUS, .YY_INVALID_ACTION, .COMMENT, .ASSIGN_DIVIDE, .YY_INVALID_ACTION, .INT, .SHIFT_LEFT, .LESS_THAN_OR_EQUAL, .EQUAL, .ARROW, .GREATER_THAN_OR_EQUAL, .SHIFT_RIGHT, .IDENTIFIER, .INDEX, .ASSIGN_BITWISE_XOR, .AS, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IF, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .ASSIGN_BITWISE_OR, .LOGICAL_OR, .ASSIGN_POWER, .YY_INVALID_ACTION, .YY_INVALID_ACTION, .YY_INVALID_ACTION, .COMMENT, .COMMENT, .DOUBLE, .ASSIGN_SHIFT_LEFT, .COMPARE, .ASSIGN_SHIFT_RIGHT, .ASSIGN_INDEX, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .DEF, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .VAR, .IDENTIFIER, .WHITESPACE, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .ELSE, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .NULL, .IDENTIFIER, .IDENTIFIER, .TRUE, .IDENTIFIER, .BREAK, .CLASS, .IDENTIFIER, .IDENTIFIER, .FALSE, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .SUPER, .WHILE, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .IDENTIFIER, .RETURN, .IDENTIFIER, .DYNAMIC, .IDENTIFIER, .IDENTIFIER, .CONTINUE, .IDENTIFIER, .IDENTIFIER, .INTERFACE, .NAMESPACE, .YY_INVALID_ACTION]
   final var yy_ec = [0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 4, 5, 1, 1, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 18, 1, 19, 20, 21, 22, 1, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 25, 26, 27, 23, 1, 28, 29, 30, 31, 32, 33, 23, 34, 35, 23, 36, 37, 38, 39, 40, 41, 23, 42, 43, 44, 45, 46, 47, 23, 48, 23, 49, 50, 51, 52, 1]
   final var yy_meta = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1]
-  final var yy_base = [0, 0, 0, 190, 191, 187, 51, 168, 50, 167, 49, 49, 191, 191, 47, 166, 191, 165, 191, 48, 45, 191, 46, 50, 52, 191, 0, 158, 191, 163, 139, 139, 39, 29, 143, 151, 45, 35, 146, 132, 134, 147, 140, 191, 61, 191, 191, 171, 80, 191, 80, 191, 169, 191, 191, 191, 78, 191, 168, 150, 191, 191, 191, 76, 166, 191, 151, 73, 147, 191, 191, 191, 191, 146, 0, 145, 191, 0, 132, 135, 123, 128, 121, 116, 121, 0, 113, 118, 118, 110, 112, 107, 109, 115, 191, 191, 191, 78, 80, 82, 146, 191, 131, 191, 191, 191, 119, 103, 101, 0, 116, 111, 99, 109, 108, 102, 93, 105, 104, 0, 98, 191, 98, 90, 97, 93, 0, 98, 87, 85, 0, 85, 84, 0, 93, 0, 0, 85, 88, 0, 89, 69, 70, 0, 0, 63, 77, 78, 76, 0, 70, 0, 71, 70, 0, 67, 65, 0, 0, 191, 111, 113, 93, 115, 117, 119]
-  final var yy_def = [0, 159, 1, 159, 159, 159, 159, 159, 160, 159, 159, 161, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 162, 159, 159, 159, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 159, 159, 159, 159, 159, 159, 159, 160, 159, 160, 159, 159, 159, 161, 159, 161, 159, 159, 159, 159, 163, 164, 159, 159, 159, 159, 159, 159, 159, 159, 159, 162, 159, 159, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 159, 159, 159, 163, 165, 163, 164, 159, 159, 159, 159, 159, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 159, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 162, 0, 159, 159, 159, 159, 159, 159]
-  final var yy_nxt = [0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 4, 28, 29, 30, 31, 32, 33, 34, 35, 26, 36, 26, 26, 26, 37, 26, 26, 38, 39, 40, 26, 41, 42, 26, 43, 44, 45, 46, 48, 48, 51, 54, 57, 59, 63, 66, 81, 67, 87, 64, 68, 69, 60, 65, 55, 70, 71, 72, 73, 58, 52, 79, 82, 85, 80, 88, 94, 48, 48, 86, 51, 57, 98, 66, 98, 67, 98, 99, 98, 99, 74, 121, 158, 99, 157, 156, 155, 154, 58, 153, 52, 152, 151, 150, 149, 148, 95, 50, 50, 56, 56, 97, 97, 100, 100, 99, 99, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 102, 101, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 96, 159, 159, 47, 93, 92, 91, 90, 89, 84, 83, 78, 77, 76, 75, 62, 61, 53, 49, 47, 159, 3, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159]
-  final var yy_chk = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 8, 10, 11, 14, 19, 20, 33, 20, 37, 19, 22, 22, 14, 19, 10, 23, 23, 24, 24, 11, 8, 32, 33, 36, 32, 37, 44, 48, 48, 36, 50, 56, 63, 67, 97, 67, 98, 63, 99, 97, 162, 98, 156, 99, 155, 153, 152, 150, 56, 148, 50, 147, 146, 145, 142, 141, 44, 160, 160, 161, 161, 163, 163, 164, 164, 165, 165, 140, 138, 137, 134, 132, 131, 129, 128, 127, 125, 124, 123, 122, 120, 118, 117, 116, 115, 114, 113, 112, 111, 110, 108, 107, 106, 102, 100, 93, 92, 91, 90, 89, 88, 87, 86, 84, 83, 82, 81, 80, 79, 78, 75, 73, 68, 66, 64, 59, 58, 52, 47, 42, 41, 40, 39, 38, 35, 34, 31, 30, 29, 27, 17, 15, 9, 7, 5, 3, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159, 159]
+  final var yy_base = [0, 0, 0, 191, 192, 188, 51, 169, 50, 168, 49, 49, 192, 192, 47, 167, 192, 166, 192, 48, 45, 192, 46, 50, 52, 192, 0, 159, 192, 164, 140, 140, 39, 29, 144, 152, 45, 35, 147, 133, 135, 148, 141, 192, 61, 192, 192, 172, 80, 192, 80, 192, 170, 192, 192, 192, 78, 192, 169, 151, 192, 192, 192, 76, 167, 192, 152, 73, 148, 146, 192, 192, 192, 146, 0, 145, 192, 0, 132, 135, 123, 128, 121, 116, 121, 0, 113, 118, 118, 110, 112, 107, 109, 115, 192, 192, 192, 78, 80, 82, 146, 192, 131, 192, 192, 192, 192, 119, 103, 101, 0, 116, 111, 99, 109, 108, 102, 93, 105, 104, 0, 98, 192, 98, 90, 97, 93, 0, 98, 87, 85, 0, 85, 84, 0, 93, 0, 0, 85, 88, 0, 89, 69, 70, 0, 0, 63, 77, 78, 76, 0, 70, 0, 71, 70, 0, 67, 65, 0, 0, 192, 111, 113, 93, 115, 117, 119]
+  final var yy_def = [0, 160, 1, 160, 160, 160, 160, 160, 161, 160, 160, 162, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 163, 160, 160, 160, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 160, 160, 160, 160, 160, 160, 160, 161, 160, 161, 160, 160, 160, 162, 160, 162, 160, 160, 160, 160, 164, 165, 160, 160, 160, 160, 160, 160, 160, 160, 160, 163, 160, 160, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 160, 160, 160, 164, 166, 164, 165, 160, 160, 160, 160, 160, 160, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 160, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 163, 0, 160, 160, 160, 160, 160, 160]
+  final var yy_nxt = [0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 4, 28, 29, 30, 31, 32, 33, 34, 35, 26, 36, 26, 26, 26, 37, 26, 26, 38, 39, 40, 26, 41, 42, 26, 43, 44, 45, 46, 48, 48, 51, 54, 57, 59, 63, 66, 81, 67, 87, 64, 68, 69, 60, 65, 55, 70, 71, 72, 73, 58, 52, 79, 82, 85, 80, 88, 94, 48, 48, 86, 51, 57, 98, 66, 98, 67, 98, 99, 98, 99, 74, 122, 159, 99, 158, 157, 156, 155, 58, 154, 52, 153, 152, 151, 150, 149, 95, 50, 50, 56, 56, 97, 97, 100, 100, 99, 99, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 102, 101, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 96, 160, 160, 47, 93, 92, 91, 90, 89, 84, 83, 78, 77, 76, 75, 62, 61, 53, 49, 47, 160, 3, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160]
+  final var yy_chk = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 6, 6, 8, 10, 11, 14, 19, 20, 33, 20, 37, 19, 22, 22, 14, 19, 10, 23, 23, 24, 24, 11, 8, 32, 33, 36, 32, 37, 44, 48, 48, 36, 50, 56, 63, 67, 97, 67, 98, 63, 99, 97, 163, 98, 157, 99, 156, 154, 153, 151, 56, 149, 50, 148, 147, 146, 143, 142, 44, 161, 161, 162, 162, 164, 164, 165, 165, 166, 166, 141, 139, 138, 135, 133, 132, 130, 129, 128, 126, 125, 124, 123, 121, 119, 118, 117, 116, 115, 114, 113, 112, 111, 109, 108, 107, 102, 100, 93, 92, 91, 90, 89, 88, 87, 86, 84, 83, 82, 81, 80, 79, 78, 75, 73, 69, 68, 66, 64, 59, 58, 52, 47, 42, 41, 40, 39, 38, 35, 34, 31, 30, 29, 27, 17, 15, 9, 7, 5, 3, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160, 160]
 
   // This is the inner loop from "flex", an ancient lexer generator. The output
   // of flex is pretty bad (obfuscated variable names and the opposite of modular
@@ -115,7 +116,7 @@ namespace astral {
       var yy_bp = yy_cp // The pointer to the beginning of the token
 
       // Search for a match
-      while (yy_current_state != 159) {
+      while (yy_current_state != 160) {
         if (yy_cp >= text_length) {
           break // This prevents syntax errors from causing infinite loops
         }
@@ -128,7 +129,7 @@ namespace astral {
         }
         while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
           yy_current_state = yy_def[yy_current_state]
-          if (yy_current_state >= 160) {
+          if (yy_current_state >= 161) {
             yy_c = yy_meta[yy_c]
           }
         }
diff --git a/src/frontend/log.sk b/src/frontend/log.sk
index 461b87b..f981b6e 100644
--- a/src/frontend/log.sk
+++ b/src/frontend/log.sk
@@ -174,5 +174,9 @@ namespace astral {
     void semanticErrorAmbiguousOperator(Range range, string name, int count) {
       error(range, "Multiple matching overloads of \"" + name + "\" were found that take " + count + " argument" + prettyPrint.plural(count))
     }
+
+    void semanticErrorComparisonOperatorNotInt(Range range) {
+      error(range, "The comparison operator must have return type of \"int\"")
+    }
   }
 }
diff --git a/src/frontend/parser.sk b/src/frontend/parser.sk
index 9d15549..9db6194 100644
--- a/src/frontend/parser.sk
+++ b/src/frontend/parser.sk
@@ -276,6 +276,7 @@ namespace astral {
     TokenKind.BITWISE_AND: 0,
     TokenKind.BITWISE_OR: 0,
     TokenKind.BITWISE_XOR: 0,
+    TokenKind.COMPARE: 0,
     TokenKind.DIVIDE: 0,
     TokenKind.INDEX: 0,
     TokenKind.MINUS: 0,
@@ -807,6 +808,7 @@ namespace astral {
 
     pratt.infix(.BITWISE_OR, .BITWISE_OR, BinaryInfix(.BITWISE_OR))
     pratt.infix(.BITWISE_XOR, .BITWISE_XOR, BinaryInfix(.BITWISE_XOR))
+    pratt.infix(.COMPARE, .COMPARE, BinaryInfix(.COMPARE))
     pratt.infix(.DIVIDE, .MULTIPLY, BinaryInfix(.DIVIDE))
     pratt.infix(.EQUAL, .EQUAL, BinaryInfix(.EQUAL))
     pratt.infix(.GREATER_THAN, .COMPARE, BinaryInfix(.GREATER_THAN))
diff --git a/src/middle/resolving.sk b/src/middle/resolving.sk
index f9a4577..deca81f 100644
--- a/src/middle/resolving.sk
+++ b/src/middle/resolving.sk
@@ -133,6 +133,18 @@ namespace astral.resolving {
           resolveNode(symbol.returnType, symbol.scope)
         }
       }
+
+      // The "<=>" operator must return "int" to ensure that there aren't any
+      // infinite expansion loops during resolving
+      if (symbol.name == "<=>") {
+        if (symbol.returnType == null) {
+          log.semanticErrorComparisonOperatorNotInt(symbol.range)
+          symbol.returnType = Node.createDynamic().withType(.DYNAMIC)
+        } else if (symbol.returnType.resolvedType != cache.intType) {
+          log.semanticErrorComparisonOperatorNotInt(symbol.returnType.range)
+          symbol.returnType.resolvedType = .DYNAMIC
+        }
+      }
     }
 
     void resolveFunction(FunctionSymbol symbol) {
@@ -290,11 +302,6 @@ namespace astral.resolving {
       resolveNode(node.whileBlock(), scope)
     }
 
-    void resolveIndex(Node node, Scope scope) {
-      resolveChildren(node, scope)
-      resolveOperatorOverload(node, scope)
-    }
-
     void resolveCall(Node node, Scope scope) {
       var value = node.callValue()
       resolveNode(value, scope)
@@ -504,8 +511,13 @@ namespace astral.resolving {
       NodeKind.BITWISE_AND: "&",
       NodeKind.BITWISE_OR: "|",
       NodeKind.BITWISE_XOR: "^",
+      NodeKind.COMPARE: "<=>",
       NodeKind.DIVIDE: "/",
+      NodeKind.GREATER_THAN: "<=>",
+      NodeKind.GREATER_THAN_OR_EQUAL: "<=>",
       NodeKind.INDEX: "[]",
+      NodeKind.LESS_THAN: "<=>",
+      NodeKind.LESS_THAN_OR_EQUAL: "<=>",
       NodeKind.MULTIPLY: "*",
       NodeKind.NEGATIVE: "-",
       NodeKind.POSITIVE: "+",
@@ -522,22 +534,59 @@ namespace astral.resolving {
     }
 
     void resolveBinary(Node node, Scope scope) {
-      resolveNode(node.binaryLeft(), scope)
-      resolveNode(node.binaryRight(), scope)
+      var left = node.binaryLeft()
+      var right = node.binaryRight()
+
+      resolveNode(left, scope)
+      resolveNode(right, scope)
+
+      if (node.kind.isBinaryComparison() && left.resolvedType == cache.intType && right.resolvedType == cache.intType) {
+        // Skip this for now or it will expand infinitely with "<=>"
+      }
+
+      else if (node.kind != .ASSIGN) {
+        resolveOperatorOverload(node, scope)
+      }
+    }
+
+    void resolveIndex(Node node, Scope scope) {
+      resolveChildren(node, scope)
       resolveOperatorOverload(node, scope)
     }
 
     void resolveOperatorOverload(Node node, Scope scope) {
       var target = node.children[0]
-      if (target.resolvedType != .DYNAMIC) {
-        var name = operatorOverloadNames.getOrDefault(node.kind, "")
-        if (name != "") {
-          node.kind = .CALL
-          node.replaceChild(0, Node.createDot(target.replaceWithNull(), name).withRange(node.internalRange).withInternalRange(node.internalRange))
-          node.resolvedType = null
-          resolveNode(node, scope)
-        }
+      if (target.resolvedType == .DYNAMIC) {
+        return
+      }
+
+      // The name should exist because all special-cases should already be handled
+      var name = operatorOverloadNames.getOrDefault(node.kind, "")
+      assert name != ""
+
+      // Find the operator method
+      var symbol = findMember(target.resolvedType, name, node.internalRange)
+      if (symbol == null) {
+        return
       }
+
+      var children = node.removeChildren()
+      children[0] = Node.createDot(children[0], name).withRange(node.internalRange).withInternalRange(node.internalRange)
+
+      // Implement the logic for the "<=>" operator
+      if (node.kind.isBinaryComparison()) {
+        node.appendChild(Node(.CALL).withChildren(children))
+        node.appendChild(Node.createInt(0))
+      }
+
+      // All other operators are just normal method calls
+      else {
+        node.kind = .CALL
+        node.withChildren(children)
+      }
+
+      node.resolvedType = null
+      resolveNode(node, scope)
     }
 
     Node defaultValueForType(Type type) {
